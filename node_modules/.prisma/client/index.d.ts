
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ResponsableFiliere
 * 
 */
export type ResponsableFiliere = $Result.DefaultSelection<Prisma.$ResponsableFilierePayload>
/**
 * Model Encadrant
 * 
 */
export type Encadrant = $Result.DefaultSelection<Prisma.$EncadrantPayload>
/**
 * Model Tuteur
 * 
 */
export type Tuteur = $Result.DefaultSelection<Prisma.$TuteurPayload>
/**
 * Model Etudiant
 * 
 */
export type Etudiant = $Result.DefaultSelection<Prisma.$EtudiantPayload>
/**
 * Model Groupe
 * 
 */
export type Groupe = $Result.DefaultSelection<Prisma.$GroupePayload>
/**
 * Model EtudiantGroupe
 * 
 */
export type EtudiantGroupe = $Result.DefaultSelection<Prisma.$EtudiantGroupePayload>
/**
 * Model Sujet
 * 
 */
export type Sujet = $Result.DefaultSelection<Prisma.$SujetPayload>
/**
 * Model EtudiantSujet
 * 
 */
export type EtudiantSujet = $Result.DefaultSelection<Prisma.$EtudiantSujetPayload>
/**
 * Model Jury
 * 
 */
export type Jury = $Result.DefaultSelection<Prisma.$JuryPayload>
/**
 * Model Soutenance
 * 
 */
export type Soutenance = $Result.DefaultSelection<Prisma.$SoutenancePayload>
/**
 * Model Evaluation
 * 
 */
export type Evaluation = $Result.DefaultSelection<Prisma.$EvaluationPayload>
/**
 * Model Livrable
 * 
 */
export type Livrable = $Result.DefaultSelection<Prisma.$LivrablePayload>
/**
 * Model PFE
 * 
 */
export type PFE = $Result.DefaultSelection<Prisma.$PFEPayload>
/**
 * Model PFE_Groupe
 * 
 */
export type PFE_Groupe = $Result.DefaultSelection<Prisma.$PFE_GroupePayload>
/**
 * Model PFE_Livrable
 * 
 */
export type PFE_Livrable = $Result.DefaultSelection<Prisma.$PFE_LivrablePayload>
/**
 * Model EncadrantLivrable
 * 
 */
export type EncadrantLivrable = $Result.DefaultSelection<Prisma.$EncadrantLivrablePayload>
/**
 * Model TuteurLivrable
 * 
 */
export type TuteurLivrable = $Result.DefaultSelection<Prisma.$TuteurLivrablePayload>
/**
 * Model EncadrantSoutenance
 * 
 */
export type EncadrantSoutenance = $Result.DefaultSelection<Prisma.$EncadrantSoutenancePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ResponsableFilieres
 * const responsableFilieres = await prisma.responsableFiliere.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ResponsableFilieres
   * const responsableFilieres = await prisma.responsableFiliere.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.responsableFiliere`: Exposes CRUD operations for the **ResponsableFiliere** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResponsableFilieres
    * const responsableFilieres = await prisma.responsableFiliere.findMany()
    * ```
    */
  get responsableFiliere(): Prisma.ResponsableFiliereDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encadrant`: Exposes CRUD operations for the **Encadrant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encadrants
    * const encadrants = await prisma.encadrant.findMany()
    * ```
    */
  get encadrant(): Prisma.EncadrantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tuteur`: Exposes CRUD operations for the **Tuteur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tuteurs
    * const tuteurs = await prisma.tuteur.findMany()
    * ```
    */
  get tuteur(): Prisma.TuteurDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.etudiant`: Exposes CRUD operations for the **Etudiant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Etudiants
    * const etudiants = await prisma.etudiant.findMany()
    * ```
    */
  get etudiant(): Prisma.EtudiantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupe`: Exposes CRUD operations for the **Groupe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groupes
    * const groupes = await prisma.groupe.findMany()
    * ```
    */
  get groupe(): Prisma.GroupeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.etudiantGroupe`: Exposes CRUD operations for the **EtudiantGroupe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EtudiantGroupes
    * const etudiantGroupes = await prisma.etudiantGroupe.findMany()
    * ```
    */
  get etudiantGroupe(): Prisma.EtudiantGroupeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sujet`: Exposes CRUD operations for the **Sujet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sujets
    * const sujets = await prisma.sujet.findMany()
    * ```
    */
  get sujet(): Prisma.SujetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.etudiantSujet`: Exposes CRUD operations for the **EtudiantSujet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EtudiantSujets
    * const etudiantSujets = await prisma.etudiantSujet.findMany()
    * ```
    */
  get etudiantSujet(): Prisma.EtudiantSujetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jury`: Exposes CRUD operations for the **Jury** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Juries
    * const juries = await prisma.jury.findMany()
    * ```
    */
  get jury(): Prisma.JuryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.soutenance`: Exposes CRUD operations for the **Soutenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Soutenances
    * const soutenances = await prisma.soutenance.findMany()
    * ```
    */
  get soutenance(): Prisma.SoutenanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evaluation`: Exposes CRUD operations for the **Evaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluations
    * const evaluations = await prisma.evaluation.findMany()
    * ```
    */
  get evaluation(): Prisma.EvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.livrable`: Exposes CRUD operations for the **Livrable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Livrables
    * const livrables = await prisma.livrable.findMany()
    * ```
    */
  get livrable(): Prisma.LivrableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pFE`: Exposes CRUD operations for the **PFE** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PFES
    * const pFES = await prisma.pFE.findMany()
    * ```
    */
  get pFE(): Prisma.PFEDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pFE_Groupe`: Exposes CRUD operations for the **PFE_Groupe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PFE_Groupes
    * const pFE_Groupes = await prisma.pFE_Groupe.findMany()
    * ```
    */
  get pFE_Groupe(): Prisma.PFE_GroupeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pFE_Livrable`: Exposes CRUD operations for the **PFE_Livrable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PFE_Livrables
    * const pFE_Livrables = await prisma.pFE_Livrable.findMany()
    * ```
    */
  get pFE_Livrable(): Prisma.PFE_LivrableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encadrantLivrable`: Exposes CRUD operations for the **EncadrantLivrable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncadrantLivrables
    * const encadrantLivrables = await prisma.encadrantLivrable.findMany()
    * ```
    */
  get encadrantLivrable(): Prisma.EncadrantLivrableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tuteurLivrable`: Exposes CRUD operations for the **TuteurLivrable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TuteurLivrables
    * const tuteurLivrables = await prisma.tuteurLivrable.findMany()
    * ```
    */
  get tuteurLivrable(): Prisma.TuteurLivrableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encadrantSoutenance`: Exposes CRUD operations for the **EncadrantSoutenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncadrantSoutenances
    * const encadrantSoutenances = await prisma.encadrantSoutenance.findMany()
    * ```
    */
  get encadrantSoutenance(): Prisma.EncadrantSoutenanceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.0
   * Query Engine version: a9055b89e58b4b5bfb59600785423b1db3d0e75d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ResponsableFiliere: 'ResponsableFiliere',
    Encadrant: 'Encadrant',
    Tuteur: 'Tuteur',
    Etudiant: 'Etudiant',
    Groupe: 'Groupe',
    EtudiantGroupe: 'EtudiantGroupe',
    Sujet: 'Sujet',
    EtudiantSujet: 'EtudiantSujet',
    Jury: 'Jury',
    Soutenance: 'Soutenance',
    Evaluation: 'Evaluation',
    Livrable: 'Livrable',
    PFE: 'PFE',
    PFE_Groupe: 'PFE_Groupe',
    PFE_Livrable: 'PFE_Livrable',
    EncadrantLivrable: 'EncadrantLivrable',
    TuteurLivrable: 'TuteurLivrable',
    EncadrantSoutenance: 'EncadrantSoutenance'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "responsableFiliere" | "encadrant" | "tuteur" | "etudiant" | "groupe" | "etudiantGroupe" | "sujet" | "etudiantSujet" | "jury" | "soutenance" | "evaluation" | "livrable" | "pFE" | "pFE_Groupe" | "pFE_Livrable" | "encadrantLivrable" | "tuteurLivrable" | "encadrantSoutenance"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ResponsableFiliere: {
        payload: Prisma.$ResponsableFilierePayload<ExtArgs>
        fields: Prisma.ResponsableFiliereFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResponsableFiliereFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsableFilierePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResponsableFiliereFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsableFilierePayload>
          }
          findFirst: {
            args: Prisma.ResponsableFiliereFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsableFilierePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResponsableFiliereFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsableFilierePayload>
          }
          findMany: {
            args: Prisma.ResponsableFiliereFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsableFilierePayload>[]
          }
          create: {
            args: Prisma.ResponsableFiliereCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsableFilierePayload>
          }
          createMany: {
            args: Prisma.ResponsableFiliereCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ResponsableFiliereDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsableFilierePayload>
          }
          update: {
            args: Prisma.ResponsableFiliereUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsableFilierePayload>
          }
          deleteMany: {
            args: Prisma.ResponsableFiliereDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResponsableFiliereUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResponsableFiliereUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsableFilierePayload>
          }
          aggregate: {
            args: Prisma.ResponsableFiliereAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponsableFiliere>
          }
          groupBy: {
            args: Prisma.ResponsableFiliereGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResponsableFiliereGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResponsableFiliereCountArgs<ExtArgs>
            result: $Utils.Optional<ResponsableFiliereCountAggregateOutputType> | number
          }
        }
      }
      Encadrant: {
        payload: Prisma.$EncadrantPayload<ExtArgs>
        fields: Prisma.EncadrantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncadrantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncadrantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantPayload>
          }
          findFirst: {
            args: Prisma.EncadrantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncadrantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantPayload>
          }
          findMany: {
            args: Prisma.EncadrantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantPayload>[]
          }
          create: {
            args: Prisma.EncadrantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantPayload>
          }
          createMany: {
            args: Prisma.EncadrantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EncadrantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantPayload>
          }
          update: {
            args: Prisma.EncadrantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantPayload>
          }
          deleteMany: {
            args: Prisma.EncadrantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncadrantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncadrantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantPayload>
          }
          aggregate: {
            args: Prisma.EncadrantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncadrant>
          }
          groupBy: {
            args: Prisma.EncadrantGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncadrantGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncadrantCountArgs<ExtArgs>
            result: $Utils.Optional<EncadrantCountAggregateOutputType> | number
          }
        }
      }
      Tuteur: {
        payload: Prisma.$TuteurPayload<ExtArgs>
        fields: Prisma.TuteurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TuteurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TuteurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurPayload>
          }
          findFirst: {
            args: Prisma.TuteurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TuteurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurPayload>
          }
          findMany: {
            args: Prisma.TuteurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurPayload>[]
          }
          create: {
            args: Prisma.TuteurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurPayload>
          }
          createMany: {
            args: Prisma.TuteurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TuteurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurPayload>
          }
          update: {
            args: Prisma.TuteurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurPayload>
          }
          deleteMany: {
            args: Prisma.TuteurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TuteurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TuteurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurPayload>
          }
          aggregate: {
            args: Prisma.TuteurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTuteur>
          }
          groupBy: {
            args: Prisma.TuteurGroupByArgs<ExtArgs>
            result: $Utils.Optional<TuteurGroupByOutputType>[]
          }
          count: {
            args: Prisma.TuteurCountArgs<ExtArgs>
            result: $Utils.Optional<TuteurCountAggregateOutputType> | number
          }
        }
      }
      Etudiant: {
        payload: Prisma.$EtudiantPayload<ExtArgs>
        fields: Prisma.EtudiantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtudiantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtudiantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          findFirst: {
            args: Prisma.EtudiantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtudiantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          findMany: {
            args: Prisma.EtudiantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>[]
          }
          create: {
            args: Prisma.EtudiantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          createMany: {
            args: Prisma.EtudiantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EtudiantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          update: {
            args: Prisma.EtudiantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          deleteMany: {
            args: Prisma.EtudiantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EtudiantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EtudiantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantPayload>
          }
          aggregate: {
            args: Prisma.EtudiantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtudiant>
          }
          groupBy: {
            args: Prisma.EtudiantGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtudiantGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtudiantCountArgs<ExtArgs>
            result: $Utils.Optional<EtudiantCountAggregateOutputType> | number
          }
        }
      }
      Groupe: {
        payload: Prisma.$GroupePayload<ExtArgs>
        fields: Prisma.GroupeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          findFirst: {
            args: Prisma.GroupeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          findMany: {
            args: Prisma.GroupeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>[]
          }
          create: {
            args: Prisma.GroupeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          createMany: {
            args: Prisma.GroupeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GroupeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          update: {
            args: Prisma.GroupeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          deleteMany: {
            args: Prisma.GroupeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupePayload>
          }
          aggregate: {
            args: Prisma.GroupeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupe>
          }
          groupBy: {
            args: Prisma.GroupeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupeCountArgs<ExtArgs>
            result: $Utils.Optional<GroupeCountAggregateOutputType> | number
          }
        }
      }
      EtudiantGroupe: {
        payload: Prisma.$EtudiantGroupePayload<ExtArgs>
        fields: Prisma.EtudiantGroupeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtudiantGroupeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantGroupePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtudiantGroupeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantGroupePayload>
          }
          findFirst: {
            args: Prisma.EtudiantGroupeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantGroupePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtudiantGroupeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantGroupePayload>
          }
          findMany: {
            args: Prisma.EtudiantGroupeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantGroupePayload>[]
          }
          create: {
            args: Prisma.EtudiantGroupeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantGroupePayload>
          }
          createMany: {
            args: Prisma.EtudiantGroupeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EtudiantGroupeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantGroupePayload>
          }
          update: {
            args: Prisma.EtudiantGroupeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantGroupePayload>
          }
          deleteMany: {
            args: Prisma.EtudiantGroupeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EtudiantGroupeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EtudiantGroupeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantGroupePayload>
          }
          aggregate: {
            args: Prisma.EtudiantGroupeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtudiantGroupe>
          }
          groupBy: {
            args: Prisma.EtudiantGroupeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtudiantGroupeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtudiantGroupeCountArgs<ExtArgs>
            result: $Utils.Optional<EtudiantGroupeCountAggregateOutputType> | number
          }
        }
      }
      Sujet: {
        payload: Prisma.$SujetPayload<ExtArgs>
        fields: Prisma.SujetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SujetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SujetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SujetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SujetPayload>
          }
          findFirst: {
            args: Prisma.SujetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SujetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SujetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SujetPayload>
          }
          findMany: {
            args: Prisma.SujetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SujetPayload>[]
          }
          create: {
            args: Prisma.SujetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SujetPayload>
          }
          createMany: {
            args: Prisma.SujetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SujetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SujetPayload>
          }
          update: {
            args: Prisma.SujetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SujetPayload>
          }
          deleteMany: {
            args: Prisma.SujetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SujetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SujetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SujetPayload>
          }
          aggregate: {
            args: Prisma.SujetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSujet>
          }
          groupBy: {
            args: Prisma.SujetGroupByArgs<ExtArgs>
            result: $Utils.Optional<SujetGroupByOutputType>[]
          }
          count: {
            args: Prisma.SujetCountArgs<ExtArgs>
            result: $Utils.Optional<SujetCountAggregateOutputType> | number
          }
        }
      }
      EtudiantSujet: {
        payload: Prisma.$EtudiantSujetPayload<ExtArgs>
        fields: Prisma.EtudiantSujetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EtudiantSujetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantSujetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EtudiantSujetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantSujetPayload>
          }
          findFirst: {
            args: Prisma.EtudiantSujetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantSujetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EtudiantSujetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantSujetPayload>
          }
          findMany: {
            args: Prisma.EtudiantSujetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantSujetPayload>[]
          }
          create: {
            args: Prisma.EtudiantSujetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantSujetPayload>
          }
          createMany: {
            args: Prisma.EtudiantSujetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EtudiantSujetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantSujetPayload>
          }
          update: {
            args: Prisma.EtudiantSujetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantSujetPayload>
          }
          deleteMany: {
            args: Prisma.EtudiantSujetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EtudiantSujetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EtudiantSujetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EtudiantSujetPayload>
          }
          aggregate: {
            args: Prisma.EtudiantSujetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtudiantSujet>
          }
          groupBy: {
            args: Prisma.EtudiantSujetGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtudiantSujetGroupByOutputType>[]
          }
          count: {
            args: Prisma.EtudiantSujetCountArgs<ExtArgs>
            result: $Utils.Optional<EtudiantSujetCountAggregateOutputType> | number
          }
        }
      }
      Jury: {
        payload: Prisma.$JuryPayload<ExtArgs>
        fields: Prisma.JuryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JuryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JuryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuryPayload>
          }
          findFirst: {
            args: Prisma.JuryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JuryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuryPayload>
          }
          findMany: {
            args: Prisma.JuryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuryPayload>[]
          }
          create: {
            args: Prisma.JuryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuryPayload>
          }
          createMany: {
            args: Prisma.JuryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JuryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuryPayload>
          }
          update: {
            args: Prisma.JuryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuryPayload>
          }
          deleteMany: {
            args: Prisma.JuryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JuryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JuryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JuryPayload>
          }
          aggregate: {
            args: Prisma.JuryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJury>
          }
          groupBy: {
            args: Prisma.JuryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JuryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JuryCountArgs<ExtArgs>
            result: $Utils.Optional<JuryCountAggregateOutputType> | number
          }
        }
      }
      Soutenance: {
        payload: Prisma.$SoutenancePayload<ExtArgs>
        fields: Prisma.SoutenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoutenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoutenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          findFirst: {
            args: Prisma.SoutenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoutenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          findMany: {
            args: Prisma.SoutenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>[]
          }
          create: {
            args: Prisma.SoutenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          createMany: {
            args: Prisma.SoutenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SoutenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          update: {
            args: Prisma.SoutenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          deleteMany: {
            args: Prisma.SoutenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SoutenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SoutenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoutenancePayload>
          }
          aggregate: {
            args: Prisma.SoutenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSoutenance>
          }
          groupBy: {
            args: Prisma.SoutenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SoutenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoutenanceCountArgs<ExtArgs>
            result: $Utils.Optional<SoutenanceCountAggregateOutputType> | number
          }
        }
      }
      Evaluation: {
        payload: Prisma.$EvaluationPayload<ExtArgs>
        fields: Prisma.EvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findFirst: {
            args: Prisma.EvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findMany: {
            args: Prisma.EvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          create: {
            args: Prisma.EvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          createMany: {
            args: Prisma.EvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          update: {
            args: Prisma.EvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          aggregate: {
            args: Prisma.EvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluation>
          }
          groupBy: {
            args: Prisma.EvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationCountAggregateOutputType> | number
          }
        }
      }
      Livrable: {
        payload: Prisma.$LivrablePayload<ExtArgs>
        fields: Prisma.LivrableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LivrableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LivrableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrablePayload>
          }
          findFirst: {
            args: Prisma.LivrableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LivrableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrablePayload>
          }
          findMany: {
            args: Prisma.LivrableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrablePayload>[]
          }
          create: {
            args: Prisma.LivrableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrablePayload>
          }
          createMany: {
            args: Prisma.LivrableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LivrableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrablePayload>
          }
          update: {
            args: Prisma.LivrableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrablePayload>
          }
          deleteMany: {
            args: Prisma.LivrableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LivrableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LivrableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrablePayload>
          }
          aggregate: {
            args: Prisma.LivrableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLivrable>
          }
          groupBy: {
            args: Prisma.LivrableGroupByArgs<ExtArgs>
            result: $Utils.Optional<LivrableGroupByOutputType>[]
          }
          count: {
            args: Prisma.LivrableCountArgs<ExtArgs>
            result: $Utils.Optional<LivrableCountAggregateOutputType> | number
          }
        }
      }
      PFE: {
        payload: Prisma.$PFEPayload<ExtArgs>
        fields: Prisma.PFEFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PFEFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFEPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PFEFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFEPayload>
          }
          findFirst: {
            args: Prisma.PFEFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFEPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PFEFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFEPayload>
          }
          findMany: {
            args: Prisma.PFEFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFEPayload>[]
          }
          create: {
            args: Prisma.PFECreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFEPayload>
          }
          createMany: {
            args: Prisma.PFECreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PFEDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFEPayload>
          }
          update: {
            args: Prisma.PFEUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFEPayload>
          }
          deleteMany: {
            args: Prisma.PFEDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PFEUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PFEUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFEPayload>
          }
          aggregate: {
            args: Prisma.PFEAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePFE>
          }
          groupBy: {
            args: Prisma.PFEGroupByArgs<ExtArgs>
            result: $Utils.Optional<PFEGroupByOutputType>[]
          }
          count: {
            args: Prisma.PFECountArgs<ExtArgs>
            result: $Utils.Optional<PFECountAggregateOutputType> | number
          }
        }
      }
      PFE_Groupe: {
        payload: Prisma.$PFE_GroupePayload<ExtArgs>
        fields: Prisma.PFE_GroupeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PFE_GroupeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_GroupePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PFE_GroupeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_GroupePayload>
          }
          findFirst: {
            args: Prisma.PFE_GroupeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_GroupePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PFE_GroupeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_GroupePayload>
          }
          findMany: {
            args: Prisma.PFE_GroupeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_GroupePayload>[]
          }
          create: {
            args: Prisma.PFE_GroupeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_GroupePayload>
          }
          createMany: {
            args: Prisma.PFE_GroupeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PFE_GroupeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_GroupePayload>
          }
          update: {
            args: Prisma.PFE_GroupeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_GroupePayload>
          }
          deleteMany: {
            args: Prisma.PFE_GroupeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PFE_GroupeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PFE_GroupeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_GroupePayload>
          }
          aggregate: {
            args: Prisma.PFE_GroupeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePFE_Groupe>
          }
          groupBy: {
            args: Prisma.PFE_GroupeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PFE_GroupeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PFE_GroupeCountArgs<ExtArgs>
            result: $Utils.Optional<PFE_GroupeCountAggregateOutputType> | number
          }
        }
      }
      PFE_Livrable: {
        payload: Prisma.$PFE_LivrablePayload<ExtArgs>
        fields: Prisma.PFE_LivrableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PFE_LivrableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_LivrablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PFE_LivrableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_LivrablePayload>
          }
          findFirst: {
            args: Prisma.PFE_LivrableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_LivrablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PFE_LivrableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_LivrablePayload>
          }
          findMany: {
            args: Prisma.PFE_LivrableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_LivrablePayload>[]
          }
          create: {
            args: Prisma.PFE_LivrableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_LivrablePayload>
          }
          createMany: {
            args: Prisma.PFE_LivrableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PFE_LivrableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_LivrablePayload>
          }
          update: {
            args: Prisma.PFE_LivrableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_LivrablePayload>
          }
          deleteMany: {
            args: Prisma.PFE_LivrableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PFE_LivrableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PFE_LivrableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PFE_LivrablePayload>
          }
          aggregate: {
            args: Prisma.PFE_LivrableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePFE_Livrable>
          }
          groupBy: {
            args: Prisma.PFE_LivrableGroupByArgs<ExtArgs>
            result: $Utils.Optional<PFE_LivrableGroupByOutputType>[]
          }
          count: {
            args: Prisma.PFE_LivrableCountArgs<ExtArgs>
            result: $Utils.Optional<PFE_LivrableCountAggregateOutputType> | number
          }
        }
      }
      EncadrantLivrable: {
        payload: Prisma.$EncadrantLivrablePayload<ExtArgs>
        fields: Prisma.EncadrantLivrableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncadrantLivrableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantLivrablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncadrantLivrableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantLivrablePayload>
          }
          findFirst: {
            args: Prisma.EncadrantLivrableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantLivrablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncadrantLivrableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantLivrablePayload>
          }
          findMany: {
            args: Prisma.EncadrantLivrableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantLivrablePayload>[]
          }
          create: {
            args: Prisma.EncadrantLivrableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantLivrablePayload>
          }
          createMany: {
            args: Prisma.EncadrantLivrableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EncadrantLivrableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantLivrablePayload>
          }
          update: {
            args: Prisma.EncadrantLivrableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantLivrablePayload>
          }
          deleteMany: {
            args: Prisma.EncadrantLivrableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncadrantLivrableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncadrantLivrableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantLivrablePayload>
          }
          aggregate: {
            args: Prisma.EncadrantLivrableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncadrantLivrable>
          }
          groupBy: {
            args: Prisma.EncadrantLivrableGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncadrantLivrableGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncadrantLivrableCountArgs<ExtArgs>
            result: $Utils.Optional<EncadrantLivrableCountAggregateOutputType> | number
          }
        }
      }
      TuteurLivrable: {
        payload: Prisma.$TuteurLivrablePayload<ExtArgs>
        fields: Prisma.TuteurLivrableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TuteurLivrableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurLivrablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TuteurLivrableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurLivrablePayload>
          }
          findFirst: {
            args: Prisma.TuteurLivrableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurLivrablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TuteurLivrableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurLivrablePayload>
          }
          findMany: {
            args: Prisma.TuteurLivrableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurLivrablePayload>[]
          }
          create: {
            args: Prisma.TuteurLivrableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurLivrablePayload>
          }
          createMany: {
            args: Prisma.TuteurLivrableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TuteurLivrableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurLivrablePayload>
          }
          update: {
            args: Prisma.TuteurLivrableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurLivrablePayload>
          }
          deleteMany: {
            args: Prisma.TuteurLivrableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TuteurLivrableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TuteurLivrableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuteurLivrablePayload>
          }
          aggregate: {
            args: Prisma.TuteurLivrableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTuteurLivrable>
          }
          groupBy: {
            args: Prisma.TuteurLivrableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TuteurLivrableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TuteurLivrableCountArgs<ExtArgs>
            result: $Utils.Optional<TuteurLivrableCountAggregateOutputType> | number
          }
        }
      }
      EncadrantSoutenance: {
        payload: Prisma.$EncadrantSoutenancePayload<ExtArgs>
        fields: Prisma.EncadrantSoutenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncadrantSoutenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantSoutenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncadrantSoutenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantSoutenancePayload>
          }
          findFirst: {
            args: Prisma.EncadrantSoutenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantSoutenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncadrantSoutenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantSoutenancePayload>
          }
          findMany: {
            args: Prisma.EncadrantSoutenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantSoutenancePayload>[]
          }
          create: {
            args: Prisma.EncadrantSoutenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantSoutenancePayload>
          }
          createMany: {
            args: Prisma.EncadrantSoutenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EncadrantSoutenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantSoutenancePayload>
          }
          update: {
            args: Prisma.EncadrantSoutenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantSoutenancePayload>
          }
          deleteMany: {
            args: Prisma.EncadrantSoutenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncadrantSoutenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncadrantSoutenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncadrantSoutenancePayload>
          }
          aggregate: {
            args: Prisma.EncadrantSoutenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncadrantSoutenance>
          }
          groupBy: {
            args: Prisma.EncadrantSoutenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncadrantSoutenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncadrantSoutenanceCountArgs<ExtArgs>
            result: $Utils.Optional<EncadrantSoutenanceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    responsableFiliere?: ResponsableFiliereOmit
    encadrant?: EncadrantOmit
    tuteur?: TuteurOmit
    etudiant?: EtudiantOmit
    groupe?: GroupeOmit
    etudiantGroupe?: EtudiantGroupeOmit
    sujet?: SujetOmit
    etudiantSujet?: EtudiantSujetOmit
    jury?: JuryOmit
    soutenance?: SoutenanceOmit
    evaluation?: EvaluationOmit
    livrable?: LivrableOmit
    pFE?: PFEOmit
    pFE_Groupe?: PFE_GroupeOmit
    pFE_Livrable?: PFE_LivrableOmit
    encadrantLivrable?: EncadrantLivrableOmit
    tuteurLivrable?: TuteurLivrableOmit
    encadrantSoutenance?: EncadrantSoutenanceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ResponsableFiliereCountOutputType
   */

  export type ResponsableFiliereCountOutputType = {
    encadrants: number
  }

  export type ResponsableFiliereCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encadrants?: boolean | ResponsableFiliereCountOutputTypeCountEncadrantsArgs
  }

  // Custom InputTypes
  /**
   * ResponsableFiliereCountOutputType without action
   */
  export type ResponsableFiliereCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliereCountOutputType
     */
    select?: ResponsableFiliereCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResponsableFiliereCountOutputType without action
   */
  export type ResponsableFiliereCountOutputTypeCountEncadrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncadrantWhereInput
  }


  /**
   * Count Type EncadrantCountOutputType
   */

  export type EncadrantCountOutputType = {
    sujets: number
    soutenances: number
    livrables: number
  }

  export type EncadrantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sujets?: boolean | EncadrantCountOutputTypeCountSujetsArgs
    soutenances?: boolean | EncadrantCountOutputTypeCountSoutenancesArgs
    livrables?: boolean | EncadrantCountOutputTypeCountLivrablesArgs
  }

  // Custom InputTypes
  /**
   * EncadrantCountOutputType without action
   */
  export type EncadrantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantCountOutputType
     */
    select?: EncadrantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncadrantCountOutputType without action
   */
  export type EncadrantCountOutputTypeCountSujetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SujetWhereInput
  }

  /**
   * EncadrantCountOutputType without action
   */
  export type EncadrantCountOutputTypeCountSoutenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncadrantSoutenanceWhereInput
  }

  /**
   * EncadrantCountOutputType without action
   */
  export type EncadrantCountOutputTypeCountLivrablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncadrantLivrableWhereInput
  }


  /**
   * Count Type TuteurCountOutputType
   */

  export type TuteurCountOutputType = {
    PFEs: number
    livrables: number
  }

  export type TuteurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PFEs?: boolean | TuteurCountOutputTypeCountPFEsArgs
    livrables?: boolean | TuteurCountOutputTypeCountLivrablesArgs
  }

  // Custom InputTypes
  /**
   * TuteurCountOutputType without action
   */
  export type TuteurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurCountOutputType
     */
    select?: TuteurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TuteurCountOutputType without action
   */
  export type TuteurCountOutputTypeCountPFEsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PFEWhereInput
  }

  /**
   * TuteurCountOutputType without action
   */
  export type TuteurCountOutputTypeCountLivrablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TuteurLivrableWhereInput
  }


  /**
   * Count Type EtudiantCountOutputType
   */

  export type EtudiantCountOutputType = {
    groupes: number
    sujets: number
    evaluations: number
  }

  export type EtudiantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupes?: boolean | EtudiantCountOutputTypeCountGroupesArgs
    sujets?: boolean | EtudiantCountOutputTypeCountSujetsArgs
    evaluations?: boolean | EtudiantCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantCountOutputType
     */
    select?: EtudiantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountGroupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtudiantGroupeWhereInput
  }

  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountSujetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtudiantSujetWhereInput
  }

  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type GroupeCountOutputType
   */

  export type GroupeCountOutputType = {
    etudiants: number
    PFEs: number
  }

  export type GroupeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etudiants?: boolean | GroupeCountOutputTypeCountEtudiantsArgs
    PFEs?: boolean | GroupeCountOutputTypeCountPFEsArgs
  }

  // Custom InputTypes
  /**
   * GroupeCountOutputType without action
   */
  export type GroupeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupeCountOutputType
     */
    select?: GroupeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupeCountOutputType without action
   */
  export type GroupeCountOutputTypeCountEtudiantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtudiantGroupeWhereInput
  }

  /**
   * GroupeCountOutputType without action
   */
  export type GroupeCountOutputTypeCountPFEsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PFE_GroupeWhereInput
  }


  /**
   * Count Type SujetCountOutputType
   */

  export type SujetCountOutputType = {
    etudiants: number
  }

  export type SujetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etudiants?: boolean | SujetCountOutputTypeCountEtudiantsArgs
  }

  // Custom InputTypes
  /**
   * SujetCountOutputType without action
   */
  export type SujetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SujetCountOutputType
     */
    select?: SujetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SujetCountOutputType without action
   */
  export type SujetCountOutputTypeCountEtudiantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtudiantSujetWhereInput
  }


  /**
   * Count Type JuryCountOutputType
   */

  export type JuryCountOutputType = {
    soutenances: number
  }

  export type JuryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soutenances?: boolean | JuryCountOutputTypeCountSoutenancesArgs
  }

  // Custom InputTypes
  /**
   * JuryCountOutputType without action
   */
  export type JuryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JuryCountOutputType
     */
    select?: JuryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JuryCountOutputType without action
   */
  export type JuryCountOutputTypeCountSoutenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoutenanceWhereInput
  }


  /**
   * Count Type SoutenanceCountOutputType
   */

  export type SoutenanceCountOutputType = {
    encadrants: number
    evaluations: number
  }

  export type SoutenanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encadrants?: boolean | SoutenanceCountOutputTypeCountEncadrantsArgs
    evaluations?: boolean | SoutenanceCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * SoutenanceCountOutputType without action
   */
  export type SoutenanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoutenanceCountOutputType
     */
    select?: SoutenanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SoutenanceCountOutputType without action
   */
  export type SoutenanceCountOutputTypeCountEncadrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncadrantSoutenanceWhereInput
  }

  /**
   * SoutenanceCountOutputType without action
   */
  export type SoutenanceCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * Count Type LivrableCountOutputType
   */

  export type LivrableCountOutputType = {
    PFEs: number
    encadrants: number
    tuteurs: number
  }

  export type LivrableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PFEs?: boolean | LivrableCountOutputTypeCountPFEsArgs
    encadrants?: boolean | LivrableCountOutputTypeCountEncadrantsArgs
    tuteurs?: boolean | LivrableCountOutputTypeCountTuteursArgs
  }

  // Custom InputTypes
  /**
   * LivrableCountOutputType without action
   */
  export type LivrableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivrableCountOutputType
     */
    select?: LivrableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LivrableCountOutputType without action
   */
  export type LivrableCountOutputTypeCountPFEsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PFE_LivrableWhereInput
  }

  /**
   * LivrableCountOutputType without action
   */
  export type LivrableCountOutputTypeCountEncadrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncadrantLivrableWhereInput
  }

  /**
   * LivrableCountOutputType without action
   */
  export type LivrableCountOutputTypeCountTuteursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TuteurLivrableWhereInput
  }


  /**
   * Count Type PFECountOutputType
   */

  export type PFECountOutputType = {
    groupes: number
    livrables: number
  }

  export type PFECountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupes?: boolean | PFECountOutputTypeCountGroupesArgs
    livrables?: boolean | PFECountOutputTypeCountLivrablesArgs
  }

  // Custom InputTypes
  /**
   * PFECountOutputType without action
   */
  export type PFECountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFECountOutputType
     */
    select?: PFECountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PFECountOutputType without action
   */
  export type PFECountOutputTypeCountGroupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PFE_GroupeWhereInput
  }

  /**
   * PFECountOutputType without action
   */
  export type PFECountOutputTypeCountLivrablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PFE_LivrableWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ResponsableFiliere
   */

  export type AggregateResponsableFiliere = {
    _count: ResponsableFiliereCountAggregateOutputType | null
    _avg: ResponsableFiliereAvgAggregateOutputType | null
    _sum: ResponsableFiliereSumAggregateOutputType | null
    _min: ResponsableFiliereMinAggregateOutputType | null
    _max: ResponsableFiliereMaxAggregateOutputType | null
  }

  export type ResponsableFiliereAvgAggregateOutputType = {
    idResponsableFiliere: number | null
    annee: number | null
  }

  export type ResponsableFiliereSumAggregateOutputType = {
    idResponsableFiliere: number | null
    annee: number | null
  }

  export type ResponsableFiliereMinAggregateOutputType = {
    idResponsableFiliere: number | null
    nom: string | null
    prenom: string | null
    email: string | null
    motDePasse: string | null
    departement: string | null
    annee: number | null
  }

  export type ResponsableFiliereMaxAggregateOutputType = {
    idResponsableFiliere: number | null
    nom: string | null
    prenom: string | null
    email: string | null
    motDePasse: string | null
    departement: string | null
    annee: number | null
  }

  export type ResponsableFiliereCountAggregateOutputType = {
    idResponsableFiliere: number
    nom: number
    prenom: number
    email: number
    motDePasse: number
    departement: number
    annee: number
    _all: number
  }


  export type ResponsableFiliereAvgAggregateInputType = {
    idResponsableFiliere?: true
    annee?: true
  }

  export type ResponsableFiliereSumAggregateInputType = {
    idResponsableFiliere?: true
    annee?: true
  }

  export type ResponsableFiliereMinAggregateInputType = {
    idResponsableFiliere?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    departement?: true
    annee?: true
  }

  export type ResponsableFiliereMaxAggregateInputType = {
    idResponsableFiliere?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    departement?: true
    annee?: true
  }

  export type ResponsableFiliereCountAggregateInputType = {
    idResponsableFiliere?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    departement?: true
    annee?: true
    _all?: true
  }

  export type ResponsableFiliereAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponsableFiliere to aggregate.
     */
    where?: ResponsableFiliereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsableFilieres to fetch.
     */
    orderBy?: ResponsableFiliereOrderByWithRelationInput | ResponsableFiliereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResponsableFiliereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsableFilieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsableFilieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResponsableFilieres
    **/
    _count?: true | ResponsableFiliereCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResponsableFiliereAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResponsableFiliereSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponsableFiliereMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponsableFiliereMaxAggregateInputType
  }

  export type GetResponsableFiliereAggregateType<T extends ResponsableFiliereAggregateArgs> = {
        [P in keyof T & keyof AggregateResponsableFiliere]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponsableFiliere[P]>
      : GetScalarType<T[P], AggregateResponsableFiliere[P]>
  }




  export type ResponsableFiliereGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponsableFiliereWhereInput
    orderBy?: ResponsableFiliereOrderByWithAggregationInput | ResponsableFiliereOrderByWithAggregationInput[]
    by: ResponsableFiliereScalarFieldEnum[] | ResponsableFiliereScalarFieldEnum
    having?: ResponsableFiliereScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponsableFiliereCountAggregateInputType | true
    _avg?: ResponsableFiliereAvgAggregateInputType
    _sum?: ResponsableFiliereSumAggregateInputType
    _min?: ResponsableFiliereMinAggregateInputType
    _max?: ResponsableFiliereMaxAggregateInputType
  }

  export type ResponsableFiliereGroupByOutputType = {
    idResponsableFiliere: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    departement: string
    annee: number
    _count: ResponsableFiliereCountAggregateOutputType | null
    _avg: ResponsableFiliereAvgAggregateOutputType | null
    _sum: ResponsableFiliereSumAggregateOutputType | null
    _min: ResponsableFiliereMinAggregateOutputType | null
    _max: ResponsableFiliereMaxAggregateOutputType | null
  }

  type GetResponsableFiliereGroupByPayload<T extends ResponsableFiliereGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponsableFiliereGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponsableFiliereGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponsableFiliereGroupByOutputType[P]>
            : GetScalarType<T[P], ResponsableFiliereGroupByOutputType[P]>
        }
      >
    >


  export type ResponsableFiliereSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idResponsableFiliere?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    motDePasse?: boolean
    departement?: boolean
    annee?: boolean
    encadrants?: boolean | ResponsableFiliere$encadrantsArgs<ExtArgs>
    _count?: boolean | ResponsableFiliereCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["responsableFiliere"]>



  export type ResponsableFiliereSelectScalar = {
    idResponsableFiliere?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    motDePasse?: boolean
    departement?: boolean
    annee?: boolean
  }

  export type ResponsableFiliereOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idResponsableFiliere" | "nom" | "prenom" | "email" | "motDePasse" | "departement" | "annee", ExtArgs["result"]["responsableFiliere"]>
  export type ResponsableFiliereInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encadrants?: boolean | ResponsableFiliere$encadrantsArgs<ExtArgs>
    _count?: boolean | ResponsableFiliereCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ResponsableFilierePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResponsableFiliere"
    objects: {
      encadrants: Prisma.$EncadrantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idResponsableFiliere: number
      nom: string
      prenom: string
      email: string
      motDePasse: string
      departement: string
      annee: number
    }, ExtArgs["result"]["responsableFiliere"]>
    composites: {}
  }

  type ResponsableFiliereGetPayload<S extends boolean | null | undefined | ResponsableFiliereDefaultArgs> = $Result.GetResult<Prisma.$ResponsableFilierePayload, S>

  type ResponsableFiliereCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResponsableFiliereFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResponsableFiliereCountAggregateInputType | true
    }

  export interface ResponsableFiliereDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResponsableFiliere'], meta: { name: 'ResponsableFiliere' } }
    /**
     * Find zero or one ResponsableFiliere that matches the filter.
     * @param {ResponsableFiliereFindUniqueArgs} args - Arguments to find a ResponsableFiliere
     * @example
     * // Get one ResponsableFiliere
     * const responsableFiliere = await prisma.responsableFiliere.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResponsableFiliereFindUniqueArgs>(args: SelectSubset<T, ResponsableFiliereFindUniqueArgs<ExtArgs>>): Prisma__ResponsableFiliereClient<$Result.GetResult<Prisma.$ResponsableFilierePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ResponsableFiliere that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResponsableFiliereFindUniqueOrThrowArgs} args - Arguments to find a ResponsableFiliere
     * @example
     * // Get one ResponsableFiliere
     * const responsableFiliere = await prisma.responsableFiliere.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResponsableFiliereFindUniqueOrThrowArgs>(args: SelectSubset<T, ResponsableFiliereFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResponsableFiliereClient<$Result.GetResult<Prisma.$ResponsableFilierePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ResponsableFiliere that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsableFiliereFindFirstArgs} args - Arguments to find a ResponsableFiliere
     * @example
     * // Get one ResponsableFiliere
     * const responsableFiliere = await prisma.responsableFiliere.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResponsableFiliereFindFirstArgs>(args?: SelectSubset<T, ResponsableFiliereFindFirstArgs<ExtArgs>>): Prisma__ResponsableFiliereClient<$Result.GetResult<Prisma.$ResponsableFilierePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ResponsableFiliere that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsableFiliereFindFirstOrThrowArgs} args - Arguments to find a ResponsableFiliere
     * @example
     * // Get one ResponsableFiliere
     * const responsableFiliere = await prisma.responsableFiliere.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResponsableFiliereFindFirstOrThrowArgs>(args?: SelectSubset<T, ResponsableFiliereFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResponsableFiliereClient<$Result.GetResult<Prisma.$ResponsableFilierePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ResponsableFilieres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsableFiliereFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResponsableFilieres
     * const responsableFilieres = await prisma.responsableFiliere.findMany()
     * 
     * // Get first 10 ResponsableFilieres
     * const responsableFilieres = await prisma.responsableFiliere.findMany({ take: 10 })
     * 
     * // Only select the `idResponsableFiliere`
     * const responsableFiliereWithIdResponsableFiliereOnly = await prisma.responsableFiliere.findMany({ select: { idResponsableFiliere: true } })
     * 
     */
    findMany<T extends ResponsableFiliereFindManyArgs>(args?: SelectSubset<T, ResponsableFiliereFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsableFilierePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ResponsableFiliere.
     * @param {ResponsableFiliereCreateArgs} args - Arguments to create a ResponsableFiliere.
     * @example
     * // Create one ResponsableFiliere
     * const ResponsableFiliere = await prisma.responsableFiliere.create({
     *   data: {
     *     // ... data to create a ResponsableFiliere
     *   }
     * })
     * 
     */
    create<T extends ResponsableFiliereCreateArgs>(args: SelectSubset<T, ResponsableFiliereCreateArgs<ExtArgs>>): Prisma__ResponsableFiliereClient<$Result.GetResult<Prisma.$ResponsableFilierePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ResponsableFilieres.
     * @param {ResponsableFiliereCreateManyArgs} args - Arguments to create many ResponsableFilieres.
     * @example
     * // Create many ResponsableFilieres
     * const responsableFiliere = await prisma.responsableFiliere.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResponsableFiliereCreateManyArgs>(args?: SelectSubset<T, ResponsableFiliereCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResponsableFiliere.
     * @param {ResponsableFiliereDeleteArgs} args - Arguments to delete one ResponsableFiliere.
     * @example
     * // Delete one ResponsableFiliere
     * const ResponsableFiliere = await prisma.responsableFiliere.delete({
     *   where: {
     *     // ... filter to delete one ResponsableFiliere
     *   }
     * })
     * 
     */
    delete<T extends ResponsableFiliereDeleteArgs>(args: SelectSubset<T, ResponsableFiliereDeleteArgs<ExtArgs>>): Prisma__ResponsableFiliereClient<$Result.GetResult<Prisma.$ResponsableFilierePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ResponsableFiliere.
     * @param {ResponsableFiliereUpdateArgs} args - Arguments to update one ResponsableFiliere.
     * @example
     * // Update one ResponsableFiliere
     * const responsableFiliere = await prisma.responsableFiliere.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResponsableFiliereUpdateArgs>(args: SelectSubset<T, ResponsableFiliereUpdateArgs<ExtArgs>>): Prisma__ResponsableFiliereClient<$Result.GetResult<Prisma.$ResponsableFilierePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ResponsableFilieres.
     * @param {ResponsableFiliereDeleteManyArgs} args - Arguments to filter ResponsableFilieres to delete.
     * @example
     * // Delete a few ResponsableFilieres
     * const { count } = await prisma.responsableFiliere.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResponsableFiliereDeleteManyArgs>(args?: SelectSubset<T, ResponsableFiliereDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponsableFilieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsableFiliereUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResponsableFilieres
     * const responsableFiliere = await prisma.responsableFiliere.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResponsableFiliereUpdateManyArgs>(args: SelectSubset<T, ResponsableFiliereUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResponsableFiliere.
     * @param {ResponsableFiliereUpsertArgs} args - Arguments to update or create a ResponsableFiliere.
     * @example
     * // Update or create a ResponsableFiliere
     * const responsableFiliere = await prisma.responsableFiliere.upsert({
     *   create: {
     *     // ... data to create a ResponsableFiliere
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResponsableFiliere we want to update
     *   }
     * })
     */
    upsert<T extends ResponsableFiliereUpsertArgs>(args: SelectSubset<T, ResponsableFiliereUpsertArgs<ExtArgs>>): Prisma__ResponsableFiliereClient<$Result.GetResult<Prisma.$ResponsableFilierePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ResponsableFilieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsableFiliereCountArgs} args - Arguments to filter ResponsableFilieres to count.
     * @example
     * // Count the number of ResponsableFilieres
     * const count = await prisma.responsableFiliere.count({
     *   where: {
     *     // ... the filter for the ResponsableFilieres we want to count
     *   }
     * })
    **/
    count<T extends ResponsableFiliereCountArgs>(
      args?: Subset<T, ResponsableFiliereCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponsableFiliereCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResponsableFiliere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsableFiliereAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponsableFiliereAggregateArgs>(args: Subset<T, ResponsableFiliereAggregateArgs>): Prisma.PrismaPromise<GetResponsableFiliereAggregateType<T>>

    /**
     * Group by ResponsableFiliere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsableFiliereGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponsableFiliereGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponsableFiliereGroupByArgs['orderBy'] }
        : { orderBy?: ResponsableFiliereGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponsableFiliereGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponsableFiliereGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResponsableFiliere model
   */
  readonly fields: ResponsableFiliereFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResponsableFiliere.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResponsableFiliereClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encadrants<T extends ResponsableFiliere$encadrantsArgs<ExtArgs> = {}>(args?: Subset<T, ResponsableFiliere$encadrantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResponsableFiliere model
   */ 
  interface ResponsableFiliereFieldRefs {
    readonly idResponsableFiliere: FieldRef<"ResponsableFiliere", 'Int'>
    readonly nom: FieldRef<"ResponsableFiliere", 'String'>
    readonly prenom: FieldRef<"ResponsableFiliere", 'String'>
    readonly email: FieldRef<"ResponsableFiliere", 'String'>
    readonly motDePasse: FieldRef<"ResponsableFiliere", 'String'>
    readonly departement: FieldRef<"ResponsableFiliere", 'String'>
    readonly annee: FieldRef<"ResponsableFiliere", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ResponsableFiliere findUnique
   */
  export type ResponsableFiliereFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
    /**
     * Filter, which ResponsableFiliere to fetch.
     */
    where: ResponsableFiliereWhereUniqueInput
  }

  /**
   * ResponsableFiliere findUniqueOrThrow
   */
  export type ResponsableFiliereFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
    /**
     * Filter, which ResponsableFiliere to fetch.
     */
    where: ResponsableFiliereWhereUniqueInput
  }

  /**
   * ResponsableFiliere findFirst
   */
  export type ResponsableFiliereFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
    /**
     * Filter, which ResponsableFiliere to fetch.
     */
    where?: ResponsableFiliereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsableFilieres to fetch.
     */
    orderBy?: ResponsableFiliereOrderByWithRelationInput | ResponsableFiliereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponsableFilieres.
     */
    cursor?: ResponsableFiliereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsableFilieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsableFilieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponsableFilieres.
     */
    distinct?: ResponsableFiliereScalarFieldEnum | ResponsableFiliereScalarFieldEnum[]
  }

  /**
   * ResponsableFiliere findFirstOrThrow
   */
  export type ResponsableFiliereFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
    /**
     * Filter, which ResponsableFiliere to fetch.
     */
    where?: ResponsableFiliereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsableFilieres to fetch.
     */
    orderBy?: ResponsableFiliereOrderByWithRelationInput | ResponsableFiliereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponsableFilieres.
     */
    cursor?: ResponsableFiliereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsableFilieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsableFilieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponsableFilieres.
     */
    distinct?: ResponsableFiliereScalarFieldEnum | ResponsableFiliereScalarFieldEnum[]
  }

  /**
   * ResponsableFiliere findMany
   */
  export type ResponsableFiliereFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
    /**
     * Filter, which ResponsableFilieres to fetch.
     */
    where?: ResponsableFiliereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsableFilieres to fetch.
     */
    orderBy?: ResponsableFiliereOrderByWithRelationInput | ResponsableFiliereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResponsableFilieres.
     */
    cursor?: ResponsableFiliereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsableFilieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsableFilieres.
     */
    skip?: number
    distinct?: ResponsableFiliereScalarFieldEnum | ResponsableFiliereScalarFieldEnum[]
  }

  /**
   * ResponsableFiliere create
   */
  export type ResponsableFiliereCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
    /**
     * The data needed to create a ResponsableFiliere.
     */
    data: XOR<ResponsableFiliereCreateInput, ResponsableFiliereUncheckedCreateInput>
  }

  /**
   * ResponsableFiliere createMany
   */
  export type ResponsableFiliereCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResponsableFilieres.
     */
    data: ResponsableFiliereCreateManyInput | ResponsableFiliereCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResponsableFiliere update
   */
  export type ResponsableFiliereUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
    /**
     * The data needed to update a ResponsableFiliere.
     */
    data: XOR<ResponsableFiliereUpdateInput, ResponsableFiliereUncheckedUpdateInput>
    /**
     * Choose, which ResponsableFiliere to update.
     */
    where: ResponsableFiliereWhereUniqueInput
  }

  /**
   * ResponsableFiliere updateMany
   */
  export type ResponsableFiliereUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResponsableFilieres.
     */
    data: XOR<ResponsableFiliereUpdateManyMutationInput, ResponsableFiliereUncheckedUpdateManyInput>
    /**
     * Filter which ResponsableFilieres to update
     */
    where?: ResponsableFiliereWhereInput
    /**
     * Limit how many ResponsableFilieres to update.
     */
    limit?: number
  }

  /**
   * ResponsableFiliere upsert
   */
  export type ResponsableFiliereUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
    /**
     * The filter to search for the ResponsableFiliere to update in case it exists.
     */
    where: ResponsableFiliereWhereUniqueInput
    /**
     * In case the ResponsableFiliere found by the `where` argument doesn't exist, create a new ResponsableFiliere with this data.
     */
    create: XOR<ResponsableFiliereCreateInput, ResponsableFiliereUncheckedCreateInput>
    /**
     * In case the ResponsableFiliere was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResponsableFiliereUpdateInput, ResponsableFiliereUncheckedUpdateInput>
  }

  /**
   * ResponsableFiliere delete
   */
  export type ResponsableFiliereDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
    /**
     * Filter which ResponsableFiliere to delete.
     */
    where: ResponsableFiliereWhereUniqueInput
  }

  /**
   * ResponsableFiliere deleteMany
   */
  export type ResponsableFiliereDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponsableFilieres to delete
     */
    where?: ResponsableFiliereWhereInput
    /**
     * Limit how many ResponsableFilieres to delete.
     */
    limit?: number
  }

  /**
   * ResponsableFiliere.encadrants
   */
  export type ResponsableFiliere$encadrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
    where?: EncadrantWhereInput
    orderBy?: EncadrantOrderByWithRelationInput | EncadrantOrderByWithRelationInput[]
    cursor?: EncadrantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncadrantScalarFieldEnum | EncadrantScalarFieldEnum[]
  }

  /**
   * ResponsableFiliere without action
   */
  export type ResponsableFiliereDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
  }


  /**
   * Model Encadrant
   */

  export type AggregateEncadrant = {
    _count: EncadrantCountAggregateOutputType | null
    _avg: EncadrantAvgAggregateOutputType | null
    _sum: EncadrantSumAggregateOutputType | null
    _min: EncadrantMinAggregateOutputType | null
    _max: EncadrantMaxAggregateOutputType | null
  }

  export type EncadrantAvgAggregateOutputType = {
    idEncadrant: number | null
    annee: number | null
    idResponsableFiliere: number | null
  }

  export type EncadrantSumAggregateOutputType = {
    idEncadrant: number | null
    annee: number | null
    idResponsableFiliere: number | null
  }

  export type EncadrantMinAggregateOutputType = {
    idEncadrant: number | null
    nom: string | null
    prenom: string | null
    email: string | null
    motDePasse: string | null
    annee: number | null
    idResponsableFiliere: number | null
  }

  export type EncadrantMaxAggregateOutputType = {
    idEncadrant: number | null
    nom: string | null
    prenom: string | null
    email: string | null
    motDePasse: string | null
    annee: number | null
    idResponsableFiliere: number | null
  }

  export type EncadrantCountAggregateOutputType = {
    idEncadrant: number
    nom: number
    prenom: number
    email: number
    motDePasse: number
    annee: number
    idResponsableFiliere: number
    _all: number
  }


  export type EncadrantAvgAggregateInputType = {
    idEncadrant?: true
    annee?: true
    idResponsableFiliere?: true
  }

  export type EncadrantSumAggregateInputType = {
    idEncadrant?: true
    annee?: true
    idResponsableFiliere?: true
  }

  export type EncadrantMinAggregateInputType = {
    idEncadrant?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    annee?: true
    idResponsableFiliere?: true
  }

  export type EncadrantMaxAggregateInputType = {
    idEncadrant?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    annee?: true
    idResponsableFiliere?: true
  }

  export type EncadrantCountAggregateInputType = {
    idEncadrant?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    annee?: true
    idResponsableFiliere?: true
    _all?: true
  }

  export type EncadrantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encadrant to aggregate.
     */
    where?: EncadrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encadrants to fetch.
     */
    orderBy?: EncadrantOrderByWithRelationInput | EncadrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncadrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encadrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encadrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encadrants
    **/
    _count?: true | EncadrantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncadrantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncadrantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncadrantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncadrantMaxAggregateInputType
  }

  export type GetEncadrantAggregateType<T extends EncadrantAggregateArgs> = {
        [P in keyof T & keyof AggregateEncadrant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncadrant[P]>
      : GetScalarType<T[P], AggregateEncadrant[P]>
  }




  export type EncadrantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncadrantWhereInput
    orderBy?: EncadrantOrderByWithAggregationInput | EncadrantOrderByWithAggregationInput[]
    by: EncadrantScalarFieldEnum[] | EncadrantScalarFieldEnum
    having?: EncadrantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncadrantCountAggregateInputType | true
    _avg?: EncadrantAvgAggregateInputType
    _sum?: EncadrantSumAggregateInputType
    _min?: EncadrantMinAggregateInputType
    _max?: EncadrantMaxAggregateInputType
  }

  export type EncadrantGroupByOutputType = {
    idEncadrant: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    idResponsableFiliere: number | null
    _count: EncadrantCountAggregateOutputType | null
    _avg: EncadrantAvgAggregateOutputType | null
    _sum: EncadrantSumAggregateOutputType | null
    _min: EncadrantMinAggregateOutputType | null
    _max: EncadrantMaxAggregateOutputType | null
  }

  type GetEncadrantGroupByPayload<T extends EncadrantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncadrantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncadrantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncadrantGroupByOutputType[P]>
            : GetScalarType<T[P], EncadrantGroupByOutputType[P]>
        }
      >
    >


  export type EncadrantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEncadrant?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    motDePasse?: boolean
    annee?: boolean
    idResponsableFiliere?: boolean
    responsableFiliere?: boolean | Encadrant$responsableFiliereArgs<ExtArgs>
    sujets?: boolean | Encadrant$sujetsArgs<ExtArgs>
    soutenances?: boolean | Encadrant$soutenancesArgs<ExtArgs>
    livrables?: boolean | Encadrant$livrablesArgs<ExtArgs>
    _count?: boolean | EncadrantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encadrant"]>



  export type EncadrantSelectScalar = {
    idEncadrant?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    motDePasse?: boolean
    annee?: boolean
    idResponsableFiliere?: boolean
  }

  export type EncadrantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idEncadrant" | "nom" | "prenom" | "email" | "motDePasse" | "annee" | "idResponsableFiliere", ExtArgs["result"]["encadrant"]>
  export type EncadrantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsableFiliere?: boolean | Encadrant$responsableFiliereArgs<ExtArgs>
    sujets?: boolean | Encadrant$sujetsArgs<ExtArgs>
    soutenances?: boolean | Encadrant$soutenancesArgs<ExtArgs>
    livrables?: boolean | Encadrant$livrablesArgs<ExtArgs>
    _count?: boolean | EncadrantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EncadrantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encadrant"
    objects: {
      responsableFiliere: Prisma.$ResponsableFilierePayload<ExtArgs> | null
      sujets: Prisma.$SujetPayload<ExtArgs>[]
      soutenances: Prisma.$EncadrantSoutenancePayload<ExtArgs>[]
      livrables: Prisma.$EncadrantLivrablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idEncadrant: number
      nom: string
      prenom: string
      email: string
      motDePasse: string
      annee: number
      idResponsableFiliere: number | null
    }, ExtArgs["result"]["encadrant"]>
    composites: {}
  }

  type EncadrantGetPayload<S extends boolean | null | undefined | EncadrantDefaultArgs> = $Result.GetResult<Prisma.$EncadrantPayload, S>

  type EncadrantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncadrantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncadrantCountAggregateInputType | true
    }

  export interface EncadrantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encadrant'], meta: { name: 'Encadrant' } }
    /**
     * Find zero or one Encadrant that matches the filter.
     * @param {EncadrantFindUniqueArgs} args - Arguments to find a Encadrant
     * @example
     * // Get one Encadrant
     * const encadrant = await prisma.encadrant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncadrantFindUniqueArgs>(args: SelectSubset<T, EncadrantFindUniqueArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Encadrant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncadrantFindUniqueOrThrowArgs} args - Arguments to find a Encadrant
     * @example
     * // Get one Encadrant
     * const encadrant = await prisma.encadrant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncadrantFindUniqueOrThrowArgs>(args: SelectSubset<T, EncadrantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Encadrant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantFindFirstArgs} args - Arguments to find a Encadrant
     * @example
     * // Get one Encadrant
     * const encadrant = await prisma.encadrant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncadrantFindFirstArgs>(args?: SelectSubset<T, EncadrantFindFirstArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Encadrant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantFindFirstOrThrowArgs} args - Arguments to find a Encadrant
     * @example
     * // Get one Encadrant
     * const encadrant = await prisma.encadrant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncadrantFindFirstOrThrowArgs>(args?: SelectSubset<T, EncadrantFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Encadrants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encadrants
     * const encadrants = await prisma.encadrant.findMany()
     * 
     * // Get first 10 Encadrants
     * const encadrants = await prisma.encadrant.findMany({ take: 10 })
     * 
     * // Only select the `idEncadrant`
     * const encadrantWithIdEncadrantOnly = await prisma.encadrant.findMany({ select: { idEncadrant: true } })
     * 
     */
    findMany<T extends EncadrantFindManyArgs>(args?: SelectSubset<T, EncadrantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Encadrant.
     * @param {EncadrantCreateArgs} args - Arguments to create a Encadrant.
     * @example
     * // Create one Encadrant
     * const Encadrant = await prisma.encadrant.create({
     *   data: {
     *     // ... data to create a Encadrant
     *   }
     * })
     * 
     */
    create<T extends EncadrantCreateArgs>(args: SelectSubset<T, EncadrantCreateArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Encadrants.
     * @param {EncadrantCreateManyArgs} args - Arguments to create many Encadrants.
     * @example
     * // Create many Encadrants
     * const encadrant = await prisma.encadrant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncadrantCreateManyArgs>(args?: SelectSubset<T, EncadrantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Encadrant.
     * @param {EncadrantDeleteArgs} args - Arguments to delete one Encadrant.
     * @example
     * // Delete one Encadrant
     * const Encadrant = await prisma.encadrant.delete({
     *   where: {
     *     // ... filter to delete one Encadrant
     *   }
     * })
     * 
     */
    delete<T extends EncadrantDeleteArgs>(args: SelectSubset<T, EncadrantDeleteArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Encadrant.
     * @param {EncadrantUpdateArgs} args - Arguments to update one Encadrant.
     * @example
     * // Update one Encadrant
     * const encadrant = await prisma.encadrant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncadrantUpdateArgs>(args: SelectSubset<T, EncadrantUpdateArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Encadrants.
     * @param {EncadrantDeleteManyArgs} args - Arguments to filter Encadrants to delete.
     * @example
     * // Delete a few Encadrants
     * const { count } = await prisma.encadrant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncadrantDeleteManyArgs>(args?: SelectSubset<T, EncadrantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encadrants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encadrants
     * const encadrant = await prisma.encadrant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncadrantUpdateManyArgs>(args: SelectSubset<T, EncadrantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Encadrant.
     * @param {EncadrantUpsertArgs} args - Arguments to update or create a Encadrant.
     * @example
     * // Update or create a Encadrant
     * const encadrant = await prisma.encadrant.upsert({
     *   create: {
     *     // ... data to create a Encadrant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encadrant we want to update
     *   }
     * })
     */
    upsert<T extends EncadrantUpsertArgs>(args: SelectSubset<T, EncadrantUpsertArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Encadrants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantCountArgs} args - Arguments to filter Encadrants to count.
     * @example
     * // Count the number of Encadrants
     * const count = await prisma.encadrant.count({
     *   where: {
     *     // ... the filter for the Encadrants we want to count
     *   }
     * })
    **/
    count<T extends EncadrantCountArgs>(
      args?: Subset<T, EncadrantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncadrantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encadrant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncadrantAggregateArgs>(args: Subset<T, EncadrantAggregateArgs>): Prisma.PrismaPromise<GetEncadrantAggregateType<T>>

    /**
     * Group by Encadrant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncadrantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncadrantGroupByArgs['orderBy'] }
        : { orderBy?: EncadrantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncadrantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncadrantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encadrant model
   */
  readonly fields: EncadrantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encadrant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncadrantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsableFiliere<T extends Encadrant$responsableFiliereArgs<ExtArgs> = {}>(args?: Subset<T, Encadrant$responsableFiliereArgs<ExtArgs>>): Prisma__ResponsableFiliereClient<$Result.GetResult<Prisma.$ResponsableFilierePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    sujets<T extends Encadrant$sujetsArgs<ExtArgs> = {}>(args?: Subset<T, Encadrant$sujetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    soutenances<T extends Encadrant$soutenancesArgs<ExtArgs> = {}>(args?: Subset<T, Encadrant$soutenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    livrables<T extends Encadrant$livrablesArgs<ExtArgs> = {}>(args?: Subset<T, Encadrant$livrablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encadrant model
   */ 
  interface EncadrantFieldRefs {
    readonly idEncadrant: FieldRef<"Encadrant", 'Int'>
    readonly nom: FieldRef<"Encadrant", 'String'>
    readonly prenom: FieldRef<"Encadrant", 'String'>
    readonly email: FieldRef<"Encadrant", 'String'>
    readonly motDePasse: FieldRef<"Encadrant", 'String'>
    readonly annee: FieldRef<"Encadrant", 'Int'>
    readonly idResponsableFiliere: FieldRef<"Encadrant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Encadrant findUnique
   */
  export type EncadrantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
    /**
     * Filter, which Encadrant to fetch.
     */
    where: EncadrantWhereUniqueInput
  }

  /**
   * Encadrant findUniqueOrThrow
   */
  export type EncadrantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
    /**
     * Filter, which Encadrant to fetch.
     */
    where: EncadrantWhereUniqueInput
  }

  /**
   * Encadrant findFirst
   */
  export type EncadrantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
    /**
     * Filter, which Encadrant to fetch.
     */
    where?: EncadrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encadrants to fetch.
     */
    orderBy?: EncadrantOrderByWithRelationInput | EncadrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encadrants.
     */
    cursor?: EncadrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encadrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encadrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encadrants.
     */
    distinct?: EncadrantScalarFieldEnum | EncadrantScalarFieldEnum[]
  }

  /**
   * Encadrant findFirstOrThrow
   */
  export type EncadrantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
    /**
     * Filter, which Encadrant to fetch.
     */
    where?: EncadrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encadrants to fetch.
     */
    orderBy?: EncadrantOrderByWithRelationInput | EncadrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encadrants.
     */
    cursor?: EncadrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encadrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encadrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encadrants.
     */
    distinct?: EncadrantScalarFieldEnum | EncadrantScalarFieldEnum[]
  }

  /**
   * Encadrant findMany
   */
  export type EncadrantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
    /**
     * Filter, which Encadrants to fetch.
     */
    where?: EncadrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encadrants to fetch.
     */
    orderBy?: EncadrantOrderByWithRelationInput | EncadrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encadrants.
     */
    cursor?: EncadrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encadrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encadrants.
     */
    skip?: number
    distinct?: EncadrantScalarFieldEnum | EncadrantScalarFieldEnum[]
  }

  /**
   * Encadrant create
   */
  export type EncadrantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
    /**
     * The data needed to create a Encadrant.
     */
    data: XOR<EncadrantCreateInput, EncadrantUncheckedCreateInput>
  }

  /**
   * Encadrant createMany
   */
  export type EncadrantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encadrants.
     */
    data: EncadrantCreateManyInput | EncadrantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encadrant update
   */
  export type EncadrantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
    /**
     * The data needed to update a Encadrant.
     */
    data: XOR<EncadrantUpdateInput, EncadrantUncheckedUpdateInput>
    /**
     * Choose, which Encadrant to update.
     */
    where: EncadrantWhereUniqueInput
  }

  /**
   * Encadrant updateMany
   */
  export type EncadrantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encadrants.
     */
    data: XOR<EncadrantUpdateManyMutationInput, EncadrantUncheckedUpdateManyInput>
    /**
     * Filter which Encadrants to update
     */
    where?: EncadrantWhereInput
    /**
     * Limit how many Encadrants to update.
     */
    limit?: number
  }

  /**
   * Encadrant upsert
   */
  export type EncadrantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
    /**
     * The filter to search for the Encadrant to update in case it exists.
     */
    where: EncadrantWhereUniqueInput
    /**
     * In case the Encadrant found by the `where` argument doesn't exist, create a new Encadrant with this data.
     */
    create: XOR<EncadrantCreateInput, EncadrantUncheckedCreateInput>
    /**
     * In case the Encadrant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncadrantUpdateInput, EncadrantUncheckedUpdateInput>
  }

  /**
   * Encadrant delete
   */
  export type EncadrantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
    /**
     * Filter which Encadrant to delete.
     */
    where: EncadrantWhereUniqueInput
  }

  /**
   * Encadrant deleteMany
   */
  export type EncadrantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encadrants to delete
     */
    where?: EncadrantWhereInput
    /**
     * Limit how many Encadrants to delete.
     */
    limit?: number
  }

  /**
   * Encadrant.responsableFiliere
   */
  export type Encadrant$responsableFiliereArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsableFiliere
     */
    select?: ResponsableFiliereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsableFiliere
     */
    omit?: ResponsableFiliereOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsableFiliereInclude<ExtArgs> | null
    where?: ResponsableFiliereWhereInput
  }

  /**
   * Encadrant.sujets
   */
  export type Encadrant$sujetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
    where?: SujetWhereInput
    orderBy?: SujetOrderByWithRelationInput | SujetOrderByWithRelationInput[]
    cursor?: SujetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SujetScalarFieldEnum | SujetScalarFieldEnum[]
  }

  /**
   * Encadrant.soutenances
   */
  export type Encadrant$soutenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    where?: EncadrantSoutenanceWhereInput
    orderBy?: EncadrantSoutenanceOrderByWithRelationInput | EncadrantSoutenanceOrderByWithRelationInput[]
    cursor?: EncadrantSoutenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncadrantSoutenanceScalarFieldEnum | EncadrantSoutenanceScalarFieldEnum[]
  }

  /**
   * Encadrant.livrables
   */
  export type Encadrant$livrablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    where?: EncadrantLivrableWhereInput
    orderBy?: EncadrantLivrableOrderByWithRelationInput | EncadrantLivrableOrderByWithRelationInput[]
    cursor?: EncadrantLivrableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncadrantLivrableScalarFieldEnum | EncadrantLivrableScalarFieldEnum[]
  }

  /**
   * Encadrant without action
   */
  export type EncadrantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encadrant
     */
    select?: EncadrantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encadrant
     */
    omit?: EncadrantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantInclude<ExtArgs> | null
  }


  /**
   * Model Tuteur
   */

  export type AggregateTuteur = {
    _count: TuteurCountAggregateOutputType | null
    _avg: TuteurAvgAggregateOutputType | null
    _sum: TuteurSumAggregateOutputType | null
    _min: TuteurMinAggregateOutputType | null
    _max: TuteurMaxAggregateOutputType | null
  }

  export type TuteurAvgAggregateOutputType = {
    idTuteur: number | null
    annee: number | null
  }

  export type TuteurSumAggregateOutputType = {
    idTuteur: number | null
    annee: number | null
  }

  export type TuteurMinAggregateOutputType = {
    idTuteur: number | null
    nom: string | null
    prenom: string | null
    email: string | null
    motDePasse: string | null
    classe: string | null
    filiere: string | null
    annee: number | null
  }

  export type TuteurMaxAggregateOutputType = {
    idTuteur: number | null
    nom: string | null
    prenom: string | null
    email: string | null
    motDePasse: string | null
    classe: string | null
    filiere: string | null
    annee: number | null
  }

  export type TuteurCountAggregateOutputType = {
    idTuteur: number
    nom: number
    prenom: number
    email: number
    motDePasse: number
    classe: number
    filiere: number
    annee: number
    _all: number
  }


  export type TuteurAvgAggregateInputType = {
    idTuteur?: true
    annee?: true
  }

  export type TuteurSumAggregateInputType = {
    idTuteur?: true
    annee?: true
  }

  export type TuteurMinAggregateInputType = {
    idTuteur?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    classe?: true
    filiere?: true
    annee?: true
  }

  export type TuteurMaxAggregateInputType = {
    idTuteur?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    classe?: true
    filiere?: true
    annee?: true
  }

  export type TuteurCountAggregateInputType = {
    idTuteur?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    classe?: true
    filiere?: true
    annee?: true
    _all?: true
  }

  export type TuteurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tuteur to aggregate.
     */
    where?: TuteurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tuteurs to fetch.
     */
    orderBy?: TuteurOrderByWithRelationInput | TuteurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TuteurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tuteurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tuteurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tuteurs
    **/
    _count?: true | TuteurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TuteurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TuteurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TuteurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TuteurMaxAggregateInputType
  }

  export type GetTuteurAggregateType<T extends TuteurAggregateArgs> = {
        [P in keyof T & keyof AggregateTuteur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTuteur[P]>
      : GetScalarType<T[P], AggregateTuteur[P]>
  }




  export type TuteurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TuteurWhereInput
    orderBy?: TuteurOrderByWithAggregationInput | TuteurOrderByWithAggregationInput[]
    by: TuteurScalarFieldEnum[] | TuteurScalarFieldEnum
    having?: TuteurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TuteurCountAggregateInputType | true
    _avg?: TuteurAvgAggregateInputType
    _sum?: TuteurSumAggregateInputType
    _min?: TuteurMinAggregateInputType
    _max?: TuteurMaxAggregateInputType
  }

  export type TuteurGroupByOutputType = {
    idTuteur: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    classe: string
    filiere: string
    annee: number
    _count: TuteurCountAggregateOutputType | null
    _avg: TuteurAvgAggregateOutputType | null
    _sum: TuteurSumAggregateOutputType | null
    _min: TuteurMinAggregateOutputType | null
    _max: TuteurMaxAggregateOutputType | null
  }

  type GetTuteurGroupByPayload<T extends TuteurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TuteurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TuteurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TuteurGroupByOutputType[P]>
            : GetScalarType<T[P], TuteurGroupByOutputType[P]>
        }
      >
    >


  export type TuteurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idTuteur?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    motDePasse?: boolean
    classe?: boolean
    filiere?: boolean
    annee?: boolean
    PFEs?: boolean | Tuteur$PFEsArgs<ExtArgs>
    livrables?: boolean | Tuteur$livrablesArgs<ExtArgs>
    _count?: boolean | TuteurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tuteur"]>



  export type TuteurSelectScalar = {
    idTuteur?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    motDePasse?: boolean
    classe?: boolean
    filiere?: boolean
    annee?: boolean
  }

  export type TuteurOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idTuteur" | "nom" | "prenom" | "email" | "motDePasse" | "classe" | "filiere" | "annee", ExtArgs["result"]["tuteur"]>
  export type TuteurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PFEs?: boolean | Tuteur$PFEsArgs<ExtArgs>
    livrables?: boolean | Tuteur$livrablesArgs<ExtArgs>
    _count?: boolean | TuteurCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TuteurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tuteur"
    objects: {
      PFEs: Prisma.$PFEPayload<ExtArgs>[]
      livrables: Prisma.$TuteurLivrablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idTuteur: number
      nom: string
      prenom: string
      email: string
      motDePasse: string
      classe: string
      filiere: string
      annee: number
    }, ExtArgs["result"]["tuteur"]>
    composites: {}
  }

  type TuteurGetPayload<S extends boolean | null | undefined | TuteurDefaultArgs> = $Result.GetResult<Prisma.$TuteurPayload, S>

  type TuteurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TuteurFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TuteurCountAggregateInputType | true
    }

  export interface TuteurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tuteur'], meta: { name: 'Tuteur' } }
    /**
     * Find zero or one Tuteur that matches the filter.
     * @param {TuteurFindUniqueArgs} args - Arguments to find a Tuteur
     * @example
     * // Get one Tuteur
     * const tuteur = await prisma.tuteur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TuteurFindUniqueArgs>(args: SelectSubset<T, TuteurFindUniqueArgs<ExtArgs>>): Prisma__TuteurClient<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tuteur that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TuteurFindUniqueOrThrowArgs} args - Arguments to find a Tuteur
     * @example
     * // Get one Tuteur
     * const tuteur = await prisma.tuteur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TuteurFindUniqueOrThrowArgs>(args: SelectSubset<T, TuteurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TuteurClient<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tuteur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurFindFirstArgs} args - Arguments to find a Tuteur
     * @example
     * // Get one Tuteur
     * const tuteur = await prisma.tuteur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TuteurFindFirstArgs>(args?: SelectSubset<T, TuteurFindFirstArgs<ExtArgs>>): Prisma__TuteurClient<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tuteur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurFindFirstOrThrowArgs} args - Arguments to find a Tuteur
     * @example
     * // Get one Tuteur
     * const tuteur = await prisma.tuteur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TuteurFindFirstOrThrowArgs>(args?: SelectSubset<T, TuteurFindFirstOrThrowArgs<ExtArgs>>): Prisma__TuteurClient<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tuteurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tuteurs
     * const tuteurs = await prisma.tuteur.findMany()
     * 
     * // Get first 10 Tuteurs
     * const tuteurs = await prisma.tuteur.findMany({ take: 10 })
     * 
     * // Only select the `idTuteur`
     * const tuteurWithIdTuteurOnly = await prisma.tuteur.findMany({ select: { idTuteur: true } })
     * 
     */
    findMany<T extends TuteurFindManyArgs>(args?: SelectSubset<T, TuteurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tuteur.
     * @param {TuteurCreateArgs} args - Arguments to create a Tuteur.
     * @example
     * // Create one Tuteur
     * const Tuteur = await prisma.tuteur.create({
     *   data: {
     *     // ... data to create a Tuteur
     *   }
     * })
     * 
     */
    create<T extends TuteurCreateArgs>(args: SelectSubset<T, TuteurCreateArgs<ExtArgs>>): Prisma__TuteurClient<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tuteurs.
     * @param {TuteurCreateManyArgs} args - Arguments to create many Tuteurs.
     * @example
     * // Create many Tuteurs
     * const tuteur = await prisma.tuteur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TuteurCreateManyArgs>(args?: SelectSubset<T, TuteurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tuteur.
     * @param {TuteurDeleteArgs} args - Arguments to delete one Tuteur.
     * @example
     * // Delete one Tuteur
     * const Tuteur = await prisma.tuteur.delete({
     *   where: {
     *     // ... filter to delete one Tuteur
     *   }
     * })
     * 
     */
    delete<T extends TuteurDeleteArgs>(args: SelectSubset<T, TuteurDeleteArgs<ExtArgs>>): Prisma__TuteurClient<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tuteur.
     * @param {TuteurUpdateArgs} args - Arguments to update one Tuteur.
     * @example
     * // Update one Tuteur
     * const tuteur = await prisma.tuteur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TuteurUpdateArgs>(args: SelectSubset<T, TuteurUpdateArgs<ExtArgs>>): Prisma__TuteurClient<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tuteurs.
     * @param {TuteurDeleteManyArgs} args - Arguments to filter Tuteurs to delete.
     * @example
     * // Delete a few Tuteurs
     * const { count } = await prisma.tuteur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TuteurDeleteManyArgs>(args?: SelectSubset<T, TuteurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tuteurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tuteurs
     * const tuteur = await prisma.tuteur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TuteurUpdateManyArgs>(args: SelectSubset<T, TuteurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tuteur.
     * @param {TuteurUpsertArgs} args - Arguments to update or create a Tuteur.
     * @example
     * // Update or create a Tuteur
     * const tuteur = await prisma.tuteur.upsert({
     *   create: {
     *     // ... data to create a Tuteur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tuteur we want to update
     *   }
     * })
     */
    upsert<T extends TuteurUpsertArgs>(args: SelectSubset<T, TuteurUpsertArgs<ExtArgs>>): Prisma__TuteurClient<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tuteurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurCountArgs} args - Arguments to filter Tuteurs to count.
     * @example
     * // Count the number of Tuteurs
     * const count = await prisma.tuteur.count({
     *   where: {
     *     // ... the filter for the Tuteurs we want to count
     *   }
     * })
    **/
    count<T extends TuteurCountArgs>(
      args?: Subset<T, TuteurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TuteurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tuteur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TuteurAggregateArgs>(args: Subset<T, TuteurAggregateArgs>): Prisma.PrismaPromise<GetTuteurAggregateType<T>>

    /**
     * Group by Tuteur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TuteurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TuteurGroupByArgs['orderBy'] }
        : { orderBy?: TuteurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TuteurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTuteurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tuteur model
   */
  readonly fields: TuteurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tuteur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TuteurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PFEs<T extends Tuteur$PFEsArgs<ExtArgs> = {}>(args?: Subset<T, Tuteur$PFEsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    livrables<T extends Tuteur$livrablesArgs<ExtArgs> = {}>(args?: Subset<T, Tuteur$livrablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tuteur model
   */ 
  interface TuteurFieldRefs {
    readonly idTuteur: FieldRef<"Tuteur", 'Int'>
    readonly nom: FieldRef<"Tuteur", 'String'>
    readonly prenom: FieldRef<"Tuteur", 'String'>
    readonly email: FieldRef<"Tuteur", 'String'>
    readonly motDePasse: FieldRef<"Tuteur", 'String'>
    readonly classe: FieldRef<"Tuteur", 'String'>
    readonly filiere: FieldRef<"Tuteur", 'String'>
    readonly annee: FieldRef<"Tuteur", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tuteur findUnique
   */
  export type TuteurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tuteur
     */
    select?: TuteurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tuteur
     */
    omit?: TuteurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurInclude<ExtArgs> | null
    /**
     * Filter, which Tuteur to fetch.
     */
    where: TuteurWhereUniqueInput
  }

  /**
   * Tuteur findUniqueOrThrow
   */
  export type TuteurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tuteur
     */
    select?: TuteurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tuteur
     */
    omit?: TuteurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurInclude<ExtArgs> | null
    /**
     * Filter, which Tuteur to fetch.
     */
    where: TuteurWhereUniqueInput
  }

  /**
   * Tuteur findFirst
   */
  export type TuteurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tuteur
     */
    select?: TuteurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tuteur
     */
    omit?: TuteurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurInclude<ExtArgs> | null
    /**
     * Filter, which Tuteur to fetch.
     */
    where?: TuteurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tuteurs to fetch.
     */
    orderBy?: TuteurOrderByWithRelationInput | TuteurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tuteurs.
     */
    cursor?: TuteurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tuteurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tuteurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tuteurs.
     */
    distinct?: TuteurScalarFieldEnum | TuteurScalarFieldEnum[]
  }

  /**
   * Tuteur findFirstOrThrow
   */
  export type TuteurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tuteur
     */
    select?: TuteurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tuteur
     */
    omit?: TuteurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurInclude<ExtArgs> | null
    /**
     * Filter, which Tuteur to fetch.
     */
    where?: TuteurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tuteurs to fetch.
     */
    orderBy?: TuteurOrderByWithRelationInput | TuteurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tuteurs.
     */
    cursor?: TuteurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tuteurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tuteurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tuteurs.
     */
    distinct?: TuteurScalarFieldEnum | TuteurScalarFieldEnum[]
  }

  /**
   * Tuteur findMany
   */
  export type TuteurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tuteur
     */
    select?: TuteurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tuteur
     */
    omit?: TuteurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurInclude<ExtArgs> | null
    /**
     * Filter, which Tuteurs to fetch.
     */
    where?: TuteurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tuteurs to fetch.
     */
    orderBy?: TuteurOrderByWithRelationInput | TuteurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tuteurs.
     */
    cursor?: TuteurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tuteurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tuteurs.
     */
    skip?: number
    distinct?: TuteurScalarFieldEnum | TuteurScalarFieldEnum[]
  }

  /**
   * Tuteur create
   */
  export type TuteurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tuteur
     */
    select?: TuteurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tuteur
     */
    omit?: TuteurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurInclude<ExtArgs> | null
    /**
     * The data needed to create a Tuteur.
     */
    data: XOR<TuteurCreateInput, TuteurUncheckedCreateInput>
  }

  /**
   * Tuteur createMany
   */
  export type TuteurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tuteurs.
     */
    data: TuteurCreateManyInput | TuteurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tuteur update
   */
  export type TuteurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tuteur
     */
    select?: TuteurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tuteur
     */
    omit?: TuteurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurInclude<ExtArgs> | null
    /**
     * The data needed to update a Tuteur.
     */
    data: XOR<TuteurUpdateInput, TuteurUncheckedUpdateInput>
    /**
     * Choose, which Tuteur to update.
     */
    where: TuteurWhereUniqueInput
  }

  /**
   * Tuteur updateMany
   */
  export type TuteurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tuteurs.
     */
    data: XOR<TuteurUpdateManyMutationInput, TuteurUncheckedUpdateManyInput>
    /**
     * Filter which Tuteurs to update
     */
    where?: TuteurWhereInput
    /**
     * Limit how many Tuteurs to update.
     */
    limit?: number
  }

  /**
   * Tuteur upsert
   */
  export type TuteurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tuteur
     */
    select?: TuteurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tuteur
     */
    omit?: TuteurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurInclude<ExtArgs> | null
    /**
     * The filter to search for the Tuteur to update in case it exists.
     */
    where: TuteurWhereUniqueInput
    /**
     * In case the Tuteur found by the `where` argument doesn't exist, create a new Tuteur with this data.
     */
    create: XOR<TuteurCreateInput, TuteurUncheckedCreateInput>
    /**
     * In case the Tuteur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TuteurUpdateInput, TuteurUncheckedUpdateInput>
  }

  /**
   * Tuteur delete
   */
  export type TuteurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tuteur
     */
    select?: TuteurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tuteur
     */
    omit?: TuteurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurInclude<ExtArgs> | null
    /**
     * Filter which Tuteur to delete.
     */
    where: TuteurWhereUniqueInput
  }

  /**
   * Tuteur deleteMany
   */
  export type TuteurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tuteurs to delete
     */
    where?: TuteurWhereInput
    /**
     * Limit how many Tuteurs to delete.
     */
    limit?: number
  }

  /**
   * Tuteur.PFEs
   */
  export type Tuteur$PFEsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
    where?: PFEWhereInput
    orderBy?: PFEOrderByWithRelationInput | PFEOrderByWithRelationInput[]
    cursor?: PFEWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PFEScalarFieldEnum | PFEScalarFieldEnum[]
  }

  /**
   * Tuteur.livrables
   */
  export type Tuteur$livrablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    where?: TuteurLivrableWhereInput
    orderBy?: TuteurLivrableOrderByWithRelationInput | TuteurLivrableOrderByWithRelationInput[]
    cursor?: TuteurLivrableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TuteurLivrableScalarFieldEnum | TuteurLivrableScalarFieldEnum[]
  }

  /**
   * Tuteur without action
   */
  export type TuteurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tuteur
     */
    select?: TuteurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tuteur
     */
    omit?: TuteurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurInclude<ExtArgs> | null
  }


  /**
   * Model Etudiant
   */

  export type AggregateEtudiant = {
    _count: EtudiantCountAggregateOutputType | null
    _avg: EtudiantAvgAggregateOutputType | null
    _sum: EtudiantSumAggregateOutputType | null
    _min: EtudiantMinAggregateOutputType | null
    _max: EtudiantMaxAggregateOutputType | null
  }

  export type EtudiantAvgAggregateOutputType = {
    idEtudiant: number | null
    annee: number | null
  }

  export type EtudiantSumAggregateOutputType = {
    idEtudiant: number | null
    annee: number | null
  }

  export type EtudiantMinAggregateOutputType = {
    idEtudiant: number | null
    nom: string | null
    prenom: string | null
    email: string | null
    motDePasse: string | null
    annee: number | null
    classe: string | null
    filiere: string | null
  }

  export type EtudiantMaxAggregateOutputType = {
    idEtudiant: number | null
    nom: string | null
    prenom: string | null
    email: string | null
    motDePasse: string | null
    annee: number | null
    classe: string | null
    filiere: string | null
  }

  export type EtudiantCountAggregateOutputType = {
    idEtudiant: number
    nom: number
    prenom: number
    email: number
    motDePasse: number
    annee: number
    classe: number
    filiere: number
    _all: number
  }


  export type EtudiantAvgAggregateInputType = {
    idEtudiant?: true
    annee?: true
  }

  export type EtudiantSumAggregateInputType = {
    idEtudiant?: true
    annee?: true
  }

  export type EtudiantMinAggregateInputType = {
    idEtudiant?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    annee?: true
    classe?: true
    filiere?: true
  }

  export type EtudiantMaxAggregateInputType = {
    idEtudiant?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    annee?: true
    classe?: true
    filiere?: true
  }

  export type EtudiantCountAggregateInputType = {
    idEtudiant?: true
    nom?: true
    prenom?: true
    email?: true
    motDePasse?: true
    annee?: true
    classe?: true
    filiere?: true
    _all?: true
  }

  export type EtudiantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etudiant to aggregate.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Etudiants
    **/
    _count?: true | EtudiantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtudiantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtudiantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtudiantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtudiantMaxAggregateInputType
  }

  export type GetEtudiantAggregateType<T extends EtudiantAggregateArgs> = {
        [P in keyof T & keyof AggregateEtudiant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtudiant[P]>
      : GetScalarType<T[P], AggregateEtudiant[P]>
  }




  export type EtudiantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtudiantWhereInput
    orderBy?: EtudiantOrderByWithAggregationInput | EtudiantOrderByWithAggregationInput[]
    by: EtudiantScalarFieldEnum[] | EtudiantScalarFieldEnum
    having?: EtudiantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtudiantCountAggregateInputType | true
    _avg?: EtudiantAvgAggregateInputType
    _sum?: EtudiantSumAggregateInputType
    _min?: EtudiantMinAggregateInputType
    _max?: EtudiantMaxAggregateInputType
  }

  export type EtudiantGroupByOutputType = {
    idEtudiant: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    classe: string
    filiere: string
    _count: EtudiantCountAggregateOutputType | null
    _avg: EtudiantAvgAggregateOutputType | null
    _sum: EtudiantSumAggregateOutputType | null
    _min: EtudiantMinAggregateOutputType | null
    _max: EtudiantMaxAggregateOutputType | null
  }

  type GetEtudiantGroupByPayload<T extends EtudiantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtudiantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtudiantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtudiantGroupByOutputType[P]>
            : GetScalarType<T[P], EtudiantGroupByOutputType[P]>
        }
      >
    >


  export type EtudiantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEtudiant?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    motDePasse?: boolean
    annee?: boolean
    classe?: boolean
    filiere?: boolean
    groupes?: boolean | Etudiant$groupesArgs<ExtArgs>
    sujets?: boolean | Etudiant$sujetsArgs<ExtArgs>
    evaluations?: boolean | Etudiant$evaluationsArgs<ExtArgs>
    _count?: boolean | EtudiantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etudiant"]>



  export type EtudiantSelectScalar = {
    idEtudiant?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    motDePasse?: boolean
    annee?: boolean
    classe?: boolean
    filiere?: boolean
  }

  export type EtudiantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idEtudiant" | "nom" | "prenom" | "email" | "motDePasse" | "annee" | "classe" | "filiere", ExtArgs["result"]["etudiant"]>
  export type EtudiantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupes?: boolean | Etudiant$groupesArgs<ExtArgs>
    sujets?: boolean | Etudiant$sujetsArgs<ExtArgs>
    evaluations?: boolean | Etudiant$evaluationsArgs<ExtArgs>
    _count?: boolean | EtudiantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EtudiantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Etudiant"
    objects: {
      groupes: Prisma.$EtudiantGroupePayload<ExtArgs>[]
      sujets: Prisma.$EtudiantSujetPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idEtudiant: number
      nom: string
      prenom: string
      email: string
      motDePasse: string
      annee: number
      classe: string
      filiere: string
    }, ExtArgs["result"]["etudiant"]>
    composites: {}
  }

  type EtudiantGetPayload<S extends boolean | null | undefined | EtudiantDefaultArgs> = $Result.GetResult<Prisma.$EtudiantPayload, S>

  type EtudiantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EtudiantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EtudiantCountAggregateInputType | true
    }

  export interface EtudiantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Etudiant'], meta: { name: 'Etudiant' } }
    /**
     * Find zero or one Etudiant that matches the filter.
     * @param {EtudiantFindUniqueArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EtudiantFindUniqueArgs>(args: SelectSubset<T, EtudiantFindUniqueArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Etudiant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EtudiantFindUniqueOrThrowArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EtudiantFindUniqueOrThrowArgs>(args: SelectSubset<T, EtudiantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Etudiant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantFindFirstArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EtudiantFindFirstArgs>(args?: SelectSubset<T, EtudiantFindFirstArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Etudiant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantFindFirstOrThrowArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EtudiantFindFirstOrThrowArgs>(args?: SelectSubset<T, EtudiantFindFirstOrThrowArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Etudiants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Etudiants
     * const etudiants = await prisma.etudiant.findMany()
     * 
     * // Get first 10 Etudiants
     * const etudiants = await prisma.etudiant.findMany({ take: 10 })
     * 
     * // Only select the `idEtudiant`
     * const etudiantWithIdEtudiantOnly = await prisma.etudiant.findMany({ select: { idEtudiant: true } })
     * 
     */
    findMany<T extends EtudiantFindManyArgs>(args?: SelectSubset<T, EtudiantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Etudiant.
     * @param {EtudiantCreateArgs} args - Arguments to create a Etudiant.
     * @example
     * // Create one Etudiant
     * const Etudiant = await prisma.etudiant.create({
     *   data: {
     *     // ... data to create a Etudiant
     *   }
     * })
     * 
     */
    create<T extends EtudiantCreateArgs>(args: SelectSubset<T, EtudiantCreateArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Etudiants.
     * @param {EtudiantCreateManyArgs} args - Arguments to create many Etudiants.
     * @example
     * // Create many Etudiants
     * const etudiant = await prisma.etudiant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EtudiantCreateManyArgs>(args?: SelectSubset<T, EtudiantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Etudiant.
     * @param {EtudiantDeleteArgs} args - Arguments to delete one Etudiant.
     * @example
     * // Delete one Etudiant
     * const Etudiant = await prisma.etudiant.delete({
     *   where: {
     *     // ... filter to delete one Etudiant
     *   }
     * })
     * 
     */
    delete<T extends EtudiantDeleteArgs>(args: SelectSubset<T, EtudiantDeleteArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Etudiant.
     * @param {EtudiantUpdateArgs} args - Arguments to update one Etudiant.
     * @example
     * // Update one Etudiant
     * const etudiant = await prisma.etudiant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EtudiantUpdateArgs>(args: SelectSubset<T, EtudiantUpdateArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Etudiants.
     * @param {EtudiantDeleteManyArgs} args - Arguments to filter Etudiants to delete.
     * @example
     * // Delete a few Etudiants
     * const { count } = await prisma.etudiant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EtudiantDeleteManyArgs>(args?: SelectSubset<T, EtudiantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Etudiants
     * const etudiant = await prisma.etudiant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EtudiantUpdateManyArgs>(args: SelectSubset<T, EtudiantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Etudiant.
     * @param {EtudiantUpsertArgs} args - Arguments to update or create a Etudiant.
     * @example
     * // Update or create a Etudiant
     * const etudiant = await prisma.etudiant.upsert({
     *   create: {
     *     // ... data to create a Etudiant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Etudiant we want to update
     *   }
     * })
     */
    upsert<T extends EtudiantUpsertArgs>(args: SelectSubset<T, EtudiantUpsertArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Etudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantCountArgs} args - Arguments to filter Etudiants to count.
     * @example
     * // Count the number of Etudiants
     * const count = await prisma.etudiant.count({
     *   where: {
     *     // ... the filter for the Etudiants we want to count
     *   }
     * })
    **/
    count<T extends EtudiantCountArgs>(
      args?: Subset<T, EtudiantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtudiantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Etudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtudiantAggregateArgs>(args: Subset<T, EtudiantAggregateArgs>): Prisma.PrismaPromise<GetEtudiantAggregateType<T>>

    /**
     * Group by Etudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtudiantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtudiantGroupByArgs['orderBy'] }
        : { orderBy?: EtudiantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtudiantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtudiantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Etudiant model
   */
  readonly fields: EtudiantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Etudiant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtudiantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groupes<T extends Etudiant$groupesArgs<ExtArgs> = {}>(args?: Subset<T, Etudiant$groupesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    sujets<T extends Etudiant$sujetsArgs<ExtArgs> = {}>(args?: Subset<T, Etudiant$sujetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    evaluations<T extends Etudiant$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Etudiant$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Etudiant model
   */ 
  interface EtudiantFieldRefs {
    readonly idEtudiant: FieldRef<"Etudiant", 'Int'>
    readonly nom: FieldRef<"Etudiant", 'String'>
    readonly prenom: FieldRef<"Etudiant", 'String'>
    readonly email: FieldRef<"Etudiant", 'String'>
    readonly motDePasse: FieldRef<"Etudiant", 'String'>
    readonly annee: FieldRef<"Etudiant", 'Int'>
    readonly classe: FieldRef<"Etudiant", 'String'>
    readonly filiere: FieldRef<"Etudiant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Etudiant findUnique
   */
  export type EtudiantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etudiant
     */
    omit?: EtudiantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where: EtudiantWhereUniqueInput
  }

  /**
   * Etudiant findUniqueOrThrow
   */
  export type EtudiantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etudiant
     */
    omit?: EtudiantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where: EtudiantWhereUniqueInput
  }

  /**
   * Etudiant findFirst
   */
  export type EtudiantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etudiant
     */
    omit?: EtudiantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etudiants.
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etudiants.
     */
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }

  /**
   * Etudiant findFirstOrThrow
   */
  export type EtudiantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etudiant
     */
    omit?: EtudiantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiant to fetch.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Etudiants.
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Etudiants.
     */
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }

  /**
   * Etudiant findMany
   */
  export type EtudiantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etudiant
     */
    omit?: EtudiantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter, which Etudiants to fetch.
     */
    where?: EtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Etudiants to fetch.
     */
    orderBy?: EtudiantOrderByWithRelationInput | EtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Etudiants.
     */
    cursor?: EtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Etudiants.
     */
    skip?: number
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }

  /**
   * Etudiant create
   */
  export type EtudiantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etudiant
     */
    omit?: EtudiantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * The data needed to create a Etudiant.
     */
    data: XOR<EtudiantCreateInput, EtudiantUncheckedCreateInput>
  }

  /**
   * Etudiant createMany
   */
  export type EtudiantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Etudiants.
     */
    data: EtudiantCreateManyInput | EtudiantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Etudiant update
   */
  export type EtudiantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etudiant
     */
    omit?: EtudiantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * The data needed to update a Etudiant.
     */
    data: XOR<EtudiantUpdateInput, EtudiantUncheckedUpdateInput>
    /**
     * Choose, which Etudiant to update.
     */
    where: EtudiantWhereUniqueInput
  }

  /**
   * Etudiant updateMany
   */
  export type EtudiantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Etudiants.
     */
    data: XOR<EtudiantUpdateManyMutationInput, EtudiantUncheckedUpdateManyInput>
    /**
     * Filter which Etudiants to update
     */
    where?: EtudiantWhereInput
    /**
     * Limit how many Etudiants to update.
     */
    limit?: number
  }

  /**
   * Etudiant upsert
   */
  export type EtudiantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etudiant
     */
    omit?: EtudiantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * The filter to search for the Etudiant to update in case it exists.
     */
    where: EtudiantWhereUniqueInput
    /**
     * In case the Etudiant found by the `where` argument doesn't exist, create a new Etudiant with this data.
     */
    create: XOR<EtudiantCreateInput, EtudiantUncheckedCreateInput>
    /**
     * In case the Etudiant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtudiantUpdateInput, EtudiantUncheckedUpdateInput>
  }

  /**
   * Etudiant delete
   */
  export type EtudiantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etudiant
     */
    omit?: EtudiantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantInclude<ExtArgs> | null
    /**
     * Filter which Etudiant to delete.
     */
    where: EtudiantWhereUniqueInput
  }

  /**
   * Etudiant deleteMany
   */
  export type EtudiantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Etudiants to delete
     */
    where?: EtudiantWhereInput
    /**
     * Limit how many Etudiants to delete.
     */
    limit?: number
  }

  /**
   * Etudiant.groupes
   */
  export type Etudiant$groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    where?: EtudiantGroupeWhereInput
    orderBy?: EtudiantGroupeOrderByWithRelationInput | EtudiantGroupeOrderByWithRelationInput[]
    cursor?: EtudiantGroupeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtudiantGroupeScalarFieldEnum | EtudiantGroupeScalarFieldEnum[]
  }

  /**
   * Etudiant.sujets
   */
  export type Etudiant$sujetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    where?: EtudiantSujetWhereInput
    orderBy?: EtudiantSujetOrderByWithRelationInput | EtudiantSujetOrderByWithRelationInput[]
    cursor?: EtudiantSujetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtudiantSujetScalarFieldEnum | EtudiantSujetScalarFieldEnum[]
  }

  /**
   * Etudiant.evaluations
   */
  export type Etudiant$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Etudiant without action
   */
  export type EtudiantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Etudiant
     */
    select?: EtudiantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Etudiant
     */
    omit?: EtudiantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantInclude<ExtArgs> | null
  }


  /**
   * Model Groupe
   */

  export type AggregateGroupe = {
    _count: GroupeCountAggregateOutputType | null
    _avg: GroupeAvgAggregateOutputType | null
    _sum: GroupeSumAggregateOutputType | null
    _min: GroupeMinAggregateOutputType | null
    _max: GroupeMaxAggregateOutputType | null
  }

  export type GroupeAvgAggregateOutputType = {
    idGroupe: number | null
    nbEtudiants: number | null
  }

  export type GroupeSumAggregateOutputType = {
    idGroupe: number | null
    nbEtudiants: number | null
  }

  export type GroupeMinAggregateOutputType = {
    idGroupe: number | null
    nomGroupe: string | null
    nbEtudiants: number | null
  }

  export type GroupeMaxAggregateOutputType = {
    idGroupe: number | null
    nomGroupe: string | null
    nbEtudiants: number | null
  }

  export type GroupeCountAggregateOutputType = {
    idGroupe: number
    nomGroupe: number
    nbEtudiants: number
    _all: number
  }


  export type GroupeAvgAggregateInputType = {
    idGroupe?: true
    nbEtudiants?: true
  }

  export type GroupeSumAggregateInputType = {
    idGroupe?: true
    nbEtudiants?: true
  }

  export type GroupeMinAggregateInputType = {
    idGroupe?: true
    nomGroupe?: true
    nbEtudiants?: true
  }

  export type GroupeMaxAggregateInputType = {
    idGroupe?: true
    nomGroupe?: true
    nbEtudiants?: true
  }

  export type GroupeCountAggregateInputType = {
    idGroupe?: true
    nomGroupe?: true
    nbEtudiants?: true
    _all?: true
  }

  export type GroupeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groupe to aggregate.
     */
    where?: GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groupes to fetch.
     */
    orderBy?: GroupeOrderByWithRelationInput | GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groupes
    **/
    _count?: true | GroupeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupeMaxAggregateInputType
  }

  export type GetGroupeAggregateType<T extends GroupeAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupe[P]>
      : GetScalarType<T[P], AggregateGroupe[P]>
  }




  export type GroupeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupeWhereInput
    orderBy?: GroupeOrderByWithAggregationInput | GroupeOrderByWithAggregationInput[]
    by: GroupeScalarFieldEnum[] | GroupeScalarFieldEnum
    having?: GroupeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupeCountAggregateInputType | true
    _avg?: GroupeAvgAggregateInputType
    _sum?: GroupeSumAggregateInputType
    _min?: GroupeMinAggregateInputType
    _max?: GroupeMaxAggregateInputType
  }

  export type GroupeGroupByOutputType = {
    idGroupe: number
    nomGroupe: string
    nbEtudiants: number
    _count: GroupeCountAggregateOutputType | null
    _avg: GroupeAvgAggregateOutputType | null
    _sum: GroupeSumAggregateOutputType | null
    _min: GroupeMinAggregateOutputType | null
    _max: GroupeMaxAggregateOutputType | null
  }

  type GetGroupeGroupByPayload<T extends GroupeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupeGroupByOutputType[P]>
            : GetScalarType<T[P], GroupeGroupByOutputType[P]>
        }
      >
    >


  export type GroupeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idGroupe?: boolean
    nomGroupe?: boolean
    nbEtudiants?: boolean
    etudiants?: boolean | Groupe$etudiantsArgs<ExtArgs>
    PFEs?: boolean | Groupe$PFEsArgs<ExtArgs>
    _count?: boolean | GroupeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupe"]>



  export type GroupeSelectScalar = {
    idGroupe?: boolean
    nomGroupe?: boolean
    nbEtudiants?: boolean
  }

  export type GroupeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idGroupe" | "nomGroupe" | "nbEtudiants", ExtArgs["result"]["groupe"]>
  export type GroupeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etudiants?: boolean | Groupe$etudiantsArgs<ExtArgs>
    PFEs?: boolean | Groupe$PFEsArgs<ExtArgs>
    _count?: boolean | GroupeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GroupePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Groupe"
    objects: {
      etudiants: Prisma.$EtudiantGroupePayload<ExtArgs>[]
      PFEs: Prisma.$PFE_GroupePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idGroupe: number
      nomGroupe: string
      nbEtudiants: number
    }, ExtArgs["result"]["groupe"]>
    composites: {}
  }

  type GroupeGetPayload<S extends boolean | null | undefined | GroupeDefaultArgs> = $Result.GetResult<Prisma.$GroupePayload, S>

  type GroupeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupeCountAggregateInputType | true
    }

  export interface GroupeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Groupe'], meta: { name: 'Groupe' } }
    /**
     * Find zero or one Groupe that matches the filter.
     * @param {GroupeFindUniqueArgs} args - Arguments to find a Groupe
     * @example
     * // Get one Groupe
     * const groupe = await prisma.groupe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupeFindUniqueArgs>(args: SelectSubset<T, GroupeFindUniqueArgs<ExtArgs>>): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Groupe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupeFindUniqueOrThrowArgs} args - Arguments to find a Groupe
     * @example
     * // Get one Groupe
     * const groupe = await prisma.groupe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupeFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Groupe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeFindFirstArgs} args - Arguments to find a Groupe
     * @example
     * // Get one Groupe
     * const groupe = await prisma.groupe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupeFindFirstArgs>(args?: SelectSubset<T, GroupeFindFirstArgs<ExtArgs>>): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Groupe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeFindFirstOrThrowArgs} args - Arguments to find a Groupe
     * @example
     * // Get one Groupe
     * const groupe = await prisma.groupe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupeFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Groupes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groupes
     * const groupes = await prisma.groupe.findMany()
     * 
     * // Get first 10 Groupes
     * const groupes = await prisma.groupe.findMany({ take: 10 })
     * 
     * // Only select the `idGroupe`
     * const groupeWithIdGroupeOnly = await prisma.groupe.findMany({ select: { idGroupe: true } })
     * 
     */
    findMany<T extends GroupeFindManyArgs>(args?: SelectSubset<T, GroupeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Groupe.
     * @param {GroupeCreateArgs} args - Arguments to create a Groupe.
     * @example
     * // Create one Groupe
     * const Groupe = await prisma.groupe.create({
     *   data: {
     *     // ... data to create a Groupe
     *   }
     * })
     * 
     */
    create<T extends GroupeCreateArgs>(args: SelectSubset<T, GroupeCreateArgs<ExtArgs>>): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Groupes.
     * @param {GroupeCreateManyArgs} args - Arguments to create many Groupes.
     * @example
     * // Create many Groupes
     * const groupe = await prisma.groupe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupeCreateManyArgs>(args?: SelectSubset<T, GroupeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Groupe.
     * @param {GroupeDeleteArgs} args - Arguments to delete one Groupe.
     * @example
     * // Delete one Groupe
     * const Groupe = await prisma.groupe.delete({
     *   where: {
     *     // ... filter to delete one Groupe
     *   }
     * })
     * 
     */
    delete<T extends GroupeDeleteArgs>(args: SelectSubset<T, GroupeDeleteArgs<ExtArgs>>): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Groupe.
     * @param {GroupeUpdateArgs} args - Arguments to update one Groupe.
     * @example
     * // Update one Groupe
     * const groupe = await prisma.groupe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupeUpdateArgs>(args: SelectSubset<T, GroupeUpdateArgs<ExtArgs>>): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Groupes.
     * @param {GroupeDeleteManyArgs} args - Arguments to filter Groupes to delete.
     * @example
     * // Delete a few Groupes
     * const { count } = await prisma.groupe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupeDeleteManyArgs>(args?: SelectSubset<T, GroupeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groupes
     * const groupe = await prisma.groupe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupeUpdateManyArgs>(args: SelectSubset<T, GroupeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Groupe.
     * @param {GroupeUpsertArgs} args - Arguments to update or create a Groupe.
     * @example
     * // Update or create a Groupe
     * const groupe = await prisma.groupe.upsert({
     *   create: {
     *     // ... data to create a Groupe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groupe we want to update
     *   }
     * })
     */
    upsert<T extends GroupeUpsertArgs>(args: SelectSubset<T, GroupeUpsertArgs<ExtArgs>>): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeCountArgs} args - Arguments to filter Groupes to count.
     * @example
     * // Count the number of Groupes
     * const count = await prisma.groupe.count({
     *   where: {
     *     // ... the filter for the Groupes we want to count
     *   }
     * })
    **/
    count<T extends GroupeCountArgs>(
      args?: Subset<T, GroupeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groupe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupeAggregateArgs>(args: Subset<T, GroupeAggregateArgs>): Prisma.PrismaPromise<GetGroupeAggregateType<T>>

    /**
     * Group by Groupe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupeGroupByArgs['orderBy'] }
        : { orderBy?: GroupeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Groupe model
   */
  readonly fields: GroupeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Groupe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    etudiants<T extends Groupe$etudiantsArgs<ExtArgs> = {}>(args?: Subset<T, Groupe$etudiantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    PFEs<T extends Groupe$PFEsArgs<ExtArgs> = {}>(args?: Subset<T, Groupe$PFEsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Groupe model
   */ 
  interface GroupeFieldRefs {
    readonly idGroupe: FieldRef<"Groupe", 'Int'>
    readonly nomGroupe: FieldRef<"Groupe", 'String'>
    readonly nbEtudiants: FieldRef<"Groupe", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Groupe findUnique
   */
  export type GroupeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groupe
     */
    omit?: GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter, which Groupe to fetch.
     */
    where: GroupeWhereUniqueInput
  }

  /**
   * Groupe findUniqueOrThrow
   */
  export type GroupeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groupe
     */
    omit?: GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter, which Groupe to fetch.
     */
    where: GroupeWhereUniqueInput
  }

  /**
   * Groupe findFirst
   */
  export type GroupeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groupe
     */
    omit?: GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter, which Groupe to fetch.
     */
    where?: GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groupes to fetch.
     */
    orderBy?: GroupeOrderByWithRelationInput | GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groupes.
     */
    cursor?: GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groupes.
     */
    distinct?: GroupeScalarFieldEnum | GroupeScalarFieldEnum[]
  }

  /**
   * Groupe findFirstOrThrow
   */
  export type GroupeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groupe
     */
    omit?: GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter, which Groupe to fetch.
     */
    where?: GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groupes to fetch.
     */
    orderBy?: GroupeOrderByWithRelationInput | GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groupes.
     */
    cursor?: GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groupes.
     */
    distinct?: GroupeScalarFieldEnum | GroupeScalarFieldEnum[]
  }

  /**
   * Groupe findMany
   */
  export type GroupeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groupe
     */
    omit?: GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter, which Groupes to fetch.
     */
    where?: GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groupes to fetch.
     */
    orderBy?: GroupeOrderByWithRelationInput | GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groupes.
     */
    cursor?: GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groupes.
     */
    skip?: number
    distinct?: GroupeScalarFieldEnum | GroupeScalarFieldEnum[]
  }

  /**
   * Groupe create
   */
  export type GroupeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groupe
     */
    omit?: GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * The data needed to create a Groupe.
     */
    data: XOR<GroupeCreateInput, GroupeUncheckedCreateInput>
  }

  /**
   * Groupe createMany
   */
  export type GroupeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groupes.
     */
    data: GroupeCreateManyInput | GroupeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Groupe update
   */
  export type GroupeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groupe
     */
    omit?: GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * The data needed to update a Groupe.
     */
    data: XOR<GroupeUpdateInput, GroupeUncheckedUpdateInput>
    /**
     * Choose, which Groupe to update.
     */
    where: GroupeWhereUniqueInput
  }

  /**
   * Groupe updateMany
   */
  export type GroupeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groupes.
     */
    data: XOR<GroupeUpdateManyMutationInput, GroupeUncheckedUpdateManyInput>
    /**
     * Filter which Groupes to update
     */
    where?: GroupeWhereInput
    /**
     * Limit how many Groupes to update.
     */
    limit?: number
  }

  /**
   * Groupe upsert
   */
  export type GroupeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groupe
     */
    omit?: GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * The filter to search for the Groupe to update in case it exists.
     */
    where: GroupeWhereUniqueInput
    /**
     * In case the Groupe found by the `where` argument doesn't exist, create a new Groupe with this data.
     */
    create: XOR<GroupeCreateInput, GroupeUncheckedCreateInput>
    /**
     * In case the Groupe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupeUpdateInput, GroupeUncheckedUpdateInput>
  }

  /**
   * Groupe delete
   */
  export type GroupeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groupe
     */
    omit?: GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupeInclude<ExtArgs> | null
    /**
     * Filter which Groupe to delete.
     */
    where: GroupeWhereUniqueInput
  }

  /**
   * Groupe deleteMany
   */
  export type GroupeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groupes to delete
     */
    where?: GroupeWhereInput
    /**
     * Limit how many Groupes to delete.
     */
    limit?: number
  }

  /**
   * Groupe.etudiants
   */
  export type Groupe$etudiantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    where?: EtudiantGroupeWhereInput
    orderBy?: EtudiantGroupeOrderByWithRelationInput | EtudiantGroupeOrderByWithRelationInput[]
    cursor?: EtudiantGroupeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtudiantGroupeScalarFieldEnum | EtudiantGroupeScalarFieldEnum[]
  }

  /**
   * Groupe.PFEs
   */
  export type Groupe$PFEsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    where?: PFE_GroupeWhereInput
    orderBy?: PFE_GroupeOrderByWithRelationInput | PFE_GroupeOrderByWithRelationInput[]
    cursor?: PFE_GroupeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PFE_GroupeScalarFieldEnum | PFE_GroupeScalarFieldEnum[]
  }

  /**
   * Groupe without action
   */
  export type GroupeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groupe
     */
    select?: GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groupe
     */
    omit?: GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupeInclude<ExtArgs> | null
  }


  /**
   * Model EtudiantGroupe
   */

  export type AggregateEtudiantGroupe = {
    _count: EtudiantGroupeCountAggregateOutputType | null
    _avg: EtudiantGroupeAvgAggregateOutputType | null
    _sum: EtudiantGroupeSumAggregateOutputType | null
    _min: EtudiantGroupeMinAggregateOutputType | null
    _max: EtudiantGroupeMaxAggregateOutputType | null
  }

  export type EtudiantGroupeAvgAggregateOutputType = {
    idEtudiant: number | null
    idGroupe: number | null
  }

  export type EtudiantGroupeSumAggregateOutputType = {
    idEtudiant: number | null
    idGroupe: number | null
  }

  export type EtudiantGroupeMinAggregateOutputType = {
    idEtudiant: number | null
    idGroupe: number | null
  }

  export type EtudiantGroupeMaxAggregateOutputType = {
    idEtudiant: number | null
    idGroupe: number | null
  }

  export type EtudiantGroupeCountAggregateOutputType = {
    idEtudiant: number
    idGroupe: number
    _all: number
  }


  export type EtudiantGroupeAvgAggregateInputType = {
    idEtudiant?: true
    idGroupe?: true
  }

  export type EtudiantGroupeSumAggregateInputType = {
    idEtudiant?: true
    idGroupe?: true
  }

  export type EtudiantGroupeMinAggregateInputType = {
    idEtudiant?: true
    idGroupe?: true
  }

  export type EtudiantGroupeMaxAggregateInputType = {
    idEtudiant?: true
    idGroupe?: true
  }

  export type EtudiantGroupeCountAggregateInputType = {
    idEtudiant?: true
    idGroupe?: true
    _all?: true
  }

  export type EtudiantGroupeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EtudiantGroupe to aggregate.
     */
    where?: EtudiantGroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtudiantGroupes to fetch.
     */
    orderBy?: EtudiantGroupeOrderByWithRelationInput | EtudiantGroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtudiantGroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtudiantGroupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtudiantGroupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EtudiantGroupes
    **/
    _count?: true | EtudiantGroupeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtudiantGroupeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtudiantGroupeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtudiantGroupeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtudiantGroupeMaxAggregateInputType
  }

  export type GetEtudiantGroupeAggregateType<T extends EtudiantGroupeAggregateArgs> = {
        [P in keyof T & keyof AggregateEtudiantGroupe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtudiantGroupe[P]>
      : GetScalarType<T[P], AggregateEtudiantGroupe[P]>
  }




  export type EtudiantGroupeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtudiantGroupeWhereInput
    orderBy?: EtudiantGroupeOrderByWithAggregationInput | EtudiantGroupeOrderByWithAggregationInput[]
    by: EtudiantGroupeScalarFieldEnum[] | EtudiantGroupeScalarFieldEnum
    having?: EtudiantGroupeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtudiantGroupeCountAggregateInputType | true
    _avg?: EtudiantGroupeAvgAggregateInputType
    _sum?: EtudiantGroupeSumAggregateInputType
    _min?: EtudiantGroupeMinAggregateInputType
    _max?: EtudiantGroupeMaxAggregateInputType
  }

  export type EtudiantGroupeGroupByOutputType = {
    idEtudiant: number
    idGroupe: number
    _count: EtudiantGroupeCountAggregateOutputType | null
    _avg: EtudiantGroupeAvgAggregateOutputType | null
    _sum: EtudiantGroupeSumAggregateOutputType | null
    _min: EtudiantGroupeMinAggregateOutputType | null
    _max: EtudiantGroupeMaxAggregateOutputType | null
  }

  type GetEtudiantGroupeGroupByPayload<T extends EtudiantGroupeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtudiantGroupeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtudiantGroupeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtudiantGroupeGroupByOutputType[P]>
            : GetScalarType<T[P], EtudiantGroupeGroupByOutputType[P]>
        }
      >
    >


  export type EtudiantGroupeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEtudiant?: boolean
    idGroupe?: boolean
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    groupe?: boolean | GroupeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etudiantGroupe"]>



  export type EtudiantGroupeSelectScalar = {
    idEtudiant?: boolean
    idGroupe?: boolean
  }

  export type EtudiantGroupeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idEtudiant" | "idGroupe", ExtArgs["result"]["etudiantGroupe"]>
  export type EtudiantGroupeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    groupe?: boolean | GroupeDefaultArgs<ExtArgs>
  }

  export type $EtudiantGroupePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EtudiantGroupe"
    objects: {
      etudiant: Prisma.$EtudiantPayload<ExtArgs>
      groupe: Prisma.$GroupePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idEtudiant: number
      idGroupe: number
    }, ExtArgs["result"]["etudiantGroupe"]>
    composites: {}
  }

  type EtudiantGroupeGetPayload<S extends boolean | null | undefined | EtudiantGroupeDefaultArgs> = $Result.GetResult<Prisma.$EtudiantGroupePayload, S>

  type EtudiantGroupeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EtudiantGroupeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EtudiantGroupeCountAggregateInputType | true
    }

  export interface EtudiantGroupeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EtudiantGroupe'], meta: { name: 'EtudiantGroupe' } }
    /**
     * Find zero or one EtudiantGroupe that matches the filter.
     * @param {EtudiantGroupeFindUniqueArgs} args - Arguments to find a EtudiantGroupe
     * @example
     * // Get one EtudiantGroupe
     * const etudiantGroupe = await prisma.etudiantGroupe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EtudiantGroupeFindUniqueArgs>(args: SelectSubset<T, EtudiantGroupeFindUniqueArgs<ExtArgs>>): Prisma__EtudiantGroupeClient<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EtudiantGroupe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EtudiantGroupeFindUniqueOrThrowArgs} args - Arguments to find a EtudiantGroupe
     * @example
     * // Get one EtudiantGroupe
     * const etudiantGroupe = await prisma.etudiantGroupe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EtudiantGroupeFindUniqueOrThrowArgs>(args: SelectSubset<T, EtudiantGroupeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EtudiantGroupeClient<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EtudiantGroupe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantGroupeFindFirstArgs} args - Arguments to find a EtudiantGroupe
     * @example
     * // Get one EtudiantGroupe
     * const etudiantGroupe = await prisma.etudiantGroupe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EtudiantGroupeFindFirstArgs>(args?: SelectSubset<T, EtudiantGroupeFindFirstArgs<ExtArgs>>): Prisma__EtudiantGroupeClient<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EtudiantGroupe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantGroupeFindFirstOrThrowArgs} args - Arguments to find a EtudiantGroupe
     * @example
     * // Get one EtudiantGroupe
     * const etudiantGroupe = await prisma.etudiantGroupe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EtudiantGroupeFindFirstOrThrowArgs>(args?: SelectSubset<T, EtudiantGroupeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EtudiantGroupeClient<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EtudiantGroupes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantGroupeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EtudiantGroupes
     * const etudiantGroupes = await prisma.etudiantGroupe.findMany()
     * 
     * // Get first 10 EtudiantGroupes
     * const etudiantGroupes = await prisma.etudiantGroupe.findMany({ take: 10 })
     * 
     * // Only select the `idEtudiant`
     * const etudiantGroupeWithIdEtudiantOnly = await prisma.etudiantGroupe.findMany({ select: { idEtudiant: true } })
     * 
     */
    findMany<T extends EtudiantGroupeFindManyArgs>(args?: SelectSubset<T, EtudiantGroupeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EtudiantGroupe.
     * @param {EtudiantGroupeCreateArgs} args - Arguments to create a EtudiantGroupe.
     * @example
     * // Create one EtudiantGroupe
     * const EtudiantGroupe = await prisma.etudiantGroupe.create({
     *   data: {
     *     // ... data to create a EtudiantGroupe
     *   }
     * })
     * 
     */
    create<T extends EtudiantGroupeCreateArgs>(args: SelectSubset<T, EtudiantGroupeCreateArgs<ExtArgs>>): Prisma__EtudiantGroupeClient<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EtudiantGroupes.
     * @param {EtudiantGroupeCreateManyArgs} args - Arguments to create many EtudiantGroupes.
     * @example
     * // Create many EtudiantGroupes
     * const etudiantGroupe = await prisma.etudiantGroupe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EtudiantGroupeCreateManyArgs>(args?: SelectSubset<T, EtudiantGroupeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EtudiantGroupe.
     * @param {EtudiantGroupeDeleteArgs} args - Arguments to delete one EtudiantGroupe.
     * @example
     * // Delete one EtudiantGroupe
     * const EtudiantGroupe = await prisma.etudiantGroupe.delete({
     *   where: {
     *     // ... filter to delete one EtudiantGroupe
     *   }
     * })
     * 
     */
    delete<T extends EtudiantGroupeDeleteArgs>(args: SelectSubset<T, EtudiantGroupeDeleteArgs<ExtArgs>>): Prisma__EtudiantGroupeClient<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EtudiantGroupe.
     * @param {EtudiantGroupeUpdateArgs} args - Arguments to update one EtudiantGroupe.
     * @example
     * // Update one EtudiantGroupe
     * const etudiantGroupe = await prisma.etudiantGroupe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EtudiantGroupeUpdateArgs>(args: SelectSubset<T, EtudiantGroupeUpdateArgs<ExtArgs>>): Prisma__EtudiantGroupeClient<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EtudiantGroupes.
     * @param {EtudiantGroupeDeleteManyArgs} args - Arguments to filter EtudiantGroupes to delete.
     * @example
     * // Delete a few EtudiantGroupes
     * const { count } = await prisma.etudiantGroupe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EtudiantGroupeDeleteManyArgs>(args?: SelectSubset<T, EtudiantGroupeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EtudiantGroupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantGroupeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EtudiantGroupes
     * const etudiantGroupe = await prisma.etudiantGroupe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EtudiantGroupeUpdateManyArgs>(args: SelectSubset<T, EtudiantGroupeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EtudiantGroupe.
     * @param {EtudiantGroupeUpsertArgs} args - Arguments to update or create a EtudiantGroupe.
     * @example
     * // Update or create a EtudiantGroupe
     * const etudiantGroupe = await prisma.etudiantGroupe.upsert({
     *   create: {
     *     // ... data to create a EtudiantGroupe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EtudiantGroupe we want to update
     *   }
     * })
     */
    upsert<T extends EtudiantGroupeUpsertArgs>(args: SelectSubset<T, EtudiantGroupeUpsertArgs<ExtArgs>>): Prisma__EtudiantGroupeClient<$Result.GetResult<Prisma.$EtudiantGroupePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EtudiantGroupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantGroupeCountArgs} args - Arguments to filter EtudiantGroupes to count.
     * @example
     * // Count the number of EtudiantGroupes
     * const count = await prisma.etudiantGroupe.count({
     *   where: {
     *     // ... the filter for the EtudiantGroupes we want to count
     *   }
     * })
    **/
    count<T extends EtudiantGroupeCountArgs>(
      args?: Subset<T, EtudiantGroupeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtudiantGroupeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EtudiantGroupe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantGroupeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtudiantGroupeAggregateArgs>(args: Subset<T, EtudiantGroupeAggregateArgs>): Prisma.PrismaPromise<GetEtudiantGroupeAggregateType<T>>

    /**
     * Group by EtudiantGroupe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantGroupeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtudiantGroupeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtudiantGroupeGroupByArgs['orderBy'] }
        : { orderBy?: EtudiantGroupeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtudiantGroupeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtudiantGroupeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EtudiantGroupe model
   */
  readonly fields: EtudiantGroupeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EtudiantGroupe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtudiantGroupeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    etudiant<T extends EtudiantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtudiantDefaultArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    groupe<T extends GroupeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupeDefaultArgs<ExtArgs>>): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EtudiantGroupe model
   */ 
  interface EtudiantGroupeFieldRefs {
    readonly idEtudiant: FieldRef<"EtudiantGroupe", 'Int'>
    readonly idGroupe: FieldRef<"EtudiantGroupe", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EtudiantGroupe findUnique
   */
  export type EtudiantGroupeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    /**
     * Filter, which EtudiantGroupe to fetch.
     */
    where: EtudiantGroupeWhereUniqueInput
  }

  /**
   * EtudiantGroupe findUniqueOrThrow
   */
  export type EtudiantGroupeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    /**
     * Filter, which EtudiantGroupe to fetch.
     */
    where: EtudiantGroupeWhereUniqueInput
  }

  /**
   * EtudiantGroupe findFirst
   */
  export type EtudiantGroupeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    /**
     * Filter, which EtudiantGroupe to fetch.
     */
    where?: EtudiantGroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtudiantGroupes to fetch.
     */
    orderBy?: EtudiantGroupeOrderByWithRelationInput | EtudiantGroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EtudiantGroupes.
     */
    cursor?: EtudiantGroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtudiantGroupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtudiantGroupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EtudiantGroupes.
     */
    distinct?: EtudiantGroupeScalarFieldEnum | EtudiantGroupeScalarFieldEnum[]
  }

  /**
   * EtudiantGroupe findFirstOrThrow
   */
  export type EtudiantGroupeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    /**
     * Filter, which EtudiantGroupe to fetch.
     */
    where?: EtudiantGroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtudiantGroupes to fetch.
     */
    orderBy?: EtudiantGroupeOrderByWithRelationInput | EtudiantGroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EtudiantGroupes.
     */
    cursor?: EtudiantGroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtudiantGroupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtudiantGroupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EtudiantGroupes.
     */
    distinct?: EtudiantGroupeScalarFieldEnum | EtudiantGroupeScalarFieldEnum[]
  }

  /**
   * EtudiantGroupe findMany
   */
  export type EtudiantGroupeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    /**
     * Filter, which EtudiantGroupes to fetch.
     */
    where?: EtudiantGroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtudiantGroupes to fetch.
     */
    orderBy?: EtudiantGroupeOrderByWithRelationInput | EtudiantGroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EtudiantGroupes.
     */
    cursor?: EtudiantGroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtudiantGroupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtudiantGroupes.
     */
    skip?: number
    distinct?: EtudiantGroupeScalarFieldEnum | EtudiantGroupeScalarFieldEnum[]
  }

  /**
   * EtudiantGroupe create
   */
  export type EtudiantGroupeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    /**
     * The data needed to create a EtudiantGroupe.
     */
    data: XOR<EtudiantGroupeCreateInput, EtudiantGroupeUncheckedCreateInput>
  }

  /**
   * EtudiantGroupe createMany
   */
  export type EtudiantGroupeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EtudiantGroupes.
     */
    data: EtudiantGroupeCreateManyInput | EtudiantGroupeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EtudiantGroupe update
   */
  export type EtudiantGroupeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    /**
     * The data needed to update a EtudiantGroupe.
     */
    data: XOR<EtudiantGroupeUpdateInput, EtudiantGroupeUncheckedUpdateInput>
    /**
     * Choose, which EtudiantGroupe to update.
     */
    where: EtudiantGroupeWhereUniqueInput
  }

  /**
   * EtudiantGroupe updateMany
   */
  export type EtudiantGroupeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EtudiantGroupes.
     */
    data: XOR<EtudiantGroupeUpdateManyMutationInput, EtudiantGroupeUncheckedUpdateManyInput>
    /**
     * Filter which EtudiantGroupes to update
     */
    where?: EtudiantGroupeWhereInput
    /**
     * Limit how many EtudiantGroupes to update.
     */
    limit?: number
  }

  /**
   * EtudiantGroupe upsert
   */
  export type EtudiantGroupeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    /**
     * The filter to search for the EtudiantGroupe to update in case it exists.
     */
    where: EtudiantGroupeWhereUniqueInput
    /**
     * In case the EtudiantGroupe found by the `where` argument doesn't exist, create a new EtudiantGroupe with this data.
     */
    create: XOR<EtudiantGroupeCreateInput, EtudiantGroupeUncheckedCreateInput>
    /**
     * In case the EtudiantGroupe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtudiantGroupeUpdateInput, EtudiantGroupeUncheckedUpdateInput>
  }

  /**
   * EtudiantGroupe delete
   */
  export type EtudiantGroupeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
    /**
     * Filter which EtudiantGroupe to delete.
     */
    where: EtudiantGroupeWhereUniqueInput
  }

  /**
   * EtudiantGroupe deleteMany
   */
  export type EtudiantGroupeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EtudiantGroupes to delete
     */
    where?: EtudiantGroupeWhereInput
    /**
     * Limit how many EtudiantGroupes to delete.
     */
    limit?: number
  }

  /**
   * EtudiantGroupe without action
   */
  export type EtudiantGroupeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantGroupe
     */
    select?: EtudiantGroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantGroupe
     */
    omit?: EtudiantGroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantGroupeInclude<ExtArgs> | null
  }


  /**
   * Model Sujet
   */

  export type AggregateSujet = {
    _count: SujetCountAggregateOutputType | null
    _avg: SujetAvgAggregateOutputType | null
    _sum: SujetSumAggregateOutputType | null
    _min: SujetMinAggregateOutputType | null
    _max: SujetMaxAggregateOutputType | null
  }

  export type SujetAvgAggregateOutputType = {
    idSujet: number | null
    annee: number | null
    idEncadrant: number | null
  }

  export type SujetSumAggregateOutputType = {
    idSujet: number | null
    annee: number | null
    idEncadrant: number | null
  }

  export type SujetMinAggregateOutputType = {
    idSujet: number | null
    titre: string | null
    description: string | null
    annee: number | null
    idEncadrant: number | null
  }

  export type SujetMaxAggregateOutputType = {
    idSujet: number | null
    titre: string | null
    description: string | null
    annee: number | null
    idEncadrant: number | null
  }

  export type SujetCountAggregateOutputType = {
    idSujet: number
    titre: number
    description: number
    annee: number
    idEncadrant: number
    _all: number
  }


  export type SujetAvgAggregateInputType = {
    idSujet?: true
    annee?: true
    idEncadrant?: true
  }

  export type SujetSumAggregateInputType = {
    idSujet?: true
    annee?: true
    idEncadrant?: true
  }

  export type SujetMinAggregateInputType = {
    idSujet?: true
    titre?: true
    description?: true
    annee?: true
    idEncadrant?: true
  }

  export type SujetMaxAggregateInputType = {
    idSujet?: true
    titre?: true
    description?: true
    annee?: true
    idEncadrant?: true
  }

  export type SujetCountAggregateInputType = {
    idSujet?: true
    titre?: true
    description?: true
    annee?: true
    idEncadrant?: true
    _all?: true
  }

  export type SujetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sujet to aggregate.
     */
    where?: SujetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sujets to fetch.
     */
    orderBy?: SujetOrderByWithRelationInput | SujetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SujetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sujets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sujets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sujets
    **/
    _count?: true | SujetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SujetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SujetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SujetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SujetMaxAggregateInputType
  }

  export type GetSujetAggregateType<T extends SujetAggregateArgs> = {
        [P in keyof T & keyof AggregateSujet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSujet[P]>
      : GetScalarType<T[P], AggregateSujet[P]>
  }




  export type SujetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SujetWhereInput
    orderBy?: SujetOrderByWithAggregationInput | SujetOrderByWithAggregationInput[]
    by: SujetScalarFieldEnum[] | SujetScalarFieldEnum
    having?: SujetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SujetCountAggregateInputType | true
    _avg?: SujetAvgAggregateInputType
    _sum?: SujetSumAggregateInputType
    _min?: SujetMinAggregateInputType
    _max?: SujetMaxAggregateInputType
  }

  export type SujetGroupByOutputType = {
    idSujet: number
    titre: string
    description: string
    annee: number
    idEncadrant: number
    _count: SujetCountAggregateOutputType | null
    _avg: SujetAvgAggregateOutputType | null
    _sum: SujetSumAggregateOutputType | null
    _min: SujetMinAggregateOutputType | null
    _max: SujetMaxAggregateOutputType | null
  }

  type GetSujetGroupByPayload<T extends SujetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SujetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SujetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SujetGroupByOutputType[P]>
            : GetScalarType<T[P], SujetGroupByOutputType[P]>
        }
      >
    >


  export type SujetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSujet?: boolean
    titre?: boolean
    description?: boolean
    annee?: boolean
    idEncadrant?: boolean
    encadrant?: boolean | EncadrantDefaultArgs<ExtArgs>
    etudiants?: boolean | Sujet$etudiantsArgs<ExtArgs>
    _count?: boolean | SujetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sujet"]>



  export type SujetSelectScalar = {
    idSujet?: boolean
    titre?: boolean
    description?: boolean
    annee?: boolean
    idEncadrant?: boolean
  }

  export type SujetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idSujet" | "titre" | "description" | "annee" | "idEncadrant", ExtArgs["result"]["sujet"]>
  export type SujetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encadrant?: boolean | EncadrantDefaultArgs<ExtArgs>
    etudiants?: boolean | Sujet$etudiantsArgs<ExtArgs>
    _count?: boolean | SujetCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SujetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sujet"
    objects: {
      encadrant: Prisma.$EncadrantPayload<ExtArgs>
      etudiants: Prisma.$EtudiantSujetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idSujet: number
      titre: string
      description: string
      annee: number
      idEncadrant: number
    }, ExtArgs["result"]["sujet"]>
    composites: {}
  }

  type SujetGetPayload<S extends boolean | null | undefined | SujetDefaultArgs> = $Result.GetResult<Prisma.$SujetPayload, S>

  type SujetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SujetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SujetCountAggregateInputType | true
    }

  export interface SujetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sujet'], meta: { name: 'Sujet' } }
    /**
     * Find zero or one Sujet that matches the filter.
     * @param {SujetFindUniqueArgs} args - Arguments to find a Sujet
     * @example
     * // Get one Sujet
     * const sujet = await prisma.sujet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SujetFindUniqueArgs>(args: SelectSubset<T, SujetFindUniqueArgs<ExtArgs>>): Prisma__SujetClient<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Sujet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SujetFindUniqueOrThrowArgs} args - Arguments to find a Sujet
     * @example
     * // Get one Sujet
     * const sujet = await prisma.sujet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SujetFindUniqueOrThrowArgs>(args: SelectSubset<T, SujetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SujetClient<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Sujet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SujetFindFirstArgs} args - Arguments to find a Sujet
     * @example
     * // Get one Sujet
     * const sujet = await prisma.sujet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SujetFindFirstArgs>(args?: SelectSubset<T, SujetFindFirstArgs<ExtArgs>>): Prisma__SujetClient<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Sujet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SujetFindFirstOrThrowArgs} args - Arguments to find a Sujet
     * @example
     * // Get one Sujet
     * const sujet = await prisma.sujet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SujetFindFirstOrThrowArgs>(args?: SelectSubset<T, SujetFindFirstOrThrowArgs<ExtArgs>>): Prisma__SujetClient<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sujets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SujetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sujets
     * const sujets = await prisma.sujet.findMany()
     * 
     * // Get first 10 Sujets
     * const sujets = await prisma.sujet.findMany({ take: 10 })
     * 
     * // Only select the `idSujet`
     * const sujetWithIdSujetOnly = await prisma.sujet.findMany({ select: { idSujet: true } })
     * 
     */
    findMany<T extends SujetFindManyArgs>(args?: SelectSubset<T, SujetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Sujet.
     * @param {SujetCreateArgs} args - Arguments to create a Sujet.
     * @example
     * // Create one Sujet
     * const Sujet = await prisma.sujet.create({
     *   data: {
     *     // ... data to create a Sujet
     *   }
     * })
     * 
     */
    create<T extends SujetCreateArgs>(args: SelectSubset<T, SujetCreateArgs<ExtArgs>>): Prisma__SujetClient<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sujets.
     * @param {SujetCreateManyArgs} args - Arguments to create many Sujets.
     * @example
     * // Create many Sujets
     * const sujet = await prisma.sujet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SujetCreateManyArgs>(args?: SelectSubset<T, SujetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sujet.
     * @param {SujetDeleteArgs} args - Arguments to delete one Sujet.
     * @example
     * // Delete one Sujet
     * const Sujet = await prisma.sujet.delete({
     *   where: {
     *     // ... filter to delete one Sujet
     *   }
     * })
     * 
     */
    delete<T extends SujetDeleteArgs>(args: SelectSubset<T, SujetDeleteArgs<ExtArgs>>): Prisma__SujetClient<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Sujet.
     * @param {SujetUpdateArgs} args - Arguments to update one Sujet.
     * @example
     * // Update one Sujet
     * const sujet = await prisma.sujet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SujetUpdateArgs>(args: SelectSubset<T, SujetUpdateArgs<ExtArgs>>): Prisma__SujetClient<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sujets.
     * @param {SujetDeleteManyArgs} args - Arguments to filter Sujets to delete.
     * @example
     * // Delete a few Sujets
     * const { count } = await prisma.sujet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SujetDeleteManyArgs>(args?: SelectSubset<T, SujetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sujets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SujetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sujets
     * const sujet = await prisma.sujet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SujetUpdateManyArgs>(args: SelectSubset<T, SujetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sujet.
     * @param {SujetUpsertArgs} args - Arguments to update or create a Sujet.
     * @example
     * // Update or create a Sujet
     * const sujet = await prisma.sujet.upsert({
     *   create: {
     *     // ... data to create a Sujet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sujet we want to update
     *   }
     * })
     */
    upsert<T extends SujetUpsertArgs>(args: SelectSubset<T, SujetUpsertArgs<ExtArgs>>): Prisma__SujetClient<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sujets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SujetCountArgs} args - Arguments to filter Sujets to count.
     * @example
     * // Count the number of Sujets
     * const count = await prisma.sujet.count({
     *   where: {
     *     // ... the filter for the Sujets we want to count
     *   }
     * })
    **/
    count<T extends SujetCountArgs>(
      args?: Subset<T, SujetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SujetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sujet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SujetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SujetAggregateArgs>(args: Subset<T, SujetAggregateArgs>): Prisma.PrismaPromise<GetSujetAggregateType<T>>

    /**
     * Group by Sujet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SujetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SujetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SujetGroupByArgs['orderBy'] }
        : { orderBy?: SujetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SujetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSujetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sujet model
   */
  readonly fields: SujetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sujet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SujetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encadrant<T extends EncadrantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncadrantDefaultArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    etudiants<T extends Sujet$etudiantsArgs<ExtArgs> = {}>(args?: Subset<T, Sujet$etudiantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sujet model
   */ 
  interface SujetFieldRefs {
    readonly idSujet: FieldRef<"Sujet", 'Int'>
    readonly titre: FieldRef<"Sujet", 'String'>
    readonly description: FieldRef<"Sujet", 'String'>
    readonly annee: FieldRef<"Sujet", 'Int'>
    readonly idEncadrant: FieldRef<"Sujet", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Sujet findUnique
   */
  export type SujetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
    /**
     * Filter, which Sujet to fetch.
     */
    where: SujetWhereUniqueInput
  }

  /**
   * Sujet findUniqueOrThrow
   */
  export type SujetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
    /**
     * Filter, which Sujet to fetch.
     */
    where: SujetWhereUniqueInput
  }

  /**
   * Sujet findFirst
   */
  export type SujetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
    /**
     * Filter, which Sujet to fetch.
     */
    where?: SujetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sujets to fetch.
     */
    orderBy?: SujetOrderByWithRelationInput | SujetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sujets.
     */
    cursor?: SujetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sujets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sujets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sujets.
     */
    distinct?: SujetScalarFieldEnum | SujetScalarFieldEnum[]
  }

  /**
   * Sujet findFirstOrThrow
   */
  export type SujetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
    /**
     * Filter, which Sujet to fetch.
     */
    where?: SujetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sujets to fetch.
     */
    orderBy?: SujetOrderByWithRelationInput | SujetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sujets.
     */
    cursor?: SujetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sujets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sujets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sujets.
     */
    distinct?: SujetScalarFieldEnum | SujetScalarFieldEnum[]
  }

  /**
   * Sujet findMany
   */
  export type SujetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
    /**
     * Filter, which Sujets to fetch.
     */
    where?: SujetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sujets to fetch.
     */
    orderBy?: SujetOrderByWithRelationInput | SujetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sujets.
     */
    cursor?: SujetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sujets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sujets.
     */
    skip?: number
    distinct?: SujetScalarFieldEnum | SujetScalarFieldEnum[]
  }

  /**
   * Sujet create
   */
  export type SujetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
    /**
     * The data needed to create a Sujet.
     */
    data: XOR<SujetCreateInput, SujetUncheckedCreateInput>
  }

  /**
   * Sujet createMany
   */
  export type SujetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sujets.
     */
    data: SujetCreateManyInput | SujetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sujet update
   */
  export type SujetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
    /**
     * The data needed to update a Sujet.
     */
    data: XOR<SujetUpdateInput, SujetUncheckedUpdateInput>
    /**
     * Choose, which Sujet to update.
     */
    where: SujetWhereUniqueInput
  }

  /**
   * Sujet updateMany
   */
  export type SujetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sujets.
     */
    data: XOR<SujetUpdateManyMutationInput, SujetUncheckedUpdateManyInput>
    /**
     * Filter which Sujets to update
     */
    where?: SujetWhereInput
    /**
     * Limit how many Sujets to update.
     */
    limit?: number
  }

  /**
   * Sujet upsert
   */
  export type SujetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
    /**
     * The filter to search for the Sujet to update in case it exists.
     */
    where: SujetWhereUniqueInput
    /**
     * In case the Sujet found by the `where` argument doesn't exist, create a new Sujet with this data.
     */
    create: XOR<SujetCreateInput, SujetUncheckedCreateInput>
    /**
     * In case the Sujet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SujetUpdateInput, SujetUncheckedUpdateInput>
  }

  /**
   * Sujet delete
   */
  export type SujetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
    /**
     * Filter which Sujet to delete.
     */
    where: SujetWhereUniqueInput
  }

  /**
   * Sujet deleteMany
   */
  export type SujetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sujets to delete
     */
    where?: SujetWhereInput
    /**
     * Limit how many Sujets to delete.
     */
    limit?: number
  }

  /**
   * Sujet.etudiants
   */
  export type Sujet$etudiantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    where?: EtudiantSujetWhereInput
    orderBy?: EtudiantSujetOrderByWithRelationInput | EtudiantSujetOrderByWithRelationInput[]
    cursor?: EtudiantSujetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EtudiantSujetScalarFieldEnum | EtudiantSujetScalarFieldEnum[]
  }

  /**
   * Sujet without action
   */
  export type SujetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sujet
     */
    select?: SujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sujet
     */
    omit?: SujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SujetInclude<ExtArgs> | null
  }


  /**
   * Model EtudiantSujet
   */

  export type AggregateEtudiantSujet = {
    _count: EtudiantSujetCountAggregateOutputType | null
    _avg: EtudiantSujetAvgAggregateOutputType | null
    _sum: EtudiantSujetSumAggregateOutputType | null
    _min: EtudiantSujetMinAggregateOutputType | null
    _max: EtudiantSujetMaxAggregateOutputType | null
  }

  export type EtudiantSujetAvgAggregateOutputType = {
    idEtudiant: number | null
    idSujet: number | null
  }

  export type EtudiantSujetSumAggregateOutputType = {
    idEtudiant: number | null
    idSujet: number | null
  }

  export type EtudiantSujetMinAggregateOutputType = {
    idEtudiant: number | null
    idSujet: number | null
  }

  export type EtudiantSujetMaxAggregateOutputType = {
    idEtudiant: number | null
    idSujet: number | null
  }

  export type EtudiantSujetCountAggregateOutputType = {
    idEtudiant: number
    idSujet: number
    _all: number
  }


  export type EtudiantSujetAvgAggregateInputType = {
    idEtudiant?: true
    idSujet?: true
  }

  export type EtudiantSujetSumAggregateInputType = {
    idEtudiant?: true
    idSujet?: true
  }

  export type EtudiantSujetMinAggregateInputType = {
    idEtudiant?: true
    idSujet?: true
  }

  export type EtudiantSujetMaxAggregateInputType = {
    idEtudiant?: true
    idSujet?: true
  }

  export type EtudiantSujetCountAggregateInputType = {
    idEtudiant?: true
    idSujet?: true
    _all?: true
  }

  export type EtudiantSujetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EtudiantSujet to aggregate.
     */
    where?: EtudiantSujetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtudiantSujets to fetch.
     */
    orderBy?: EtudiantSujetOrderByWithRelationInput | EtudiantSujetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EtudiantSujetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtudiantSujets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtudiantSujets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EtudiantSujets
    **/
    _count?: true | EtudiantSujetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtudiantSujetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtudiantSujetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtudiantSujetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtudiantSujetMaxAggregateInputType
  }

  export type GetEtudiantSujetAggregateType<T extends EtudiantSujetAggregateArgs> = {
        [P in keyof T & keyof AggregateEtudiantSujet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtudiantSujet[P]>
      : GetScalarType<T[P], AggregateEtudiantSujet[P]>
  }




  export type EtudiantSujetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EtudiantSujetWhereInput
    orderBy?: EtudiantSujetOrderByWithAggregationInput | EtudiantSujetOrderByWithAggregationInput[]
    by: EtudiantSujetScalarFieldEnum[] | EtudiantSujetScalarFieldEnum
    having?: EtudiantSujetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtudiantSujetCountAggregateInputType | true
    _avg?: EtudiantSujetAvgAggregateInputType
    _sum?: EtudiantSujetSumAggregateInputType
    _min?: EtudiantSujetMinAggregateInputType
    _max?: EtudiantSujetMaxAggregateInputType
  }

  export type EtudiantSujetGroupByOutputType = {
    idEtudiant: number
    idSujet: number
    _count: EtudiantSujetCountAggregateOutputType | null
    _avg: EtudiantSujetAvgAggregateOutputType | null
    _sum: EtudiantSujetSumAggregateOutputType | null
    _min: EtudiantSujetMinAggregateOutputType | null
    _max: EtudiantSujetMaxAggregateOutputType | null
  }

  type GetEtudiantSujetGroupByPayload<T extends EtudiantSujetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtudiantSujetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtudiantSujetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtudiantSujetGroupByOutputType[P]>
            : GetScalarType<T[P], EtudiantSujetGroupByOutputType[P]>
        }
      >
    >


  export type EtudiantSujetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEtudiant?: boolean
    idSujet?: boolean
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    sujet?: boolean | SujetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etudiantSujet"]>



  export type EtudiantSujetSelectScalar = {
    idEtudiant?: boolean
    idSujet?: boolean
  }

  export type EtudiantSujetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idEtudiant" | "idSujet", ExtArgs["result"]["etudiantSujet"]>
  export type EtudiantSujetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
    sujet?: boolean | SujetDefaultArgs<ExtArgs>
  }

  export type $EtudiantSujetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EtudiantSujet"
    objects: {
      etudiant: Prisma.$EtudiantPayload<ExtArgs>
      sujet: Prisma.$SujetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idEtudiant: number
      idSujet: number
    }, ExtArgs["result"]["etudiantSujet"]>
    composites: {}
  }

  type EtudiantSujetGetPayload<S extends boolean | null | undefined | EtudiantSujetDefaultArgs> = $Result.GetResult<Prisma.$EtudiantSujetPayload, S>

  type EtudiantSujetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EtudiantSujetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EtudiantSujetCountAggregateInputType | true
    }

  export interface EtudiantSujetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EtudiantSujet'], meta: { name: 'EtudiantSujet' } }
    /**
     * Find zero or one EtudiantSujet that matches the filter.
     * @param {EtudiantSujetFindUniqueArgs} args - Arguments to find a EtudiantSujet
     * @example
     * // Get one EtudiantSujet
     * const etudiantSujet = await prisma.etudiantSujet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EtudiantSujetFindUniqueArgs>(args: SelectSubset<T, EtudiantSujetFindUniqueArgs<ExtArgs>>): Prisma__EtudiantSujetClient<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EtudiantSujet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EtudiantSujetFindUniqueOrThrowArgs} args - Arguments to find a EtudiantSujet
     * @example
     * // Get one EtudiantSujet
     * const etudiantSujet = await prisma.etudiantSujet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EtudiantSujetFindUniqueOrThrowArgs>(args: SelectSubset<T, EtudiantSujetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EtudiantSujetClient<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EtudiantSujet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantSujetFindFirstArgs} args - Arguments to find a EtudiantSujet
     * @example
     * // Get one EtudiantSujet
     * const etudiantSujet = await prisma.etudiantSujet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EtudiantSujetFindFirstArgs>(args?: SelectSubset<T, EtudiantSujetFindFirstArgs<ExtArgs>>): Prisma__EtudiantSujetClient<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EtudiantSujet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantSujetFindFirstOrThrowArgs} args - Arguments to find a EtudiantSujet
     * @example
     * // Get one EtudiantSujet
     * const etudiantSujet = await prisma.etudiantSujet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EtudiantSujetFindFirstOrThrowArgs>(args?: SelectSubset<T, EtudiantSujetFindFirstOrThrowArgs<ExtArgs>>): Prisma__EtudiantSujetClient<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EtudiantSujets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantSujetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EtudiantSujets
     * const etudiantSujets = await prisma.etudiantSujet.findMany()
     * 
     * // Get first 10 EtudiantSujets
     * const etudiantSujets = await prisma.etudiantSujet.findMany({ take: 10 })
     * 
     * // Only select the `idEtudiant`
     * const etudiantSujetWithIdEtudiantOnly = await prisma.etudiantSujet.findMany({ select: { idEtudiant: true } })
     * 
     */
    findMany<T extends EtudiantSujetFindManyArgs>(args?: SelectSubset<T, EtudiantSujetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EtudiantSujet.
     * @param {EtudiantSujetCreateArgs} args - Arguments to create a EtudiantSujet.
     * @example
     * // Create one EtudiantSujet
     * const EtudiantSujet = await prisma.etudiantSujet.create({
     *   data: {
     *     // ... data to create a EtudiantSujet
     *   }
     * })
     * 
     */
    create<T extends EtudiantSujetCreateArgs>(args: SelectSubset<T, EtudiantSujetCreateArgs<ExtArgs>>): Prisma__EtudiantSujetClient<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EtudiantSujets.
     * @param {EtudiantSujetCreateManyArgs} args - Arguments to create many EtudiantSujets.
     * @example
     * // Create many EtudiantSujets
     * const etudiantSujet = await prisma.etudiantSujet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EtudiantSujetCreateManyArgs>(args?: SelectSubset<T, EtudiantSujetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EtudiantSujet.
     * @param {EtudiantSujetDeleteArgs} args - Arguments to delete one EtudiantSujet.
     * @example
     * // Delete one EtudiantSujet
     * const EtudiantSujet = await prisma.etudiantSujet.delete({
     *   where: {
     *     // ... filter to delete one EtudiantSujet
     *   }
     * })
     * 
     */
    delete<T extends EtudiantSujetDeleteArgs>(args: SelectSubset<T, EtudiantSujetDeleteArgs<ExtArgs>>): Prisma__EtudiantSujetClient<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EtudiantSujet.
     * @param {EtudiantSujetUpdateArgs} args - Arguments to update one EtudiantSujet.
     * @example
     * // Update one EtudiantSujet
     * const etudiantSujet = await prisma.etudiantSujet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EtudiantSujetUpdateArgs>(args: SelectSubset<T, EtudiantSujetUpdateArgs<ExtArgs>>): Prisma__EtudiantSujetClient<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EtudiantSujets.
     * @param {EtudiantSujetDeleteManyArgs} args - Arguments to filter EtudiantSujets to delete.
     * @example
     * // Delete a few EtudiantSujets
     * const { count } = await prisma.etudiantSujet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EtudiantSujetDeleteManyArgs>(args?: SelectSubset<T, EtudiantSujetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EtudiantSujets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantSujetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EtudiantSujets
     * const etudiantSujet = await prisma.etudiantSujet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EtudiantSujetUpdateManyArgs>(args: SelectSubset<T, EtudiantSujetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EtudiantSujet.
     * @param {EtudiantSujetUpsertArgs} args - Arguments to update or create a EtudiantSujet.
     * @example
     * // Update or create a EtudiantSujet
     * const etudiantSujet = await prisma.etudiantSujet.upsert({
     *   create: {
     *     // ... data to create a EtudiantSujet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EtudiantSujet we want to update
     *   }
     * })
     */
    upsert<T extends EtudiantSujetUpsertArgs>(args: SelectSubset<T, EtudiantSujetUpsertArgs<ExtArgs>>): Prisma__EtudiantSujetClient<$Result.GetResult<Prisma.$EtudiantSujetPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EtudiantSujets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantSujetCountArgs} args - Arguments to filter EtudiantSujets to count.
     * @example
     * // Count the number of EtudiantSujets
     * const count = await prisma.etudiantSujet.count({
     *   where: {
     *     // ... the filter for the EtudiantSujets we want to count
     *   }
     * })
    **/
    count<T extends EtudiantSujetCountArgs>(
      args?: Subset<T, EtudiantSujetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtudiantSujetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EtudiantSujet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantSujetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtudiantSujetAggregateArgs>(args: Subset<T, EtudiantSujetAggregateArgs>): Prisma.PrismaPromise<GetEtudiantSujetAggregateType<T>>

    /**
     * Group by EtudiantSujet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantSujetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EtudiantSujetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EtudiantSujetGroupByArgs['orderBy'] }
        : { orderBy?: EtudiantSujetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EtudiantSujetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtudiantSujetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EtudiantSujet model
   */
  readonly fields: EtudiantSujetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EtudiantSujet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EtudiantSujetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    etudiant<T extends EtudiantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtudiantDefaultArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    sujet<T extends SujetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SujetDefaultArgs<ExtArgs>>): Prisma__SujetClient<$Result.GetResult<Prisma.$SujetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EtudiantSujet model
   */ 
  interface EtudiantSujetFieldRefs {
    readonly idEtudiant: FieldRef<"EtudiantSujet", 'Int'>
    readonly idSujet: FieldRef<"EtudiantSujet", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EtudiantSujet findUnique
   */
  export type EtudiantSujetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    /**
     * Filter, which EtudiantSujet to fetch.
     */
    where: EtudiantSujetWhereUniqueInput
  }

  /**
   * EtudiantSujet findUniqueOrThrow
   */
  export type EtudiantSujetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    /**
     * Filter, which EtudiantSujet to fetch.
     */
    where: EtudiantSujetWhereUniqueInput
  }

  /**
   * EtudiantSujet findFirst
   */
  export type EtudiantSujetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    /**
     * Filter, which EtudiantSujet to fetch.
     */
    where?: EtudiantSujetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtudiantSujets to fetch.
     */
    orderBy?: EtudiantSujetOrderByWithRelationInput | EtudiantSujetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EtudiantSujets.
     */
    cursor?: EtudiantSujetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtudiantSujets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtudiantSujets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EtudiantSujets.
     */
    distinct?: EtudiantSujetScalarFieldEnum | EtudiantSujetScalarFieldEnum[]
  }

  /**
   * EtudiantSujet findFirstOrThrow
   */
  export type EtudiantSujetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    /**
     * Filter, which EtudiantSujet to fetch.
     */
    where?: EtudiantSujetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtudiantSujets to fetch.
     */
    orderBy?: EtudiantSujetOrderByWithRelationInput | EtudiantSujetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EtudiantSujets.
     */
    cursor?: EtudiantSujetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtudiantSujets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtudiantSujets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EtudiantSujets.
     */
    distinct?: EtudiantSujetScalarFieldEnum | EtudiantSujetScalarFieldEnum[]
  }

  /**
   * EtudiantSujet findMany
   */
  export type EtudiantSujetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    /**
     * Filter, which EtudiantSujets to fetch.
     */
    where?: EtudiantSujetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EtudiantSujets to fetch.
     */
    orderBy?: EtudiantSujetOrderByWithRelationInput | EtudiantSujetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EtudiantSujets.
     */
    cursor?: EtudiantSujetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EtudiantSujets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EtudiantSujets.
     */
    skip?: number
    distinct?: EtudiantSujetScalarFieldEnum | EtudiantSujetScalarFieldEnum[]
  }

  /**
   * EtudiantSujet create
   */
  export type EtudiantSujetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    /**
     * The data needed to create a EtudiantSujet.
     */
    data: XOR<EtudiantSujetCreateInput, EtudiantSujetUncheckedCreateInput>
  }

  /**
   * EtudiantSujet createMany
   */
  export type EtudiantSujetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EtudiantSujets.
     */
    data: EtudiantSujetCreateManyInput | EtudiantSujetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EtudiantSujet update
   */
  export type EtudiantSujetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    /**
     * The data needed to update a EtudiantSujet.
     */
    data: XOR<EtudiantSujetUpdateInput, EtudiantSujetUncheckedUpdateInput>
    /**
     * Choose, which EtudiantSujet to update.
     */
    where: EtudiantSujetWhereUniqueInput
  }

  /**
   * EtudiantSujet updateMany
   */
  export type EtudiantSujetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EtudiantSujets.
     */
    data: XOR<EtudiantSujetUpdateManyMutationInput, EtudiantSujetUncheckedUpdateManyInput>
    /**
     * Filter which EtudiantSujets to update
     */
    where?: EtudiantSujetWhereInput
    /**
     * Limit how many EtudiantSujets to update.
     */
    limit?: number
  }

  /**
   * EtudiantSujet upsert
   */
  export type EtudiantSujetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    /**
     * The filter to search for the EtudiantSujet to update in case it exists.
     */
    where: EtudiantSujetWhereUniqueInput
    /**
     * In case the EtudiantSujet found by the `where` argument doesn't exist, create a new EtudiantSujet with this data.
     */
    create: XOR<EtudiantSujetCreateInput, EtudiantSujetUncheckedCreateInput>
    /**
     * In case the EtudiantSujet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EtudiantSujetUpdateInput, EtudiantSujetUncheckedUpdateInput>
  }

  /**
   * EtudiantSujet delete
   */
  export type EtudiantSujetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
    /**
     * Filter which EtudiantSujet to delete.
     */
    where: EtudiantSujetWhereUniqueInput
  }

  /**
   * EtudiantSujet deleteMany
   */
  export type EtudiantSujetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EtudiantSujets to delete
     */
    where?: EtudiantSujetWhereInput
    /**
     * Limit how many EtudiantSujets to delete.
     */
    limit?: number
  }

  /**
   * EtudiantSujet without action
   */
  export type EtudiantSujetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantSujet
     */
    select?: EtudiantSujetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EtudiantSujet
     */
    omit?: EtudiantSujetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EtudiantSujetInclude<ExtArgs> | null
  }


  /**
   * Model Jury
   */

  export type AggregateJury = {
    _count: JuryCountAggregateOutputType | null
    _avg: JuryAvgAggregateOutputType | null
    _sum: JurySumAggregateOutputType | null
    _min: JuryMinAggregateOutputType | null
    _max: JuryMaxAggregateOutputType | null
  }

  export type JuryAvgAggregateOutputType = {
    idJury: number | null
  }

  export type JurySumAggregateOutputType = {
    idJury: number | null
  }

  export type JuryMinAggregateOutputType = {
    idJury: number | null
    valideDeliberation: boolean | null
  }

  export type JuryMaxAggregateOutputType = {
    idJury: number | null
    valideDeliberation: boolean | null
  }

  export type JuryCountAggregateOutputType = {
    idJury: number
    valideDeliberation: number
    _all: number
  }


  export type JuryAvgAggregateInputType = {
    idJury?: true
  }

  export type JurySumAggregateInputType = {
    idJury?: true
  }

  export type JuryMinAggregateInputType = {
    idJury?: true
    valideDeliberation?: true
  }

  export type JuryMaxAggregateInputType = {
    idJury?: true
    valideDeliberation?: true
  }

  export type JuryCountAggregateInputType = {
    idJury?: true
    valideDeliberation?: true
    _all?: true
  }

  export type JuryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jury to aggregate.
     */
    where?: JuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Juries to fetch.
     */
    orderBy?: JuryOrderByWithRelationInput | JuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Juries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Juries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Juries
    **/
    _count?: true | JuryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JuryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JurySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JuryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JuryMaxAggregateInputType
  }

  export type GetJuryAggregateType<T extends JuryAggregateArgs> = {
        [P in keyof T & keyof AggregateJury]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJury[P]>
      : GetScalarType<T[P], AggregateJury[P]>
  }




  export type JuryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JuryWhereInput
    orderBy?: JuryOrderByWithAggregationInput | JuryOrderByWithAggregationInput[]
    by: JuryScalarFieldEnum[] | JuryScalarFieldEnum
    having?: JuryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JuryCountAggregateInputType | true
    _avg?: JuryAvgAggregateInputType
    _sum?: JurySumAggregateInputType
    _min?: JuryMinAggregateInputType
    _max?: JuryMaxAggregateInputType
  }

  export type JuryGroupByOutputType = {
    idJury: number
    valideDeliberation: boolean
    _count: JuryCountAggregateOutputType | null
    _avg: JuryAvgAggregateOutputType | null
    _sum: JurySumAggregateOutputType | null
    _min: JuryMinAggregateOutputType | null
    _max: JuryMaxAggregateOutputType | null
  }

  type GetJuryGroupByPayload<T extends JuryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JuryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JuryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JuryGroupByOutputType[P]>
            : GetScalarType<T[P], JuryGroupByOutputType[P]>
        }
      >
    >


  export type JurySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idJury?: boolean
    valideDeliberation?: boolean
    soutenances?: boolean | Jury$soutenancesArgs<ExtArgs>
    _count?: boolean | JuryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jury"]>



  export type JurySelectScalar = {
    idJury?: boolean
    valideDeliberation?: boolean
  }

  export type JuryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idJury" | "valideDeliberation", ExtArgs["result"]["jury"]>
  export type JuryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soutenances?: boolean | Jury$soutenancesArgs<ExtArgs>
    _count?: boolean | JuryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JuryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jury"
    objects: {
      soutenances: Prisma.$SoutenancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idJury: number
      valideDeliberation: boolean
    }, ExtArgs["result"]["jury"]>
    composites: {}
  }

  type JuryGetPayload<S extends boolean | null | undefined | JuryDefaultArgs> = $Result.GetResult<Prisma.$JuryPayload, S>

  type JuryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JuryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JuryCountAggregateInputType | true
    }

  export interface JuryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jury'], meta: { name: 'Jury' } }
    /**
     * Find zero or one Jury that matches the filter.
     * @param {JuryFindUniqueArgs} args - Arguments to find a Jury
     * @example
     * // Get one Jury
     * const jury = await prisma.jury.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JuryFindUniqueArgs>(args: SelectSubset<T, JuryFindUniqueArgs<ExtArgs>>): Prisma__JuryClient<$Result.GetResult<Prisma.$JuryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Jury that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JuryFindUniqueOrThrowArgs} args - Arguments to find a Jury
     * @example
     * // Get one Jury
     * const jury = await prisma.jury.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JuryFindUniqueOrThrowArgs>(args: SelectSubset<T, JuryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JuryClient<$Result.GetResult<Prisma.$JuryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Jury that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuryFindFirstArgs} args - Arguments to find a Jury
     * @example
     * // Get one Jury
     * const jury = await prisma.jury.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JuryFindFirstArgs>(args?: SelectSubset<T, JuryFindFirstArgs<ExtArgs>>): Prisma__JuryClient<$Result.GetResult<Prisma.$JuryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Jury that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuryFindFirstOrThrowArgs} args - Arguments to find a Jury
     * @example
     * // Get one Jury
     * const jury = await prisma.jury.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JuryFindFirstOrThrowArgs>(args?: SelectSubset<T, JuryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JuryClient<$Result.GetResult<Prisma.$JuryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Juries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Juries
     * const juries = await prisma.jury.findMany()
     * 
     * // Get first 10 Juries
     * const juries = await prisma.jury.findMany({ take: 10 })
     * 
     * // Only select the `idJury`
     * const juryWithIdJuryOnly = await prisma.jury.findMany({ select: { idJury: true } })
     * 
     */
    findMany<T extends JuryFindManyArgs>(args?: SelectSubset<T, JuryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JuryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Jury.
     * @param {JuryCreateArgs} args - Arguments to create a Jury.
     * @example
     * // Create one Jury
     * const Jury = await prisma.jury.create({
     *   data: {
     *     // ... data to create a Jury
     *   }
     * })
     * 
     */
    create<T extends JuryCreateArgs>(args: SelectSubset<T, JuryCreateArgs<ExtArgs>>): Prisma__JuryClient<$Result.GetResult<Prisma.$JuryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Juries.
     * @param {JuryCreateManyArgs} args - Arguments to create many Juries.
     * @example
     * // Create many Juries
     * const jury = await prisma.jury.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JuryCreateManyArgs>(args?: SelectSubset<T, JuryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jury.
     * @param {JuryDeleteArgs} args - Arguments to delete one Jury.
     * @example
     * // Delete one Jury
     * const Jury = await prisma.jury.delete({
     *   where: {
     *     // ... filter to delete one Jury
     *   }
     * })
     * 
     */
    delete<T extends JuryDeleteArgs>(args: SelectSubset<T, JuryDeleteArgs<ExtArgs>>): Prisma__JuryClient<$Result.GetResult<Prisma.$JuryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Jury.
     * @param {JuryUpdateArgs} args - Arguments to update one Jury.
     * @example
     * // Update one Jury
     * const jury = await prisma.jury.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JuryUpdateArgs>(args: SelectSubset<T, JuryUpdateArgs<ExtArgs>>): Prisma__JuryClient<$Result.GetResult<Prisma.$JuryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Juries.
     * @param {JuryDeleteManyArgs} args - Arguments to filter Juries to delete.
     * @example
     * // Delete a few Juries
     * const { count } = await prisma.jury.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JuryDeleteManyArgs>(args?: SelectSubset<T, JuryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Juries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Juries
     * const jury = await prisma.jury.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JuryUpdateManyArgs>(args: SelectSubset<T, JuryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jury.
     * @param {JuryUpsertArgs} args - Arguments to update or create a Jury.
     * @example
     * // Update or create a Jury
     * const jury = await prisma.jury.upsert({
     *   create: {
     *     // ... data to create a Jury
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jury we want to update
     *   }
     * })
     */
    upsert<T extends JuryUpsertArgs>(args: SelectSubset<T, JuryUpsertArgs<ExtArgs>>): Prisma__JuryClient<$Result.GetResult<Prisma.$JuryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Juries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuryCountArgs} args - Arguments to filter Juries to count.
     * @example
     * // Count the number of Juries
     * const count = await prisma.jury.count({
     *   where: {
     *     // ... the filter for the Juries we want to count
     *   }
     * })
    **/
    count<T extends JuryCountArgs>(
      args?: Subset<T, JuryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JuryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JuryAggregateArgs>(args: Subset<T, JuryAggregateArgs>): Prisma.PrismaPromise<GetJuryAggregateType<T>>

    /**
     * Group by Jury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JuryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JuryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JuryGroupByArgs['orderBy'] }
        : { orderBy?: JuryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JuryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJuryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jury model
   */
  readonly fields: JuryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jury.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JuryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    soutenances<T extends Jury$soutenancesArgs<ExtArgs> = {}>(args?: Subset<T, Jury$soutenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jury model
   */ 
  interface JuryFieldRefs {
    readonly idJury: FieldRef<"Jury", 'Int'>
    readonly valideDeliberation: FieldRef<"Jury", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Jury findUnique
   */
  export type JuryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jury
     */
    select?: JurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jury
     */
    omit?: JuryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuryInclude<ExtArgs> | null
    /**
     * Filter, which Jury to fetch.
     */
    where: JuryWhereUniqueInput
  }

  /**
   * Jury findUniqueOrThrow
   */
  export type JuryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jury
     */
    select?: JurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jury
     */
    omit?: JuryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuryInclude<ExtArgs> | null
    /**
     * Filter, which Jury to fetch.
     */
    where: JuryWhereUniqueInput
  }

  /**
   * Jury findFirst
   */
  export type JuryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jury
     */
    select?: JurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jury
     */
    omit?: JuryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuryInclude<ExtArgs> | null
    /**
     * Filter, which Jury to fetch.
     */
    where?: JuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Juries to fetch.
     */
    orderBy?: JuryOrderByWithRelationInput | JuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Juries.
     */
    cursor?: JuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Juries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Juries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Juries.
     */
    distinct?: JuryScalarFieldEnum | JuryScalarFieldEnum[]
  }

  /**
   * Jury findFirstOrThrow
   */
  export type JuryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jury
     */
    select?: JurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jury
     */
    omit?: JuryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuryInclude<ExtArgs> | null
    /**
     * Filter, which Jury to fetch.
     */
    where?: JuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Juries to fetch.
     */
    orderBy?: JuryOrderByWithRelationInput | JuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Juries.
     */
    cursor?: JuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Juries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Juries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Juries.
     */
    distinct?: JuryScalarFieldEnum | JuryScalarFieldEnum[]
  }

  /**
   * Jury findMany
   */
  export type JuryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jury
     */
    select?: JurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jury
     */
    omit?: JuryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuryInclude<ExtArgs> | null
    /**
     * Filter, which Juries to fetch.
     */
    where?: JuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Juries to fetch.
     */
    orderBy?: JuryOrderByWithRelationInput | JuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Juries.
     */
    cursor?: JuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Juries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Juries.
     */
    skip?: number
    distinct?: JuryScalarFieldEnum | JuryScalarFieldEnum[]
  }

  /**
   * Jury create
   */
  export type JuryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jury
     */
    select?: JurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jury
     */
    omit?: JuryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuryInclude<ExtArgs> | null
    /**
     * The data needed to create a Jury.
     */
    data: XOR<JuryCreateInput, JuryUncheckedCreateInput>
  }

  /**
   * Jury createMany
   */
  export type JuryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Juries.
     */
    data: JuryCreateManyInput | JuryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jury update
   */
  export type JuryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jury
     */
    select?: JurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jury
     */
    omit?: JuryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuryInclude<ExtArgs> | null
    /**
     * The data needed to update a Jury.
     */
    data: XOR<JuryUpdateInput, JuryUncheckedUpdateInput>
    /**
     * Choose, which Jury to update.
     */
    where: JuryWhereUniqueInput
  }

  /**
   * Jury updateMany
   */
  export type JuryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Juries.
     */
    data: XOR<JuryUpdateManyMutationInput, JuryUncheckedUpdateManyInput>
    /**
     * Filter which Juries to update
     */
    where?: JuryWhereInput
    /**
     * Limit how many Juries to update.
     */
    limit?: number
  }

  /**
   * Jury upsert
   */
  export type JuryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jury
     */
    select?: JurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jury
     */
    omit?: JuryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuryInclude<ExtArgs> | null
    /**
     * The filter to search for the Jury to update in case it exists.
     */
    where: JuryWhereUniqueInput
    /**
     * In case the Jury found by the `where` argument doesn't exist, create a new Jury with this data.
     */
    create: XOR<JuryCreateInput, JuryUncheckedCreateInput>
    /**
     * In case the Jury was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JuryUpdateInput, JuryUncheckedUpdateInput>
  }

  /**
   * Jury delete
   */
  export type JuryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jury
     */
    select?: JurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jury
     */
    omit?: JuryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuryInclude<ExtArgs> | null
    /**
     * Filter which Jury to delete.
     */
    where: JuryWhereUniqueInput
  }

  /**
   * Jury deleteMany
   */
  export type JuryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Juries to delete
     */
    where?: JuryWhereInput
    /**
     * Limit how many Juries to delete.
     */
    limit?: number
  }

  /**
   * Jury.soutenances
   */
  export type Jury$soutenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
    where?: SoutenanceWhereInput
    orderBy?: SoutenanceOrderByWithRelationInput | SoutenanceOrderByWithRelationInput[]
    cursor?: SoutenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoutenanceScalarFieldEnum | SoutenanceScalarFieldEnum[]
  }

  /**
   * Jury without action
   */
  export type JuryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jury
     */
    select?: JurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jury
     */
    omit?: JuryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JuryInclude<ExtArgs> | null
  }


  /**
   * Model Soutenance
   */

  export type AggregateSoutenance = {
    _count: SoutenanceCountAggregateOutputType | null
    _avg: SoutenanceAvgAggregateOutputType | null
    _sum: SoutenanceSumAggregateOutputType | null
    _min: SoutenanceMinAggregateOutputType | null
    _max: SoutenanceMaxAggregateOutputType | null
  }

  export type SoutenanceAvgAggregateOutputType = {
    idSoutenance: number | null
    idJury: number | null
  }

  export type SoutenanceSumAggregateOutputType = {
    idSoutenance: number | null
    idJury: number | null
  }

  export type SoutenanceMinAggregateOutputType = {
    idSoutenance: number | null
    date: Date | null
    heure: Date | null
    idJury: number | null
  }

  export type SoutenanceMaxAggregateOutputType = {
    idSoutenance: number | null
    date: Date | null
    heure: Date | null
    idJury: number | null
  }

  export type SoutenanceCountAggregateOutputType = {
    idSoutenance: number
    date: number
    heure: number
    idJury: number
    _all: number
  }


  export type SoutenanceAvgAggregateInputType = {
    idSoutenance?: true
    idJury?: true
  }

  export type SoutenanceSumAggregateInputType = {
    idSoutenance?: true
    idJury?: true
  }

  export type SoutenanceMinAggregateInputType = {
    idSoutenance?: true
    date?: true
    heure?: true
    idJury?: true
  }

  export type SoutenanceMaxAggregateInputType = {
    idSoutenance?: true
    date?: true
    heure?: true
    idJury?: true
  }

  export type SoutenanceCountAggregateInputType = {
    idSoutenance?: true
    date?: true
    heure?: true
    idJury?: true
    _all?: true
  }

  export type SoutenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Soutenance to aggregate.
     */
    where?: SoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Soutenances to fetch.
     */
    orderBy?: SoutenanceOrderByWithRelationInput | SoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Soutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Soutenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Soutenances
    **/
    _count?: true | SoutenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoutenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoutenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoutenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoutenanceMaxAggregateInputType
  }

  export type GetSoutenanceAggregateType<T extends SoutenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateSoutenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoutenance[P]>
      : GetScalarType<T[P], AggregateSoutenance[P]>
  }




  export type SoutenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoutenanceWhereInput
    orderBy?: SoutenanceOrderByWithAggregationInput | SoutenanceOrderByWithAggregationInput[]
    by: SoutenanceScalarFieldEnum[] | SoutenanceScalarFieldEnum
    having?: SoutenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoutenanceCountAggregateInputType | true
    _avg?: SoutenanceAvgAggregateInputType
    _sum?: SoutenanceSumAggregateInputType
    _min?: SoutenanceMinAggregateInputType
    _max?: SoutenanceMaxAggregateInputType
  }

  export type SoutenanceGroupByOutputType = {
    idSoutenance: number
    date: Date
    heure: Date
    idJury: number
    _count: SoutenanceCountAggregateOutputType | null
    _avg: SoutenanceAvgAggregateOutputType | null
    _sum: SoutenanceSumAggregateOutputType | null
    _min: SoutenanceMinAggregateOutputType | null
    _max: SoutenanceMaxAggregateOutputType | null
  }

  type GetSoutenanceGroupByPayload<T extends SoutenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoutenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoutenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoutenanceGroupByOutputType[P]>
            : GetScalarType<T[P], SoutenanceGroupByOutputType[P]>
        }
      >
    >


  export type SoutenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSoutenance?: boolean
    date?: boolean
    heure?: boolean
    idJury?: boolean
    jury?: boolean | JuryDefaultArgs<ExtArgs>
    encadrants?: boolean | Soutenance$encadrantsArgs<ExtArgs>
    evaluations?: boolean | Soutenance$evaluationsArgs<ExtArgs>
    _count?: boolean | SoutenanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soutenance"]>



  export type SoutenanceSelectScalar = {
    idSoutenance?: boolean
    date?: boolean
    heure?: boolean
    idJury?: boolean
  }

  export type SoutenanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idSoutenance" | "date" | "heure" | "idJury", ExtArgs["result"]["soutenance"]>
  export type SoutenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jury?: boolean | JuryDefaultArgs<ExtArgs>
    encadrants?: boolean | Soutenance$encadrantsArgs<ExtArgs>
    evaluations?: boolean | Soutenance$evaluationsArgs<ExtArgs>
    _count?: boolean | SoutenanceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SoutenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Soutenance"
    objects: {
      jury: Prisma.$JuryPayload<ExtArgs>
      encadrants: Prisma.$EncadrantSoutenancePayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idSoutenance: number
      date: Date
      heure: Date
      idJury: number
    }, ExtArgs["result"]["soutenance"]>
    composites: {}
  }

  type SoutenanceGetPayload<S extends boolean | null | undefined | SoutenanceDefaultArgs> = $Result.GetResult<Prisma.$SoutenancePayload, S>

  type SoutenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SoutenanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SoutenanceCountAggregateInputType | true
    }

  export interface SoutenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Soutenance'], meta: { name: 'Soutenance' } }
    /**
     * Find zero or one Soutenance that matches the filter.
     * @param {SoutenanceFindUniqueArgs} args - Arguments to find a Soutenance
     * @example
     * // Get one Soutenance
     * const soutenance = await prisma.soutenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SoutenanceFindUniqueArgs>(args: SelectSubset<T, SoutenanceFindUniqueArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Soutenance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SoutenanceFindUniqueOrThrowArgs} args - Arguments to find a Soutenance
     * @example
     * // Get one Soutenance
     * const soutenance = await prisma.soutenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SoutenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, SoutenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Soutenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceFindFirstArgs} args - Arguments to find a Soutenance
     * @example
     * // Get one Soutenance
     * const soutenance = await prisma.soutenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SoutenanceFindFirstArgs>(args?: SelectSubset<T, SoutenanceFindFirstArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Soutenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceFindFirstOrThrowArgs} args - Arguments to find a Soutenance
     * @example
     * // Get one Soutenance
     * const soutenance = await prisma.soutenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SoutenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, SoutenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Soutenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Soutenances
     * const soutenances = await prisma.soutenance.findMany()
     * 
     * // Get first 10 Soutenances
     * const soutenances = await prisma.soutenance.findMany({ take: 10 })
     * 
     * // Only select the `idSoutenance`
     * const soutenanceWithIdSoutenanceOnly = await prisma.soutenance.findMany({ select: { idSoutenance: true } })
     * 
     */
    findMany<T extends SoutenanceFindManyArgs>(args?: SelectSubset<T, SoutenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Soutenance.
     * @param {SoutenanceCreateArgs} args - Arguments to create a Soutenance.
     * @example
     * // Create one Soutenance
     * const Soutenance = await prisma.soutenance.create({
     *   data: {
     *     // ... data to create a Soutenance
     *   }
     * })
     * 
     */
    create<T extends SoutenanceCreateArgs>(args: SelectSubset<T, SoutenanceCreateArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Soutenances.
     * @param {SoutenanceCreateManyArgs} args - Arguments to create many Soutenances.
     * @example
     * // Create many Soutenances
     * const soutenance = await prisma.soutenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SoutenanceCreateManyArgs>(args?: SelectSubset<T, SoutenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Soutenance.
     * @param {SoutenanceDeleteArgs} args - Arguments to delete one Soutenance.
     * @example
     * // Delete one Soutenance
     * const Soutenance = await prisma.soutenance.delete({
     *   where: {
     *     // ... filter to delete one Soutenance
     *   }
     * })
     * 
     */
    delete<T extends SoutenanceDeleteArgs>(args: SelectSubset<T, SoutenanceDeleteArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Soutenance.
     * @param {SoutenanceUpdateArgs} args - Arguments to update one Soutenance.
     * @example
     * // Update one Soutenance
     * const soutenance = await prisma.soutenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SoutenanceUpdateArgs>(args: SelectSubset<T, SoutenanceUpdateArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Soutenances.
     * @param {SoutenanceDeleteManyArgs} args - Arguments to filter Soutenances to delete.
     * @example
     * // Delete a few Soutenances
     * const { count } = await prisma.soutenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SoutenanceDeleteManyArgs>(args?: SelectSubset<T, SoutenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Soutenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Soutenances
     * const soutenance = await prisma.soutenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SoutenanceUpdateManyArgs>(args: SelectSubset<T, SoutenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Soutenance.
     * @param {SoutenanceUpsertArgs} args - Arguments to update or create a Soutenance.
     * @example
     * // Update or create a Soutenance
     * const soutenance = await prisma.soutenance.upsert({
     *   create: {
     *     // ... data to create a Soutenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Soutenance we want to update
     *   }
     * })
     */
    upsert<T extends SoutenanceUpsertArgs>(args: SelectSubset<T, SoutenanceUpsertArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Soutenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceCountArgs} args - Arguments to filter Soutenances to count.
     * @example
     * // Count the number of Soutenances
     * const count = await prisma.soutenance.count({
     *   where: {
     *     // ... the filter for the Soutenances we want to count
     *   }
     * })
    **/
    count<T extends SoutenanceCountArgs>(
      args?: Subset<T, SoutenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoutenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Soutenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoutenanceAggregateArgs>(args: Subset<T, SoutenanceAggregateArgs>): Prisma.PrismaPromise<GetSoutenanceAggregateType<T>>

    /**
     * Group by Soutenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoutenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoutenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoutenanceGroupByArgs['orderBy'] }
        : { orderBy?: SoutenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoutenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoutenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Soutenance model
   */
  readonly fields: SoutenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Soutenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoutenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jury<T extends JuryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JuryDefaultArgs<ExtArgs>>): Prisma__JuryClient<$Result.GetResult<Prisma.$JuryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    encadrants<T extends Soutenance$encadrantsArgs<ExtArgs> = {}>(args?: Subset<T, Soutenance$encadrantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    evaluations<T extends Soutenance$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Soutenance$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Soutenance model
   */ 
  interface SoutenanceFieldRefs {
    readonly idSoutenance: FieldRef<"Soutenance", 'Int'>
    readonly date: FieldRef<"Soutenance", 'DateTime'>
    readonly heure: FieldRef<"Soutenance", 'DateTime'>
    readonly idJury: FieldRef<"Soutenance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Soutenance findUnique
   */
  export type SoutenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which Soutenance to fetch.
     */
    where: SoutenanceWhereUniqueInput
  }

  /**
   * Soutenance findUniqueOrThrow
   */
  export type SoutenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which Soutenance to fetch.
     */
    where: SoutenanceWhereUniqueInput
  }

  /**
   * Soutenance findFirst
   */
  export type SoutenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which Soutenance to fetch.
     */
    where?: SoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Soutenances to fetch.
     */
    orderBy?: SoutenanceOrderByWithRelationInput | SoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Soutenances.
     */
    cursor?: SoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Soutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Soutenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Soutenances.
     */
    distinct?: SoutenanceScalarFieldEnum | SoutenanceScalarFieldEnum[]
  }

  /**
   * Soutenance findFirstOrThrow
   */
  export type SoutenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which Soutenance to fetch.
     */
    where?: SoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Soutenances to fetch.
     */
    orderBy?: SoutenanceOrderByWithRelationInput | SoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Soutenances.
     */
    cursor?: SoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Soutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Soutenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Soutenances.
     */
    distinct?: SoutenanceScalarFieldEnum | SoutenanceScalarFieldEnum[]
  }

  /**
   * Soutenance findMany
   */
  export type SoutenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which Soutenances to fetch.
     */
    where?: SoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Soutenances to fetch.
     */
    orderBy?: SoutenanceOrderByWithRelationInput | SoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Soutenances.
     */
    cursor?: SoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Soutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Soutenances.
     */
    skip?: number
    distinct?: SoutenanceScalarFieldEnum | SoutenanceScalarFieldEnum[]
  }

  /**
   * Soutenance create
   */
  export type SoutenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Soutenance.
     */
    data: XOR<SoutenanceCreateInput, SoutenanceUncheckedCreateInput>
  }

  /**
   * Soutenance createMany
   */
  export type SoutenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Soutenances.
     */
    data: SoutenanceCreateManyInput | SoutenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Soutenance update
   */
  export type SoutenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Soutenance.
     */
    data: XOR<SoutenanceUpdateInput, SoutenanceUncheckedUpdateInput>
    /**
     * Choose, which Soutenance to update.
     */
    where: SoutenanceWhereUniqueInput
  }

  /**
   * Soutenance updateMany
   */
  export type SoutenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Soutenances.
     */
    data: XOR<SoutenanceUpdateManyMutationInput, SoutenanceUncheckedUpdateManyInput>
    /**
     * Filter which Soutenances to update
     */
    where?: SoutenanceWhereInput
    /**
     * Limit how many Soutenances to update.
     */
    limit?: number
  }

  /**
   * Soutenance upsert
   */
  export type SoutenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Soutenance to update in case it exists.
     */
    where: SoutenanceWhereUniqueInput
    /**
     * In case the Soutenance found by the `where` argument doesn't exist, create a new Soutenance with this data.
     */
    create: XOR<SoutenanceCreateInput, SoutenanceUncheckedCreateInput>
    /**
     * In case the Soutenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoutenanceUpdateInput, SoutenanceUncheckedUpdateInput>
  }

  /**
   * Soutenance delete
   */
  export type SoutenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
    /**
     * Filter which Soutenance to delete.
     */
    where: SoutenanceWhereUniqueInput
  }

  /**
   * Soutenance deleteMany
   */
  export type SoutenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Soutenances to delete
     */
    where?: SoutenanceWhereInput
    /**
     * Limit how many Soutenances to delete.
     */
    limit?: number
  }

  /**
   * Soutenance.encadrants
   */
  export type Soutenance$encadrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    where?: EncadrantSoutenanceWhereInput
    orderBy?: EncadrantSoutenanceOrderByWithRelationInput | EncadrantSoutenanceOrderByWithRelationInput[]
    cursor?: EncadrantSoutenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncadrantSoutenanceScalarFieldEnum | EncadrantSoutenanceScalarFieldEnum[]
  }

  /**
   * Soutenance.evaluations
   */
  export type Soutenance$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Soutenance without action
   */
  export type SoutenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Soutenance
     */
    select?: SoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Soutenance
     */
    omit?: SoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoutenanceInclude<ExtArgs> | null
  }


  /**
   * Model Evaluation
   */

  export type AggregateEvaluation = {
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  export type EvaluationAvgAggregateOutputType = {
    idEvaluation: number | null
    note: number | null
    idSoutenance: number | null
    idEtudiant: number | null
  }

  export type EvaluationSumAggregateOutputType = {
    idEvaluation: number | null
    note: number | null
    idSoutenance: number | null
    idEtudiant: number | null
  }

  export type EvaluationMinAggregateOutputType = {
    idEvaluation: number | null
    note: number | null
    feedback: string | null
    idSoutenance: number | null
    idEtudiant: number | null
  }

  export type EvaluationMaxAggregateOutputType = {
    idEvaluation: number | null
    note: number | null
    feedback: string | null
    idSoutenance: number | null
    idEtudiant: number | null
  }

  export type EvaluationCountAggregateOutputType = {
    idEvaluation: number
    note: number
    feedback: number
    idSoutenance: number
    idEtudiant: number
    _all: number
  }


  export type EvaluationAvgAggregateInputType = {
    idEvaluation?: true
    note?: true
    idSoutenance?: true
    idEtudiant?: true
  }

  export type EvaluationSumAggregateInputType = {
    idEvaluation?: true
    note?: true
    idSoutenance?: true
    idEtudiant?: true
  }

  export type EvaluationMinAggregateInputType = {
    idEvaluation?: true
    note?: true
    feedback?: true
    idSoutenance?: true
    idEtudiant?: true
  }

  export type EvaluationMaxAggregateInputType = {
    idEvaluation?: true
    note?: true
    feedback?: true
    idSoutenance?: true
    idEtudiant?: true
  }

  export type EvaluationCountAggregateInputType = {
    idEvaluation?: true
    note?: true
    feedback?: true
    idSoutenance?: true
    idEtudiant?: true
    _all?: true
  }

  export type EvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluation to aggregate.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluations
    **/
    _count?: true | EvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationMaxAggregateInputType
  }

  export type GetEvaluationAggregateType<T extends EvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluation[P]>
      : GetScalarType<T[P], AggregateEvaluation[P]>
  }




  export type EvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithAggregationInput | EvaluationOrderByWithAggregationInput[]
    by: EvaluationScalarFieldEnum[] | EvaluationScalarFieldEnum
    having?: EvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationCountAggregateInputType | true
    _avg?: EvaluationAvgAggregateInputType
    _sum?: EvaluationSumAggregateInputType
    _min?: EvaluationMinAggregateInputType
    _max?: EvaluationMaxAggregateInputType
  }

  export type EvaluationGroupByOutputType = {
    idEvaluation: number
    note: number
    feedback: string | null
    idSoutenance: number
    idEtudiant: number
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  type GetEvaluationGroupByPayload<T extends EvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEvaluation?: boolean
    note?: boolean
    feedback?: boolean
    idSoutenance?: boolean
    idEtudiant?: boolean
    soutenance?: boolean | SoutenanceDefaultArgs<ExtArgs>
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>



  export type EvaluationSelectScalar = {
    idEvaluation?: boolean
    note?: boolean
    feedback?: boolean
    idSoutenance?: boolean
    idEtudiant?: boolean
  }

  export type EvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idEvaluation" | "note" | "feedback" | "idSoutenance" | "idEtudiant", ExtArgs["result"]["evaluation"]>
  export type EvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    soutenance?: boolean | SoutenanceDefaultArgs<ExtArgs>
    etudiant?: boolean | EtudiantDefaultArgs<ExtArgs>
  }

  export type $EvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evaluation"
    objects: {
      soutenance: Prisma.$SoutenancePayload<ExtArgs>
      etudiant: Prisma.$EtudiantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idEvaluation: number
      note: number
      feedback: string | null
      idSoutenance: number
      idEtudiant: number
    }, ExtArgs["result"]["evaluation"]>
    composites: {}
  }

  type EvaluationGetPayload<S extends boolean | null | undefined | EvaluationDefaultArgs> = $Result.GetResult<Prisma.$EvaluationPayload, S>

  type EvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvaluationCountAggregateInputType | true
    }

  export interface EvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluation'], meta: { name: 'Evaluation' } }
    /**
     * Find zero or one Evaluation that matches the filter.
     * @param {EvaluationFindUniqueArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationFindUniqueArgs>(args: SelectSubset<T, EvaluationFindUniqueArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Evaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvaluationFindUniqueOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Evaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationFindFirstArgs>(args?: SelectSubset<T, EvaluationFindFirstArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Evaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluations
     * const evaluations = await prisma.evaluation.findMany()
     * 
     * // Get first 10 Evaluations
     * const evaluations = await prisma.evaluation.findMany({ take: 10 })
     * 
     * // Only select the `idEvaluation`
     * const evaluationWithIdEvaluationOnly = await prisma.evaluation.findMany({ select: { idEvaluation: true } })
     * 
     */
    findMany<T extends EvaluationFindManyArgs>(args?: SelectSubset<T, EvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Evaluation.
     * @param {EvaluationCreateArgs} args - Arguments to create a Evaluation.
     * @example
     * // Create one Evaluation
     * const Evaluation = await prisma.evaluation.create({
     *   data: {
     *     // ... data to create a Evaluation
     *   }
     * })
     * 
     */
    create<T extends EvaluationCreateArgs>(args: SelectSubset<T, EvaluationCreateArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Evaluations.
     * @param {EvaluationCreateManyArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationCreateManyArgs>(args?: SelectSubset<T, EvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evaluation.
     * @param {EvaluationDeleteArgs} args - Arguments to delete one Evaluation.
     * @example
     * // Delete one Evaluation
     * const Evaluation = await prisma.evaluation.delete({
     *   where: {
     *     // ... filter to delete one Evaluation
     *   }
     * })
     * 
     */
    delete<T extends EvaluationDeleteArgs>(args: SelectSubset<T, EvaluationDeleteArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Evaluation.
     * @param {EvaluationUpdateArgs} args - Arguments to update one Evaluation.
     * @example
     * // Update one Evaluation
     * const evaluation = await prisma.evaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationUpdateArgs>(args: SelectSubset<T, EvaluationUpdateArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Evaluations.
     * @param {EvaluationDeleteManyArgs} args - Arguments to filter Evaluations to delete.
     * @example
     * // Delete a few Evaluations
     * const { count } = await prisma.evaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationDeleteManyArgs>(args?: SelectSubset<T, EvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationUpdateManyArgs>(args: SelectSubset<T, EvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evaluation.
     * @param {EvaluationUpsertArgs} args - Arguments to update or create a Evaluation.
     * @example
     * // Update or create a Evaluation
     * const evaluation = await prisma.evaluation.upsert({
     *   create: {
     *     // ... data to create a Evaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluation we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationUpsertArgs>(args: SelectSubset<T, EvaluationUpsertArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationCountArgs} args - Arguments to filter Evaluations to count.
     * @example
     * // Count the number of Evaluations
     * const count = await prisma.evaluation.count({
     *   where: {
     *     // ... the filter for the Evaluations we want to count
     *   }
     * })
    **/
    count<T extends EvaluationCountArgs>(
      args?: Subset<T, EvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationAggregateArgs>(args: Subset<T, EvaluationAggregateArgs>): Prisma.PrismaPromise<GetEvaluationAggregateType<T>>

    /**
     * Group by Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evaluation model
   */
  readonly fields: EvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    soutenance<T extends SoutenanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SoutenanceDefaultArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    etudiant<T extends EtudiantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EtudiantDefaultArgs<ExtArgs>>): Prisma__EtudiantClient<$Result.GetResult<Prisma.$EtudiantPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evaluation model
   */ 
  interface EvaluationFieldRefs {
    readonly idEvaluation: FieldRef<"Evaluation", 'Int'>
    readonly note: FieldRef<"Evaluation", 'Float'>
    readonly feedback: FieldRef<"Evaluation", 'String'>
    readonly idSoutenance: FieldRef<"Evaluation", 'Int'>
    readonly idEtudiant: FieldRef<"Evaluation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Evaluation findUnique
   */
  export type EvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findUniqueOrThrow
   */
  export type EvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findFirst
   */
  export type EvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findFirstOrThrow
   */
  export type EvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findMany
   */
  export type EvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluations to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation create
   */
  export type EvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluation.
     */
    data: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
  }

  /**
   * Evaluation createMany
   */
  export type EvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evaluation update
   */
  export type EvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluation.
     */
    data: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
    /**
     * Choose, which Evaluation to update.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation updateMany
   */
  export type EvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
    /**
     * Limit how many Evaluations to update.
     */
    limit?: number
  }

  /**
   * Evaluation upsert
   */
  export type EvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluation to update in case it exists.
     */
    where: EvaluationWhereUniqueInput
    /**
     * In case the Evaluation found by the `where` argument doesn't exist, create a new Evaluation with this data.
     */
    create: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
    /**
     * In case the Evaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
  }

  /**
   * Evaluation delete
   */
  export type EvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter which Evaluation to delete.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation deleteMany
   */
  export type EvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluations to delete
     */
    where?: EvaluationWhereInput
    /**
     * Limit how many Evaluations to delete.
     */
    limit?: number
  }

  /**
   * Evaluation without action
   */
  export type EvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
  }


  /**
   * Model Livrable
   */

  export type AggregateLivrable = {
    _count: LivrableCountAggregateOutputType | null
    _avg: LivrableAvgAggregateOutputType | null
    _sum: LivrableSumAggregateOutputType | null
    _min: LivrableMinAggregateOutputType | null
    _max: LivrableMaxAggregateOutputType | null
  }

  export type LivrableAvgAggregateOutputType = {
    idLivrable: number | null
    annee: number | null
  }

  export type LivrableSumAggregateOutputType = {
    idLivrable: number | null
    annee: number | null
  }

  export type LivrableMinAggregateOutputType = {
    idLivrable: number | null
    type: string | null
    nom: string | null
    annee: number | null
  }

  export type LivrableMaxAggregateOutputType = {
    idLivrable: number | null
    type: string | null
    nom: string | null
    annee: number | null
  }

  export type LivrableCountAggregateOutputType = {
    idLivrable: number
    type: number
    nom: number
    annee: number
    _all: number
  }


  export type LivrableAvgAggregateInputType = {
    idLivrable?: true
    annee?: true
  }

  export type LivrableSumAggregateInputType = {
    idLivrable?: true
    annee?: true
  }

  export type LivrableMinAggregateInputType = {
    idLivrable?: true
    type?: true
    nom?: true
    annee?: true
  }

  export type LivrableMaxAggregateInputType = {
    idLivrable?: true
    type?: true
    nom?: true
    annee?: true
  }

  export type LivrableCountAggregateInputType = {
    idLivrable?: true
    type?: true
    nom?: true
    annee?: true
    _all?: true
  }

  export type LivrableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Livrable to aggregate.
     */
    where?: LivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livrables to fetch.
     */
    orderBy?: LivrableOrderByWithRelationInput | LivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Livrables
    **/
    _count?: true | LivrableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LivrableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LivrableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LivrableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LivrableMaxAggregateInputType
  }

  export type GetLivrableAggregateType<T extends LivrableAggregateArgs> = {
        [P in keyof T & keyof AggregateLivrable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLivrable[P]>
      : GetScalarType<T[P], AggregateLivrable[P]>
  }




  export type LivrableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivrableWhereInput
    orderBy?: LivrableOrderByWithAggregationInput | LivrableOrderByWithAggregationInput[]
    by: LivrableScalarFieldEnum[] | LivrableScalarFieldEnum
    having?: LivrableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LivrableCountAggregateInputType | true
    _avg?: LivrableAvgAggregateInputType
    _sum?: LivrableSumAggregateInputType
    _min?: LivrableMinAggregateInputType
    _max?: LivrableMaxAggregateInputType
  }

  export type LivrableGroupByOutputType = {
    idLivrable: number
    type: string
    nom: string
    annee: number
    _count: LivrableCountAggregateOutputType | null
    _avg: LivrableAvgAggregateOutputType | null
    _sum: LivrableSumAggregateOutputType | null
    _min: LivrableMinAggregateOutputType | null
    _max: LivrableMaxAggregateOutputType | null
  }

  type GetLivrableGroupByPayload<T extends LivrableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LivrableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LivrableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LivrableGroupByOutputType[P]>
            : GetScalarType<T[P], LivrableGroupByOutputType[P]>
        }
      >
    >


  export type LivrableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idLivrable?: boolean
    type?: boolean
    nom?: boolean
    annee?: boolean
    PFEs?: boolean | Livrable$PFEsArgs<ExtArgs>
    encadrants?: boolean | Livrable$encadrantsArgs<ExtArgs>
    tuteurs?: boolean | Livrable$tuteursArgs<ExtArgs>
    _count?: boolean | LivrableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livrable"]>



  export type LivrableSelectScalar = {
    idLivrable?: boolean
    type?: boolean
    nom?: boolean
    annee?: boolean
  }

  export type LivrableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idLivrable" | "type" | "nom" | "annee", ExtArgs["result"]["livrable"]>
  export type LivrableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PFEs?: boolean | Livrable$PFEsArgs<ExtArgs>
    encadrants?: boolean | Livrable$encadrantsArgs<ExtArgs>
    tuteurs?: boolean | Livrable$tuteursArgs<ExtArgs>
    _count?: boolean | LivrableCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LivrablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Livrable"
    objects: {
      PFEs: Prisma.$PFE_LivrablePayload<ExtArgs>[]
      encadrants: Prisma.$EncadrantLivrablePayload<ExtArgs>[]
      tuteurs: Prisma.$TuteurLivrablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idLivrable: number
      type: string
      nom: string
      annee: number
    }, ExtArgs["result"]["livrable"]>
    composites: {}
  }

  type LivrableGetPayload<S extends boolean | null | undefined | LivrableDefaultArgs> = $Result.GetResult<Prisma.$LivrablePayload, S>

  type LivrableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LivrableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LivrableCountAggregateInputType | true
    }

  export interface LivrableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Livrable'], meta: { name: 'Livrable' } }
    /**
     * Find zero or one Livrable that matches the filter.
     * @param {LivrableFindUniqueArgs} args - Arguments to find a Livrable
     * @example
     * // Get one Livrable
     * const livrable = await prisma.livrable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LivrableFindUniqueArgs>(args: SelectSubset<T, LivrableFindUniqueArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Livrable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LivrableFindUniqueOrThrowArgs} args - Arguments to find a Livrable
     * @example
     * // Get one Livrable
     * const livrable = await prisma.livrable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LivrableFindUniqueOrThrowArgs>(args: SelectSubset<T, LivrableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Livrable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivrableFindFirstArgs} args - Arguments to find a Livrable
     * @example
     * // Get one Livrable
     * const livrable = await prisma.livrable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LivrableFindFirstArgs>(args?: SelectSubset<T, LivrableFindFirstArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Livrable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivrableFindFirstOrThrowArgs} args - Arguments to find a Livrable
     * @example
     * // Get one Livrable
     * const livrable = await prisma.livrable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LivrableFindFirstOrThrowArgs>(args?: SelectSubset<T, LivrableFindFirstOrThrowArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Livrables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivrableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Livrables
     * const livrables = await prisma.livrable.findMany()
     * 
     * // Get first 10 Livrables
     * const livrables = await prisma.livrable.findMany({ take: 10 })
     * 
     * // Only select the `idLivrable`
     * const livrableWithIdLivrableOnly = await prisma.livrable.findMany({ select: { idLivrable: true } })
     * 
     */
    findMany<T extends LivrableFindManyArgs>(args?: SelectSubset<T, LivrableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Livrable.
     * @param {LivrableCreateArgs} args - Arguments to create a Livrable.
     * @example
     * // Create one Livrable
     * const Livrable = await prisma.livrable.create({
     *   data: {
     *     // ... data to create a Livrable
     *   }
     * })
     * 
     */
    create<T extends LivrableCreateArgs>(args: SelectSubset<T, LivrableCreateArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Livrables.
     * @param {LivrableCreateManyArgs} args - Arguments to create many Livrables.
     * @example
     * // Create many Livrables
     * const livrable = await prisma.livrable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LivrableCreateManyArgs>(args?: SelectSubset<T, LivrableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Livrable.
     * @param {LivrableDeleteArgs} args - Arguments to delete one Livrable.
     * @example
     * // Delete one Livrable
     * const Livrable = await prisma.livrable.delete({
     *   where: {
     *     // ... filter to delete one Livrable
     *   }
     * })
     * 
     */
    delete<T extends LivrableDeleteArgs>(args: SelectSubset<T, LivrableDeleteArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Livrable.
     * @param {LivrableUpdateArgs} args - Arguments to update one Livrable.
     * @example
     * // Update one Livrable
     * const livrable = await prisma.livrable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LivrableUpdateArgs>(args: SelectSubset<T, LivrableUpdateArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Livrables.
     * @param {LivrableDeleteManyArgs} args - Arguments to filter Livrables to delete.
     * @example
     * // Delete a few Livrables
     * const { count } = await prisma.livrable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LivrableDeleteManyArgs>(args?: SelectSubset<T, LivrableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Livrables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivrableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Livrables
     * const livrable = await prisma.livrable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LivrableUpdateManyArgs>(args: SelectSubset<T, LivrableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Livrable.
     * @param {LivrableUpsertArgs} args - Arguments to update or create a Livrable.
     * @example
     * // Update or create a Livrable
     * const livrable = await prisma.livrable.upsert({
     *   create: {
     *     // ... data to create a Livrable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Livrable we want to update
     *   }
     * })
     */
    upsert<T extends LivrableUpsertArgs>(args: SelectSubset<T, LivrableUpsertArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Livrables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivrableCountArgs} args - Arguments to filter Livrables to count.
     * @example
     * // Count the number of Livrables
     * const count = await prisma.livrable.count({
     *   where: {
     *     // ... the filter for the Livrables we want to count
     *   }
     * })
    **/
    count<T extends LivrableCountArgs>(
      args?: Subset<T, LivrableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LivrableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Livrable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivrableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LivrableAggregateArgs>(args: Subset<T, LivrableAggregateArgs>): Prisma.PrismaPromise<GetLivrableAggregateType<T>>

    /**
     * Group by Livrable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivrableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LivrableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LivrableGroupByArgs['orderBy'] }
        : { orderBy?: LivrableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LivrableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLivrableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Livrable model
   */
  readonly fields: LivrableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Livrable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LivrableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PFEs<T extends Livrable$PFEsArgs<ExtArgs> = {}>(args?: Subset<T, Livrable$PFEsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    encadrants<T extends Livrable$encadrantsArgs<ExtArgs> = {}>(args?: Subset<T, Livrable$encadrantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tuteurs<T extends Livrable$tuteursArgs<ExtArgs> = {}>(args?: Subset<T, Livrable$tuteursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Livrable model
   */ 
  interface LivrableFieldRefs {
    readonly idLivrable: FieldRef<"Livrable", 'Int'>
    readonly type: FieldRef<"Livrable", 'String'>
    readonly nom: FieldRef<"Livrable", 'String'>
    readonly annee: FieldRef<"Livrable", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Livrable findUnique
   */
  export type LivrableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livrable
     */
    select?: LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livrable
     */
    omit?: LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivrableInclude<ExtArgs> | null
    /**
     * Filter, which Livrable to fetch.
     */
    where: LivrableWhereUniqueInput
  }

  /**
   * Livrable findUniqueOrThrow
   */
  export type LivrableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livrable
     */
    select?: LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livrable
     */
    omit?: LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivrableInclude<ExtArgs> | null
    /**
     * Filter, which Livrable to fetch.
     */
    where: LivrableWhereUniqueInput
  }

  /**
   * Livrable findFirst
   */
  export type LivrableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livrable
     */
    select?: LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livrable
     */
    omit?: LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivrableInclude<ExtArgs> | null
    /**
     * Filter, which Livrable to fetch.
     */
    where?: LivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livrables to fetch.
     */
    orderBy?: LivrableOrderByWithRelationInput | LivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Livrables.
     */
    cursor?: LivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Livrables.
     */
    distinct?: LivrableScalarFieldEnum | LivrableScalarFieldEnum[]
  }

  /**
   * Livrable findFirstOrThrow
   */
  export type LivrableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livrable
     */
    select?: LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livrable
     */
    omit?: LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivrableInclude<ExtArgs> | null
    /**
     * Filter, which Livrable to fetch.
     */
    where?: LivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livrables to fetch.
     */
    orderBy?: LivrableOrderByWithRelationInput | LivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Livrables.
     */
    cursor?: LivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Livrables.
     */
    distinct?: LivrableScalarFieldEnum | LivrableScalarFieldEnum[]
  }

  /**
   * Livrable findMany
   */
  export type LivrableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livrable
     */
    select?: LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livrable
     */
    omit?: LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivrableInclude<ExtArgs> | null
    /**
     * Filter, which Livrables to fetch.
     */
    where?: LivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livrables to fetch.
     */
    orderBy?: LivrableOrderByWithRelationInput | LivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Livrables.
     */
    cursor?: LivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livrables.
     */
    skip?: number
    distinct?: LivrableScalarFieldEnum | LivrableScalarFieldEnum[]
  }

  /**
   * Livrable create
   */
  export type LivrableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livrable
     */
    select?: LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livrable
     */
    omit?: LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivrableInclude<ExtArgs> | null
    /**
     * The data needed to create a Livrable.
     */
    data: XOR<LivrableCreateInput, LivrableUncheckedCreateInput>
  }

  /**
   * Livrable createMany
   */
  export type LivrableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Livrables.
     */
    data: LivrableCreateManyInput | LivrableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Livrable update
   */
  export type LivrableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livrable
     */
    select?: LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livrable
     */
    omit?: LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivrableInclude<ExtArgs> | null
    /**
     * The data needed to update a Livrable.
     */
    data: XOR<LivrableUpdateInput, LivrableUncheckedUpdateInput>
    /**
     * Choose, which Livrable to update.
     */
    where: LivrableWhereUniqueInput
  }

  /**
   * Livrable updateMany
   */
  export type LivrableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Livrables.
     */
    data: XOR<LivrableUpdateManyMutationInput, LivrableUncheckedUpdateManyInput>
    /**
     * Filter which Livrables to update
     */
    where?: LivrableWhereInput
    /**
     * Limit how many Livrables to update.
     */
    limit?: number
  }

  /**
   * Livrable upsert
   */
  export type LivrableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livrable
     */
    select?: LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livrable
     */
    omit?: LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivrableInclude<ExtArgs> | null
    /**
     * The filter to search for the Livrable to update in case it exists.
     */
    where: LivrableWhereUniqueInput
    /**
     * In case the Livrable found by the `where` argument doesn't exist, create a new Livrable with this data.
     */
    create: XOR<LivrableCreateInput, LivrableUncheckedCreateInput>
    /**
     * In case the Livrable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LivrableUpdateInput, LivrableUncheckedUpdateInput>
  }

  /**
   * Livrable delete
   */
  export type LivrableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livrable
     */
    select?: LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livrable
     */
    omit?: LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivrableInclude<ExtArgs> | null
    /**
     * Filter which Livrable to delete.
     */
    where: LivrableWhereUniqueInput
  }

  /**
   * Livrable deleteMany
   */
  export type LivrableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Livrables to delete
     */
    where?: LivrableWhereInput
    /**
     * Limit how many Livrables to delete.
     */
    limit?: number
  }

  /**
   * Livrable.PFEs
   */
  export type Livrable$PFEsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    where?: PFE_LivrableWhereInput
    orderBy?: PFE_LivrableOrderByWithRelationInput | PFE_LivrableOrderByWithRelationInput[]
    cursor?: PFE_LivrableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PFE_LivrableScalarFieldEnum | PFE_LivrableScalarFieldEnum[]
  }

  /**
   * Livrable.encadrants
   */
  export type Livrable$encadrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    where?: EncadrantLivrableWhereInput
    orderBy?: EncadrantLivrableOrderByWithRelationInput | EncadrantLivrableOrderByWithRelationInput[]
    cursor?: EncadrantLivrableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncadrantLivrableScalarFieldEnum | EncadrantLivrableScalarFieldEnum[]
  }

  /**
   * Livrable.tuteurs
   */
  export type Livrable$tuteursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    where?: TuteurLivrableWhereInput
    orderBy?: TuteurLivrableOrderByWithRelationInput | TuteurLivrableOrderByWithRelationInput[]
    cursor?: TuteurLivrableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TuteurLivrableScalarFieldEnum | TuteurLivrableScalarFieldEnum[]
  }

  /**
   * Livrable without action
   */
  export type LivrableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livrable
     */
    select?: LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livrable
     */
    omit?: LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivrableInclude<ExtArgs> | null
  }


  /**
   * Model PFE
   */

  export type AggregatePFE = {
    _count: PFECountAggregateOutputType | null
    _avg: PFEAvgAggregateOutputType | null
    _sum: PFESumAggregateOutputType | null
    _min: PFEMinAggregateOutputType | null
    _max: PFEMaxAggregateOutputType | null
  }

  export type PFEAvgAggregateOutputType = {
    idPFE: number | null
    statut: number | null
    annee: number | null
    idTuteur: number | null
  }

  export type PFESumAggregateOutputType = {
    idPFE: number | null
    statut: number | null
    annee: number | null
    idTuteur: number | null
  }

  export type PFEMinAggregateOutputType = {
    idPFE: number | null
    statut: number | null
    annee: number | null
    idTuteur: number | null
  }

  export type PFEMaxAggregateOutputType = {
    idPFE: number | null
    statut: number | null
    annee: number | null
    idTuteur: number | null
  }

  export type PFECountAggregateOutputType = {
    idPFE: number
    statut: number
    annee: number
    idTuteur: number
    _all: number
  }


  export type PFEAvgAggregateInputType = {
    idPFE?: true
    statut?: true
    annee?: true
    idTuteur?: true
  }

  export type PFESumAggregateInputType = {
    idPFE?: true
    statut?: true
    annee?: true
    idTuteur?: true
  }

  export type PFEMinAggregateInputType = {
    idPFE?: true
    statut?: true
    annee?: true
    idTuteur?: true
  }

  export type PFEMaxAggregateInputType = {
    idPFE?: true
    statut?: true
    annee?: true
    idTuteur?: true
  }

  export type PFECountAggregateInputType = {
    idPFE?: true
    statut?: true
    annee?: true
    idTuteur?: true
    _all?: true
  }

  export type PFEAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PFE to aggregate.
     */
    where?: PFEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFES to fetch.
     */
    orderBy?: PFEOrderByWithRelationInput | PFEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PFEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PFES
    **/
    _count?: true | PFECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PFEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PFESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PFEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PFEMaxAggregateInputType
  }

  export type GetPFEAggregateType<T extends PFEAggregateArgs> = {
        [P in keyof T & keyof AggregatePFE]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePFE[P]>
      : GetScalarType<T[P], AggregatePFE[P]>
  }




  export type PFEGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PFEWhereInput
    orderBy?: PFEOrderByWithAggregationInput | PFEOrderByWithAggregationInput[]
    by: PFEScalarFieldEnum[] | PFEScalarFieldEnum
    having?: PFEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PFECountAggregateInputType | true
    _avg?: PFEAvgAggregateInputType
    _sum?: PFESumAggregateInputType
    _min?: PFEMinAggregateInputType
    _max?: PFEMaxAggregateInputType
  }

  export type PFEGroupByOutputType = {
    idPFE: number
    statut: number
    annee: number
    idTuteur: number
    _count: PFECountAggregateOutputType | null
    _avg: PFEAvgAggregateOutputType | null
    _sum: PFESumAggregateOutputType | null
    _min: PFEMinAggregateOutputType | null
    _max: PFEMaxAggregateOutputType | null
  }

  type GetPFEGroupByPayload<T extends PFEGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PFEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PFEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PFEGroupByOutputType[P]>
            : GetScalarType<T[P], PFEGroupByOutputType[P]>
        }
      >
    >


  export type PFESelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPFE?: boolean
    statut?: boolean
    annee?: boolean
    idTuteur?: boolean
    tuteur?: boolean | TuteurDefaultArgs<ExtArgs>
    groupes?: boolean | PFE$groupesArgs<ExtArgs>
    livrables?: boolean | PFE$livrablesArgs<ExtArgs>
    _count?: boolean | PFECountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pFE"]>



  export type PFESelectScalar = {
    idPFE?: boolean
    statut?: boolean
    annee?: boolean
    idTuteur?: boolean
  }

  export type PFEOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPFE" | "statut" | "annee" | "idTuteur", ExtArgs["result"]["pFE"]>
  export type PFEInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tuteur?: boolean | TuteurDefaultArgs<ExtArgs>
    groupes?: boolean | PFE$groupesArgs<ExtArgs>
    livrables?: boolean | PFE$livrablesArgs<ExtArgs>
    _count?: boolean | PFECountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PFEPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PFE"
    objects: {
      tuteur: Prisma.$TuteurPayload<ExtArgs>
      groupes: Prisma.$PFE_GroupePayload<ExtArgs>[]
      livrables: Prisma.$PFE_LivrablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPFE: number
      statut: number
      annee: number
      idTuteur: number
    }, ExtArgs["result"]["pFE"]>
    composites: {}
  }

  type PFEGetPayload<S extends boolean | null | undefined | PFEDefaultArgs> = $Result.GetResult<Prisma.$PFEPayload, S>

  type PFECountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PFEFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PFECountAggregateInputType | true
    }

  export interface PFEDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PFE'], meta: { name: 'PFE' } }
    /**
     * Find zero or one PFE that matches the filter.
     * @param {PFEFindUniqueArgs} args - Arguments to find a PFE
     * @example
     * // Get one PFE
     * const pFE = await prisma.pFE.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PFEFindUniqueArgs>(args: SelectSubset<T, PFEFindUniqueArgs<ExtArgs>>): Prisma__PFEClient<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PFE that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PFEFindUniqueOrThrowArgs} args - Arguments to find a PFE
     * @example
     * // Get one PFE
     * const pFE = await prisma.pFE.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PFEFindUniqueOrThrowArgs>(args: SelectSubset<T, PFEFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PFEClient<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PFE that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFEFindFirstArgs} args - Arguments to find a PFE
     * @example
     * // Get one PFE
     * const pFE = await prisma.pFE.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PFEFindFirstArgs>(args?: SelectSubset<T, PFEFindFirstArgs<ExtArgs>>): Prisma__PFEClient<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PFE that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFEFindFirstOrThrowArgs} args - Arguments to find a PFE
     * @example
     * // Get one PFE
     * const pFE = await prisma.pFE.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PFEFindFirstOrThrowArgs>(args?: SelectSubset<T, PFEFindFirstOrThrowArgs<ExtArgs>>): Prisma__PFEClient<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PFES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFEFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PFES
     * const pFES = await prisma.pFE.findMany()
     * 
     * // Get first 10 PFES
     * const pFES = await prisma.pFE.findMany({ take: 10 })
     * 
     * // Only select the `idPFE`
     * const pFEWithIdPFEOnly = await prisma.pFE.findMany({ select: { idPFE: true } })
     * 
     */
    findMany<T extends PFEFindManyArgs>(args?: SelectSubset<T, PFEFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PFE.
     * @param {PFECreateArgs} args - Arguments to create a PFE.
     * @example
     * // Create one PFE
     * const PFE = await prisma.pFE.create({
     *   data: {
     *     // ... data to create a PFE
     *   }
     * })
     * 
     */
    create<T extends PFECreateArgs>(args: SelectSubset<T, PFECreateArgs<ExtArgs>>): Prisma__PFEClient<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PFES.
     * @param {PFECreateManyArgs} args - Arguments to create many PFES.
     * @example
     * // Create many PFES
     * const pFE = await prisma.pFE.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PFECreateManyArgs>(args?: SelectSubset<T, PFECreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PFE.
     * @param {PFEDeleteArgs} args - Arguments to delete one PFE.
     * @example
     * // Delete one PFE
     * const PFE = await prisma.pFE.delete({
     *   where: {
     *     // ... filter to delete one PFE
     *   }
     * })
     * 
     */
    delete<T extends PFEDeleteArgs>(args: SelectSubset<T, PFEDeleteArgs<ExtArgs>>): Prisma__PFEClient<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PFE.
     * @param {PFEUpdateArgs} args - Arguments to update one PFE.
     * @example
     * // Update one PFE
     * const pFE = await prisma.pFE.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PFEUpdateArgs>(args: SelectSubset<T, PFEUpdateArgs<ExtArgs>>): Prisma__PFEClient<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PFES.
     * @param {PFEDeleteManyArgs} args - Arguments to filter PFES to delete.
     * @example
     * // Delete a few PFES
     * const { count } = await prisma.pFE.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PFEDeleteManyArgs>(args?: SelectSubset<T, PFEDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PFES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PFES
     * const pFE = await prisma.pFE.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PFEUpdateManyArgs>(args: SelectSubset<T, PFEUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PFE.
     * @param {PFEUpsertArgs} args - Arguments to update or create a PFE.
     * @example
     * // Update or create a PFE
     * const pFE = await prisma.pFE.upsert({
     *   create: {
     *     // ... data to create a PFE
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PFE we want to update
     *   }
     * })
     */
    upsert<T extends PFEUpsertArgs>(args: SelectSubset<T, PFEUpsertArgs<ExtArgs>>): Prisma__PFEClient<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PFES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFECountArgs} args - Arguments to filter PFES to count.
     * @example
     * // Count the number of PFES
     * const count = await prisma.pFE.count({
     *   where: {
     *     // ... the filter for the PFES we want to count
     *   }
     * })
    **/
    count<T extends PFECountArgs>(
      args?: Subset<T, PFECountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PFECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PFE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PFEAggregateArgs>(args: Subset<T, PFEAggregateArgs>): Prisma.PrismaPromise<GetPFEAggregateType<T>>

    /**
     * Group by PFE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PFEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PFEGroupByArgs['orderBy'] }
        : { orderBy?: PFEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PFEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPFEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PFE model
   */
  readonly fields: PFEFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PFE.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PFEClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tuteur<T extends TuteurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TuteurDefaultArgs<ExtArgs>>): Prisma__TuteurClient<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    groupes<T extends PFE$groupesArgs<ExtArgs> = {}>(args?: Subset<T, PFE$groupesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    livrables<T extends PFE$livrablesArgs<ExtArgs> = {}>(args?: Subset<T, PFE$livrablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PFE model
   */ 
  interface PFEFieldRefs {
    readonly idPFE: FieldRef<"PFE", 'Int'>
    readonly statut: FieldRef<"PFE", 'Int'>
    readonly annee: FieldRef<"PFE", 'Int'>
    readonly idTuteur: FieldRef<"PFE", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PFE findUnique
   */
  export type PFEFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
    /**
     * Filter, which PFE to fetch.
     */
    where: PFEWhereUniqueInput
  }

  /**
   * PFE findUniqueOrThrow
   */
  export type PFEFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
    /**
     * Filter, which PFE to fetch.
     */
    where: PFEWhereUniqueInput
  }

  /**
   * PFE findFirst
   */
  export type PFEFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
    /**
     * Filter, which PFE to fetch.
     */
    where?: PFEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFES to fetch.
     */
    orderBy?: PFEOrderByWithRelationInput | PFEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PFES.
     */
    cursor?: PFEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PFES.
     */
    distinct?: PFEScalarFieldEnum | PFEScalarFieldEnum[]
  }

  /**
   * PFE findFirstOrThrow
   */
  export type PFEFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
    /**
     * Filter, which PFE to fetch.
     */
    where?: PFEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFES to fetch.
     */
    orderBy?: PFEOrderByWithRelationInput | PFEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PFES.
     */
    cursor?: PFEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PFES.
     */
    distinct?: PFEScalarFieldEnum | PFEScalarFieldEnum[]
  }

  /**
   * PFE findMany
   */
  export type PFEFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
    /**
     * Filter, which PFES to fetch.
     */
    where?: PFEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFES to fetch.
     */
    orderBy?: PFEOrderByWithRelationInput | PFEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PFES.
     */
    cursor?: PFEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFES.
     */
    skip?: number
    distinct?: PFEScalarFieldEnum | PFEScalarFieldEnum[]
  }

  /**
   * PFE create
   */
  export type PFECreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
    /**
     * The data needed to create a PFE.
     */
    data: XOR<PFECreateInput, PFEUncheckedCreateInput>
  }

  /**
   * PFE createMany
   */
  export type PFECreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PFES.
     */
    data: PFECreateManyInput | PFECreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PFE update
   */
  export type PFEUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
    /**
     * The data needed to update a PFE.
     */
    data: XOR<PFEUpdateInput, PFEUncheckedUpdateInput>
    /**
     * Choose, which PFE to update.
     */
    where: PFEWhereUniqueInput
  }

  /**
   * PFE updateMany
   */
  export type PFEUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PFES.
     */
    data: XOR<PFEUpdateManyMutationInput, PFEUncheckedUpdateManyInput>
    /**
     * Filter which PFES to update
     */
    where?: PFEWhereInput
    /**
     * Limit how many PFES to update.
     */
    limit?: number
  }

  /**
   * PFE upsert
   */
  export type PFEUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
    /**
     * The filter to search for the PFE to update in case it exists.
     */
    where: PFEWhereUniqueInput
    /**
     * In case the PFE found by the `where` argument doesn't exist, create a new PFE with this data.
     */
    create: XOR<PFECreateInput, PFEUncheckedCreateInput>
    /**
     * In case the PFE was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PFEUpdateInput, PFEUncheckedUpdateInput>
  }

  /**
   * PFE delete
   */
  export type PFEDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
    /**
     * Filter which PFE to delete.
     */
    where: PFEWhereUniqueInput
  }

  /**
   * PFE deleteMany
   */
  export type PFEDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PFES to delete
     */
    where?: PFEWhereInput
    /**
     * Limit how many PFES to delete.
     */
    limit?: number
  }

  /**
   * PFE.groupes
   */
  export type PFE$groupesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    where?: PFE_GroupeWhereInput
    orderBy?: PFE_GroupeOrderByWithRelationInput | PFE_GroupeOrderByWithRelationInput[]
    cursor?: PFE_GroupeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PFE_GroupeScalarFieldEnum | PFE_GroupeScalarFieldEnum[]
  }

  /**
   * PFE.livrables
   */
  export type PFE$livrablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    where?: PFE_LivrableWhereInput
    orderBy?: PFE_LivrableOrderByWithRelationInput | PFE_LivrableOrderByWithRelationInput[]
    cursor?: PFE_LivrableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PFE_LivrableScalarFieldEnum | PFE_LivrableScalarFieldEnum[]
  }

  /**
   * PFE without action
   */
  export type PFEDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE
     */
    select?: PFESelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE
     */
    omit?: PFEOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFEInclude<ExtArgs> | null
  }


  /**
   * Model PFE_Groupe
   */

  export type AggregatePFE_Groupe = {
    _count: PFE_GroupeCountAggregateOutputType | null
    _avg: PFE_GroupeAvgAggregateOutputType | null
    _sum: PFE_GroupeSumAggregateOutputType | null
    _min: PFE_GroupeMinAggregateOutputType | null
    _max: PFE_GroupeMaxAggregateOutputType | null
  }

  export type PFE_GroupeAvgAggregateOutputType = {
    idPFE: number | null
    idGroupe: number | null
  }

  export type PFE_GroupeSumAggregateOutputType = {
    idPFE: number | null
    idGroupe: number | null
  }

  export type PFE_GroupeMinAggregateOutputType = {
    idPFE: number | null
    idGroupe: number | null
  }

  export type PFE_GroupeMaxAggregateOutputType = {
    idPFE: number | null
    idGroupe: number | null
  }

  export type PFE_GroupeCountAggregateOutputType = {
    idPFE: number
    idGroupe: number
    _all: number
  }


  export type PFE_GroupeAvgAggregateInputType = {
    idPFE?: true
    idGroupe?: true
  }

  export type PFE_GroupeSumAggregateInputType = {
    idPFE?: true
    idGroupe?: true
  }

  export type PFE_GroupeMinAggregateInputType = {
    idPFE?: true
    idGroupe?: true
  }

  export type PFE_GroupeMaxAggregateInputType = {
    idPFE?: true
    idGroupe?: true
  }

  export type PFE_GroupeCountAggregateInputType = {
    idPFE?: true
    idGroupe?: true
    _all?: true
  }

  export type PFE_GroupeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PFE_Groupe to aggregate.
     */
    where?: PFE_GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFE_Groupes to fetch.
     */
    orderBy?: PFE_GroupeOrderByWithRelationInput | PFE_GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PFE_GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFE_Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFE_Groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PFE_Groupes
    **/
    _count?: true | PFE_GroupeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PFE_GroupeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PFE_GroupeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PFE_GroupeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PFE_GroupeMaxAggregateInputType
  }

  export type GetPFE_GroupeAggregateType<T extends PFE_GroupeAggregateArgs> = {
        [P in keyof T & keyof AggregatePFE_Groupe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePFE_Groupe[P]>
      : GetScalarType<T[P], AggregatePFE_Groupe[P]>
  }




  export type PFE_GroupeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PFE_GroupeWhereInput
    orderBy?: PFE_GroupeOrderByWithAggregationInput | PFE_GroupeOrderByWithAggregationInput[]
    by: PFE_GroupeScalarFieldEnum[] | PFE_GroupeScalarFieldEnum
    having?: PFE_GroupeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PFE_GroupeCountAggregateInputType | true
    _avg?: PFE_GroupeAvgAggregateInputType
    _sum?: PFE_GroupeSumAggregateInputType
    _min?: PFE_GroupeMinAggregateInputType
    _max?: PFE_GroupeMaxAggregateInputType
  }

  export type PFE_GroupeGroupByOutputType = {
    idPFE: number
    idGroupe: number
    _count: PFE_GroupeCountAggregateOutputType | null
    _avg: PFE_GroupeAvgAggregateOutputType | null
    _sum: PFE_GroupeSumAggregateOutputType | null
    _min: PFE_GroupeMinAggregateOutputType | null
    _max: PFE_GroupeMaxAggregateOutputType | null
  }

  type GetPFE_GroupeGroupByPayload<T extends PFE_GroupeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PFE_GroupeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PFE_GroupeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PFE_GroupeGroupByOutputType[P]>
            : GetScalarType<T[P], PFE_GroupeGroupByOutputType[P]>
        }
      >
    >


  export type PFE_GroupeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPFE?: boolean
    idGroupe?: boolean
    pfe?: boolean | PFEDefaultArgs<ExtArgs>
    groupe?: boolean | GroupeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pFE_Groupe"]>



  export type PFE_GroupeSelectScalar = {
    idPFE?: boolean
    idGroupe?: boolean
  }

  export type PFE_GroupeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPFE" | "idGroupe", ExtArgs["result"]["pFE_Groupe"]>
  export type PFE_GroupeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pfe?: boolean | PFEDefaultArgs<ExtArgs>
    groupe?: boolean | GroupeDefaultArgs<ExtArgs>
  }

  export type $PFE_GroupePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PFE_Groupe"
    objects: {
      pfe: Prisma.$PFEPayload<ExtArgs>
      groupe: Prisma.$GroupePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPFE: number
      idGroupe: number
    }, ExtArgs["result"]["pFE_Groupe"]>
    composites: {}
  }

  type PFE_GroupeGetPayload<S extends boolean | null | undefined | PFE_GroupeDefaultArgs> = $Result.GetResult<Prisma.$PFE_GroupePayload, S>

  type PFE_GroupeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PFE_GroupeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PFE_GroupeCountAggregateInputType | true
    }

  export interface PFE_GroupeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PFE_Groupe'], meta: { name: 'PFE_Groupe' } }
    /**
     * Find zero or one PFE_Groupe that matches the filter.
     * @param {PFE_GroupeFindUniqueArgs} args - Arguments to find a PFE_Groupe
     * @example
     * // Get one PFE_Groupe
     * const pFE_Groupe = await prisma.pFE_Groupe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PFE_GroupeFindUniqueArgs>(args: SelectSubset<T, PFE_GroupeFindUniqueArgs<ExtArgs>>): Prisma__PFE_GroupeClient<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PFE_Groupe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PFE_GroupeFindUniqueOrThrowArgs} args - Arguments to find a PFE_Groupe
     * @example
     * // Get one PFE_Groupe
     * const pFE_Groupe = await prisma.pFE_Groupe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PFE_GroupeFindUniqueOrThrowArgs>(args: SelectSubset<T, PFE_GroupeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PFE_GroupeClient<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PFE_Groupe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_GroupeFindFirstArgs} args - Arguments to find a PFE_Groupe
     * @example
     * // Get one PFE_Groupe
     * const pFE_Groupe = await prisma.pFE_Groupe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PFE_GroupeFindFirstArgs>(args?: SelectSubset<T, PFE_GroupeFindFirstArgs<ExtArgs>>): Prisma__PFE_GroupeClient<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PFE_Groupe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_GroupeFindFirstOrThrowArgs} args - Arguments to find a PFE_Groupe
     * @example
     * // Get one PFE_Groupe
     * const pFE_Groupe = await prisma.pFE_Groupe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PFE_GroupeFindFirstOrThrowArgs>(args?: SelectSubset<T, PFE_GroupeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PFE_GroupeClient<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PFE_Groupes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_GroupeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PFE_Groupes
     * const pFE_Groupes = await prisma.pFE_Groupe.findMany()
     * 
     * // Get first 10 PFE_Groupes
     * const pFE_Groupes = await prisma.pFE_Groupe.findMany({ take: 10 })
     * 
     * // Only select the `idPFE`
     * const pFE_GroupeWithIdPFEOnly = await prisma.pFE_Groupe.findMany({ select: { idPFE: true } })
     * 
     */
    findMany<T extends PFE_GroupeFindManyArgs>(args?: SelectSubset<T, PFE_GroupeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PFE_Groupe.
     * @param {PFE_GroupeCreateArgs} args - Arguments to create a PFE_Groupe.
     * @example
     * // Create one PFE_Groupe
     * const PFE_Groupe = await prisma.pFE_Groupe.create({
     *   data: {
     *     // ... data to create a PFE_Groupe
     *   }
     * })
     * 
     */
    create<T extends PFE_GroupeCreateArgs>(args: SelectSubset<T, PFE_GroupeCreateArgs<ExtArgs>>): Prisma__PFE_GroupeClient<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PFE_Groupes.
     * @param {PFE_GroupeCreateManyArgs} args - Arguments to create many PFE_Groupes.
     * @example
     * // Create many PFE_Groupes
     * const pFE_Groupe = await prisma.pFE_Groupe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PFE_GroupeCreateManyArgs>(args?: SelectSubset<T, PFE_GroupeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PFE_Groupe.
     * @param {PFE_GroupeDeleteArgs} args - Arguments to delete one PFE_Groupe.
     * @example
     * // Delete one PFE_Groupe
     * const PFE_Groupe = await prisma.pFE_Groupe.delete({
     *   where: {
     *     // ... filter to delete one PFE_Groupe
     *   }
     * })
     * 
     */
    delete<T extends PFE_GroupeDeleteArgs>(args: SelectSubset<T, PFE_GroupeDeleteArgs<ExtArgs>>): Prisma__PFE_GroupeClient<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PFE_Groupe.
     * @param {PFE_GroupeUpdateArgs} args - Arguments to update one PFE_Groupe.
     * @example
     * // Update one PFE_Groupe
     * const pFE_Groupe = await prisma.pFE_Groupe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PFE_GroupeUpdateArgs>(args: SelectSubset<T, PFE_GroupeUpdateArgs<ExtArgs>>): Prisma__PFE_GroupeClient<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PFE_Groupes.
     * @param {PFE_GroupeDeleteManyArgs} args - Arguments to filter PFE_Groupes to delete.
     * @example
     * // Delete a few PFE_Groupes
     * const { count } = await prisma.pFE_Groupe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PFE_GroupeDeleteManyArgs>(args?: SelectSubset<T, PFE_GroupeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PFE_Groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_GroupeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PFE_Groupes
     * const pFE_Groupe = await prisma.pFE_Groupe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PFE_GroupeUpdateManyArgs>(args: SelectSubset<T, PFE_GroupeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PFE_Groupe.
     * @param {PFE_GroupeUpsertArgs} args - Arguments to update or create a PFE_Groupe.
     * @example
     * // Update or create a PFE_Groupe
     * const pFE_Groupe = await prisma.pFE_Groupe.upsert({
     *   create: {
     *     // ... data to create a PFE_Groupe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PFE_Groupe we want to update
     *   }
     * })
     */
    upsert<T extends PFE_GroupeUpsertArgs>(args: SelectSubset<T, PFE_GroupeUpsertArgs<ExtArgs>>): Prisma__PFE_GroupeClient<$Result.GetResult<Prisma.$PFE_GroupePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PFE_Groupes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_GroupeCountArgs} args - Arguments to filter PFE_Groupes to count.
     * @example
     * // Count the number of PFE_Groupes
     * const count = await prisma.pFE_Groupe.count({
     *   where: {
     *     // ... the filter for the PFE_Groupes we want to count
     *   }
     * })
    **/
    count<T extends PFE_GroupeCountArgs>(
      args?: Subset<T, PFE_GroupeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PFE_GroupeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PFE_Groupe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_GroupeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PFE_GroupeAggregateArgs>(args: Subset<T, PFE_GroupeAggregateArgs>): Prisma.PrismaPromise<GetPFE_GroupeAggregateType<T>>

    /**
     * Group by PFE_Groupe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_GroupeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PFE_GroupeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PFE_GroupeGroupByArgs['orderBy'] }
        : { orderBy?: PFE_GroupeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PFE_GroupeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPFE_GroupeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PFE_Groupe model
   */
  readonly fields: PFE_GroupeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PFE_Groupe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PFE_GroupeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pfe<T extends PFEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PFEDefaultArgs<ExtArgs>>): Prisma__PFEClient<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    groupe<T extends GroupeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupeDefaultArgs<ExtArgs>>): Prisma__GroupeClient<$Result.GetResult<Prisma.$GroupePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PFE_Groupe model
   */ 
  interface PFE_GroupeFieldRefs {
    readonly idPFE: FieldRef<"PFE_Groupe", 'Int'>
    readonly idGroupe: FieldRef<"PFE_Groupe", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PFE_Groupe findUnique
   */
  export type PFE_GroupeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    /**
     * Filter, which PFE_Groupe to fetch.
     */
    where: PFE_GroupeWhereUniqueInput
  }

  /**
   * PFE_Groupe findUniqueOrThrow
   */
  export type PFE_GroupeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    /**
     * Filter, which PFE_Groupe to fetch.
     */
    where: PFE_GroupeWhereUniqueInput
  }

  /**
   * PFE_Groupe findFirst
   */
  export type PFE_GroupeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    /**
     * Filter, which PFE_Groupe to fetch.
     */
    where?: PFE_GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFE_Groupes to fetch.
     */
    orderBy?: PFE_GroupeOrderByWithRelationInput | PFE_GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PFE_Groupes.
     */
    cursor?: PFE_GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFE_Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFE_Groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PFE_Groupes.
     */
    distinct?: PFE_GroupeScalarFieldEnum | PFE_GroupeScalarFieldEnum[]
  }

  /**
   * PFE_Groupe findFirstOrThrow
   */
  export type PFE_GroupeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    /**
     * Filter, which PFE_Groupe to fetch.
     */
    where?: PFE_GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFE_Groupes to fetch.
     */
    orderBy?: PFE_GroupeOrderByWithRelationInput | PFE_GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PFE_Groupes.
     */
    cursor?: PFE_GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFE_Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFE_Groupes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PFE_Groupes.
     */
    distinct?: PFE_GroupeScalarFieldEnum | PFE_GroupeScalarFieldEnum[]
  }

  /**
   * PFE_Groupe findMany
   */
  export type PFE_GroupeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    /**
     * Filter, which PFE_Groupes to fetch.
     */
    where?: PFE_GroupeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFE_Groupes to fetch.
     */
    orderBy?: PFE_GroupeOrderByWithRelationInput | PFE_GroupeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PFE_Groupes.
     */
    cursor?: PFE_GroupeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFE_Groupes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFE_Groupes.
     */
    skip?: number
    distinct?: PFE_GroupeScalarFieldEnum | PFE_GroupeScalarFieldEnum[]
  }

  /**
   * PFE_Groupe create
   */
  export type PFE_GroupeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    /**
     * The data needed to create a PFE_Groupe.
     */
    data: XOR<PFE_GroupeCreateInput, PFE_GroupeUncheckedCreateInput>
  }

  /**
   * PFE_Groupe createMany
   */
  export type PFE_GroupeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PFE_Groupes.
     */
    data: PFE_GroupeCreateManyInput | PFE_GroupeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PFE_Groupe update
   */
  export type PFE_GroupeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    /**
     * The data needed to update a PFE_Groupe.
     */
    data: XOR<PFE_GroupeUpdateInput, PFE_GroupeUncheckedUpdateInput>
    /**
     * Choose, which PFE_Groupe to update.
     */
    where: PFE_GroupeWhereUniqueInput
  }

  /**
   * PFE_Groupe updateMany
   */
  export type PFE_GroupeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PFE_Groupes.
     */
    data: XOR<PFE_GroupeUpdateManyMutationInput, PFE_GroupeUncheckedUpdateManyInput>
    /**
     * Filter which PFE_Groupes to update
     */
    where?: PFE_GroupeWhereInput
    /**
     * Limit how many PFE_Groupes to update.
     */
    limit?: number
  }

  /**
   * PFE_Groupe upsert
   */
  export type PFE_GroupeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    /**
     * The filter to search for the PFE_Groupe to update in case it exists.
     */
    where: PFE_GroupeWhereUniqueInput
    /**
     * In case the PFE_Groupe found by the `where` argument doesn't exist, create a new PFE_Groupe with this data.
     */
    create: XOR<PFE_GroupeCreateInput, PFE_GroupeUncheckedCreateInput>
    /**
     * In case the PFE_Groupe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PFE_GroupeUpdateInput, PFE_GroupeUncheckedUpdateInput>
  }

  /**
   * PFE_Groupe delete
   */
  export type PFE_GroupeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
    /**
     * Filter which PFE_Groupe to delete.
     */
    where: PFE_GroupeWhereUniqueInput
  }

  /**
   * PFE_Groupe deleteMany
   */
  export type PFE_GroupeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PFE_Groupes to delete
     */
    where?: PFE_GroupeWhereInput
    /**
     * Limit how many PFE_Groupes to delete.
     */
    limit?: number
  }

  /**
   * PFE_Groupe without action
   */
  export type PFE_GroupeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Groupe
     */
    select?: PFE_GroupeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Groupe
     */
    omit?: PFE_GroupeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_GroupeInclude<ExtArgs> | null
  }


  /**
   * Model PFE_Livrable
   */

  export type AggregatePFE_Livrable = {
    _count: PFE_LivrableCountAggregateOutputType | null
    _avg: PFE_LivrableAvgAggregateOutputType | null
    _sum: PFE_LivrableSumAggregateOutputType | null
    _min: PFE_LivrableMinAggregateOutputType | null
    _max: PFE_LivrableMaxAggregateOutputType | null
  }

  export type PFE_LivrableAvgAggregateOutputType = {
    idPFE: number | null
    idLivrable: number | null
  }

  export type PFE_LivrableSumAggregateOutputType = {
    idPFE: number | null
    idLivrable: number | null
  }

  export type PFE_LivrableMinAggregateOutputType = {
    idPFE: number | null
    idLivrable: number | null
  }

  export type PFE_LivrableMaxAggregateOutputType = {
    idPFE: number | null
    idLivrable: number | null
  }

  export type PFE_LivrableCountAggregateOutputType = {
    idPFE: number
    idLivrable: number
    _all: number
  }


  export type PFE_LivrableAvgAggregateInputType = {
    idPFE?: true
    idLivrable?: true
  }

  export type PFE_LivrableSumAggregateInputType = {
    idPFE?: true
    idLivrable?: true
  }

  export type PFE_LivrableMinAggregateInputType = {
    idPFE?: true
    idLivrable?: true
  }

  export type PFE_LivrableMaxAggregateInputType = {
    idPFE?: true
    idLivrable?: true
  }

  export type PFE_LivrableCountAggregateInputType = {
    idPFE?: true
    idLivrable?: true
    _all?: true
  }

  export type PFE_LivrableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PFE_Livrable to aggregate.
     */
    where?: PFE_LivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFE_Livrables to fetch.
     */
    orderBy?: PFE_LivrableOrderByWithRelationInput | PFE_LivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PFE_LivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFE_Livrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFE_Livrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PFE_Livrables
    **/
    _count?: true | PFE_LivrableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PFE_LivrableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PFE_LivrableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PFE_LivrableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PFE_LivrableMaxAggregateInputType
  }

  export type GetPFE_LivrableAggregateType<T extends PFE_LivrableAggregateArgs> = {
        [P in keyof T & keyof AggregatePFE_Livrable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePFE_Livrable[P]>
      : GetScalarType<T[P], AggregatePFE_Livrable[P]>
  }




  export type PFE_LivrableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PFE_LivrableWhereInput
    orderBy?: PFE_LivrableOrderByWithAggregationInput | PFE_LivrableOrderByWithAggregationInput[]
    by: PFE_LivrableScalarFieldEnum[] | PFE_LivrableScalarFieldEnum
    having?: PFE_LivrableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PFE_LivrableCountAggregateInputType | true
    _avg?: PFE_LivrableAvgAggregateInputType
    _sum?: PFE_LivrableSumAggregateInputType
    _min?: PFE_LivrableMinAggregateInputType
    _max?: PFE_LivrableMaxAggregateInputType
  }

  export type PFE_LivrableGroupByOutputType = {
    idPFE: number
    idLivrable: number
    _count: PFE_LivrableCountAggregateOutputType | null
    _avg: PFE_LivrableAvgAggregateOutputType | null
    _sum: PFE_LivrableSumAggregateOutputType | null
    _min: PFE_LivrableMinAggregateOutputType | null
    _max: PFE_LivrableMaxAggregateOutputType | null
  }

  type GetPFE_LivrableGroupByPayload<T extends PFE_LivrableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PFE_LivrableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PFE_LivrableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PFE_LivrableGroupByOutputType[P]>
            : GetScalarType<T[P], PFE_LivrableGroupByOutputType[P]>
        }
      >
    >


  export type PFE_LivrableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPFE?: boolean
    idLivrable?: boolean
    pfe?: boolean | PFEDefaultArgs<ExtArgs>
    livrable?: boolean | LivrableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pFE_Livrable"]>



  export type PFE_LivrableSelectScalar = {
    idPFE?: boolean
    idLivrable?: boolean
  }

  export type PFE_LivrableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPFE" | "idLivrable", ExtArgs["result"]["pFE_Livrable"]>
  export type PFE_LivrableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pfe?: boolean | PFEDefaultArgs<ExtArgs>
    livrable?: boolean | LivrableDefaultArgs<ExtArgs>
  }

  export type $PFE_LivrablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PFE_Livrable"
    objects: {
      pfe: Prisma.$PFEPayload<ExtArgs>
      livrable: Prisma.$LivrablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPFE: number
      idLivrable: number
    }, ExtArgs["result"]["pFE_Livrable"]>
    composites: {}
  }

  type PFE_LivrableGetPayload<S extends boolean | null | undefined | PFE_LivrableDefaultArgs> = $Result.GetResult<Prisma.$PFE_LivrablePayload, S>

  type PFE_LivrableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PFE_LivrableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PFE_LivrableCountAggregateInputType | true
    }

  export interface PFE_LivrableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PFE_Livrable'], meta: { name: 'PFE_Livrable' } }
    /**
     * Find zero or one PFE_Livrable that matches the filter.
     * @param {PFE_LivrableFindUniqueArgs} args - Arguments to find a PFE_Livrable
     * @example
     * // Get one PFE_Livrable
     * const pFE_Livrable = await prisma.pFE_Livrable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PFE_LivrableFindUniqueArgs>(args: SelectSubset<T, PFE_LivrableFindUniqueArgs<ExtArgs>>): Prisma__PFE_LivrableClient<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PFE_Livrable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PFE_LivrableFindUniqueOrThrowArgs} args - Arguments to find a PFE_Livrable
     * @example
     * // Get one PFE_Livrable
     * const pFE_Livrable = await prisma.pFE_Livrable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PFE_LivrableFindUniqueOrThrowArgs>(args: SelectSubset<T, PFE_LivrableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PFE_LivrableClient<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PFE_Livrable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_LivrableFindFirstArgs} args - Arguments to find a PFE_Livrable
     * @example
     * // Get one PFE_Livrable
     * const pFE_Livrable = await prisma.pFE_Livrable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PFE_LivrableFindFirstArgs>(args?: SelectSubset<T, PFE_LivrableFindFirstArgs<ExtArgs>>): Prisma__PFE_LivrableClient<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PFE_Livrable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_LivrableFindFirstOrThrowArgs} args - Arguments to find a PFE_Livrable
     * @example
     * // Get one PFE_Livrable
     * const pFE_Livrable = await prisma.pFE_Livrable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PFE_LivrableFindFirstOrThrowArgs>(args?: SelectSubset<T, PFE_LivrableFindFirstOrThrowArgs<ExtArgs>>): Prisma__PFE_LivrableClient<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PFE_Livrables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_LivrableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PFE_Livrables
     * const pFE_Livrables = await prisma.pFE_Livrable.findMany()
     * 
     * // Get first 10 PFE_Livrables
     * const pFE_Livrables = await prisma.pFE_Livrable.findMany({ take: 10 })
     * 
     * // Only select the `idPFE`
     * const pFE_LivrableWithIdPFEOnly = await prisma.pFE_Livrable.findMany({ select: { idPFE: true } })
     * 
     */
    findMany<T extends PFE_LivrableFindManyArgs>(args?: SelectSubset<T, PFE_LivrableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PFE_Livrable.
     * @param {PFE_LivrableCreateArgs} args - Arguments to create a PFE_Livrable.
     * @example
     * // Create one PFE_Livrable
     * const PFE_Livrable = await prisma.pFE_Livrable.create({
     *   data: {
     *     // ... data to create a PFE_Livrable
     *   }
     * })
     * 
     */
    create<T extends PFE_LivrableCreateArgs>(args: SelectSubset<T, PFE_LivrableCreateArgs<ExtArgs>>): Prisma__PFE_LivrableClient<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PFE_Livrables.
     * @param {PFE_LivrableCreateManyArgs} args - Arguments to create many PFE_Livrables.
     * @example
     * // Create many PFE_Livrables
     * const pFE_Livrable = await prisma.pFE_Livrable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PFE_LivrableCreateManyArgs>(args?: SelectSubset<T, PFE_LivrableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PFE_Livrable.
     * @param {PFE_LivrableDeleteArgs} args - Arguments to delete one PFE_Livrable.
     * @example
     * // Delete one PFE_Livrable
     * const PFE_Livrable = await prisma.pFE_Livrable.delete({
     *   where: {
     *     // ... filter to delete one PFE_Livrable
     *   }
     * })
     * 
     */
    delete<T extends PFE_LivrableDeleteArgs>(args: SelectSubset<T, PFE_LivrableDeleteArgs<ExtArgs>>): Prisma__PFE_LivrableClient<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PFE_Livrable.
     * @param {PFE_LivrableUpdateArgs} args - Arguments to update one PFE_Livrable.
     * @example
     * // Update one PFE_Livrable
     * const pFE_Livrable = await prisma.pFE_Livrable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PFE_LivrableUpdateArgs>(args: SelectSubset<T, PFE_LivrableUpdateArgs<ExtArgs>>): Prisma__PFE_LivrableClient<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PFE_Livrables.
     * @param {PFE_LivrableDeleteManyArgs} args - Arguments to filter PFE_Livrables to delete.
     * @example
     * // Delete a few PFE_Livrables
     * const { count } = await prisma.pFE_Livrable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PFE_LivrableDeleteManyArgs>(args?: SelectSubset<T, PFE_LivrableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PFE_Livrables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_LivrableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PFE_Livrables
     * const pFE_Livrable = await prisma.pFE_Livrable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PFE_LivrableUpdateManyArgs>(args: SelectSubset<T, PFE_LivrableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PFE_Livrable.
     * @param {PFE_LivrableUpsertArgs} args - Arguments to update or create a PFE_Livrable.
     * @example
     * // Update or create a PFE_Livrable
     * const pFE_Livrable = await prisma.pFE_Livrable.upsert({
     *   create: {
     *     // ... data to create a PFE_Livrable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PFE_Livrable we want to update
     *   }
     * })
     */
    upsert<T extends PFE_LivrableUpsertArgs>(args: SelectSubset<T, PFE_LivrableUpsertArgs<ExtArgs>>): Prisma__PFE_LivrableClient<$Result.GetResult<Prisma.$PFE_LivrablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PFE_Livrables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_LivrableCountArgs} args - Arguments to filter PFE_Livrables to count.
     * @example
     * // Count the number of PFE_Livrables
     * const count = await prisma.pFE_Livrable.count({
     *   where: {
     *     // ... the filter for the PFE_Livrables we want to count
     *   }
     * })
    **/
    count<T extends PFE_LivrableCountArgs>(
      args?: Subset<T, PFE_LivrableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PFE_LivrableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PFE_Livrable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_LivrableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PFE_LivrableAggregateArgs>(args: Subset<T, PFE_LivrableAggregateArgs>): Prisma.PrismaPromise<GetPFE_LivrableAggregateType<T>>

    /**
     * Group by PFE_Livrable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PFE_LivrableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PFE_LivrableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PFE_LivrableGroupByArgs['orderBy'] }
        : { orderBy?: PFE_LivrableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PFE_LivrableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPFE_LivrableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PFE_Livrable model
   */
  readonly fields: PFE_LivrableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PFE_Livrable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PFE_LivrableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pfe<T extends PFEDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PFEDefaultArgs<ExtArgs>>): Prisma__PFEClient<$Result.GetResult<Prisma.$PFEPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    livrable<T extends LivrableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivrableDefaultArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PFE_Livrable model
   */ 
  interface PFE_LivrableFieldRefs {
    readonly idPFE: FieldRef<"PFE_Livrable", 'Int'>
    readonly idLivrable: FieldRef<"PFE_Livrable", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PFE_Livrable findUnique
   */
  export type PFE_LivrableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    /**
     * Filter, which PFE_Livrable to fetch.
     */
    where: PFE_LivrableWhereUniqueInput
  }

  /**
   * PFE_Livrable findUniqueOrThrow
   */
  export type PFE_LivrableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    /**
     * Filter, which PFE_Livrable to fetch.
     */
    where: PFE_LivrableWhereUniqueInput
  }

  /**
   * PFE_Livrable findFirst
   */
  export type PFE_LivrableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    /**
     * Filter, which PFE_Livrable to fetch.
     */
    where?: PFE_LivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFE_Livrables to fetch.
     */
    orderBy?: PFE_LivrableOrderByWithRelationInput | PFE_LivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PFE_Livrables.
     */
    cursor?: PFE_LivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFE_Livrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFE_Livrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PFE_Livrables.
     */
    distinct?: PFE_LivrableScalarFieldEnum | PFE_LivrableScalarFieldEnum[]
  }

  /**
   * PFE_Livrable findFirstOrThrow
   */
  export type PFE_LivrableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    /**
     * Filter, which PFE_Livrable to fetch.
     */
    where?: PFE_LivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFE_Livrables to fetch.
     */
    orderBy?: PFE_LivrableOrderByWithRelationInput | PFE_LivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PFE_Livrables.
     */
    cursor?: PFE_LivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFE_Livrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFE_Livrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PFE_Livrables.
     */
    distinct?: PFE_LivrableScalarFieldEnum | PFE_LivrableScalarFieldEnum[]
  }

  /**
   * PFE_Livrable findMany
   */
  export type PFE_LivrableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    /**
     * Filter, which PFE_Livrables to fetch.
     */
    where?: PFE_LivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PFE_Livrables to fetch.
     */
    orderBy?: PFE_LivrableOrderByWithRelationInput | PFE_LivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PFE_Livrables.
     */
    cursor?: PFE_LivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PFE_Livrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PFE_Livrables.
     */
    skip?: number
    distinct?: PFE_LivrableScalarFieldEnum | PFE_LivrableScalarFieldEnum[]
  }

  /**
   * PFE_Livrable create
   */
  export type PFE_LivrableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    /**
     * The data needed to create a PFE_Livrable.
     */
    data: XOR<PFE_LivrableCreateInput, PFE_LivrableUncheckedCreateInput>
  }

  /**
   * PFE_Livrable createMany
   */
  export type PFE_LivrableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PFE_Livrables.
     */
    data: PFE_LivrableCreateManyInput | PFE_LivrableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PFE_Livrable update
   */
  export type PFE_LivrableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    /**
     * The data needed to update a PFE_Livrable.
     */
    data: XOR<PFE_LivrableUpdateInput, PFE_LivrableUncheckedUpdateInput>
    /**
     * Choose, which PFE_Livrable to update.
     */
    where: PFE_LivrableWhereUniqueInput
  }

  /**
   * PFE_Livrable updateMany
   */
  export type PFE_LivrableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PFE_Livrables.
     */
    data: XOR<PFE_LivrableUpdateManyMutationInput, PFE_LivrableUncheckedUpdateManyInput>
    /**
     * Filter which PFE_Livrables to update
     */
    where?: PFE_LivrableWhereInput
    /**
     * Limit how many PFE_Livrables to update.
     */
    limit?: number
  }

  /**
   * PFE_Livrable upsert
   */
  export type PFE_LivrableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    /**
     * The filter to search for the PFE_Livrable to update in case it exists.
     */
    where: PFE_LivrableWhereUniqueInput
    /**
     * In case the PFE_Livrable found by the `where` argument doesn't exist, create a new PFE_Livrable with this data.
     */
    create: XOR<PFE_LivrableCreateInput, PFE_LivrableUncheckedCreateInput>
    /**
     * In case the PFE_Livrable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PFE_LivrableUpdateInput, PFE_LivrableUncheckedUpdateInput>
  }

  /**
   * PFE_Livrable delete
   */
  export type PFE_LivrableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
    /**
     * Filter which PFE_Livrable to delete.
     */
    where: PFE_LivrableWhereUniqueInput
  }

  /**
   * PFE_Livrable deleteMany
   */
  export type PFE_LivrableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PFE_Livrables to delete
     */
    where?: PFE_LivrableWhereInput
    /**
     * Limit how many PFE_Livrables to delete.
     */
    limit?: number
  }

  /**
   * PFE_Livrable without action
   */
  export type PFE_LivrableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PFE_Livrable
     */
    select?: PFE_LivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PFE_Livrable
     */
    omit?: PFE_LivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PFE_LivrableInclude<ExtArgs> | null
  }


  /**
   * Model EncadrantLivrable
   */

  export type AggregateEncadrantLivrable = {
    _count: EncadrantLivrableCountAggregateOutputType | null
    _avg: EncadrantLivrableAvgAggregateOutputType | null
    _sum: EncadrantLivrableSumAggregateOutputType | null
    _min: EncadrantLivrableMinAggregateOutputType | null
    _max: EncadrantLivrableMaxAggregateOutputType | null
  }

  export type EncadrantLivrableAvgAggregateOutputType = {
    idEncadrant: number | null
    idLivrable: number | null
  }

  export type EncadrantLivrableSumAggregateOutputType = {
    idEncadrant: number | null
    idLivrable: number | null
  }

  export type EncadrantLivrableMinAggregateOutputType = {
    idEncadrant: number | null
    idLivrable: number | null
  }

  export type EncadrantLivrableMaxAggregateOutputType = {
    idEncadrant: number | null
    idLivrable: number | null
  }

  export type EncadrantLivrableCountAggregateOutputType = {
    idEncadrant: number
    idLivrable: number
    _all: number
  }


  export type EncadrantLivrableAvgAggregateInputType = {
    idEncadrant?: true
    idLivrable?: true
  }

  export type EncadrantLivrableSumAggregateInputType = {
    idEncadrant?: true
    idLivrable?: true
  }

  export type EncadrantLivrableMinAggregateInputType = {
    idEncadrant?: true
    idLivrable?: true
  }

  export type EncadrantLivrableMaxAggregateInputType = {
    idEncadrant?: true
    idLivrable?: true
  }

  export type EncadrantLivrableCountAggregateInputType = {
    idEncadrant?: true
    idLivrable?: true
    _all?: true
  }

  export type EncadrantLivrableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncadrantLivrable to aggregate.
     */
    where?: EncadrantLivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncadrantLivrables to fetch.
     */
    orderBy?: EncadrantLivrableOrderByWithRelationInput | EncadrantLivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncadrantLivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncadrantLivrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncadrantLivrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncadrantLivrables
    **/
    _count?: true | EncadrantLivrableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncadrantLivrableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncadrantLivrableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncadrantLivrableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncadrantLivrableMaxAggregateInputType
  }

  export type GetEncadrantLivrableAggregateType<T extends EncadrantLivrableAggregateArgs> = {
        [P in keyof T & keyof AggregateEncadrantLivrable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncadrantLivrable[P]>
      : GetScalarType<T[P], AggregateEncadrantLivrable[P]>
  }




  export type EncadrantLivrableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncadrantLivrableWhereInput
    orderBy?: EncadrantLivrableOrderByWithAggregationInput | EncadrantLivrableOrderByWithAggregationInput[]
    by: EncadrantLivrableScalarFieldEnum[] | EncadrantLivrableScalarFieldEnum
    having?: EncadrantLivrableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncadrantLivrableCountAggregateInputType | true
    _avg?: EncadrantLivrableAvgAggregateInputType
    _sum?: EncadrantLivrableSumAggregateInputType
    _min?: EncadrantLivrableMinAggregateInputType
    _max?: EncadrantLivrableMaxAggregateInputType
  }

  export type EncadrantLivrableGroupByOutputType = {
    idEncadrant: number
    idLivrable: number
    _count: EncadrantLivrableCountAggregateOutputType | null
    _avg: EncadrantLivrableAvgAggregateOutputType | null
    _sum: EncadrantLivrableSumAggregateOutputType | null
    _min: EncadrantLivrableMinAggregateOutputType | null
    _max: EncadrantLivrableMaxAggregateOutputType | null
  }

  type GetEncadrantLivrableGroupByPayload<T extends EncadrantLivrableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncadrantLivrableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncadrantLivrableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncadrantLivrableGroupByOutputType[P]>
            : GetScalarType<T[P], EncadrantLivrableGroupByOutputType[P]>
        }
      >
    >


  export type EncadrantLivrableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEncadrant?: boolean
    idLivrable?: boolean
    encadrant?: boolean | EncadrantDefaultArgs<ExtArgs>
    livrable?: boolean | LivrableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encadrantLivrable"]>



  export type EncadrantLivrableSelectScalar = {
    idEncadrant?: boolean
    idLivrable?: boolean
  }

  export type EncadrantLivrableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idEncadrant" | "idLivrable", ExtArgs["result"]["encadrantLivrable"]>
  export type EncadrantLivrableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encadrant?: boolean | EncadrantDefaultArgs<ExtArgs>
    livrable?: boolean | LivrableDefaultArgs<ExtArgs>
  }

  export type $EncadrantLivrablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncadrantLivrable"
    objects: {
      encadrant: Prisma.$EncadrantPayload<ExtArgs>
      livrable: Prisma.$LivrablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idEncadrant: number
      idLivrable: number
    }, ExtArgs["result"]["encadrantLivrable"]>
    composites: {}
  }

  type EncadrantLivrableGetPayload<S extends boolean | null | undefined | EncadrantLivrableDefaultArgs> = $Result.GetResult<Prisma.$EncadrantLivrablePayload, S>

  type EncadrantLivrableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncadrantLivrableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncadrantLivrableCountAggregateInputType | true
    }

  export interface EncadrantLivrableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncadrantLivrable'], meta: { name: 'EncadrantLivrable' } }
    /**
     * Find zero or one EncadrantLivrable that matches the filter.
     * @param {EncadrantLivrableFindUniqueArgs} args - Arguments to find a EncadrantLivrable
     * @example
     * // Get one EncadrantLivrable
     * const encadrantLivrable = await prisma.encadrantLivrable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncadrantLivrableFindUniqueArgs>(args: SelectSubset<T, EncadrantLivrableFindUniqueArgs<ExtArgs>>): Prisma__EncadrantLivrableClient<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EncadrantLivrable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncadrantLivrableFindUniqueOrThrowArgs} args - Arguments to find a EncadrantLivrable
     * @example
     * // Get one EncadrantLivrable
     * const encadrantLivrable = await prisma.encadrantLivrable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncadrantLivrableFindUniqueOrThrowArgs>(args: SelectSubset<T, EncadrantLivrableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncadrantLivrableClient<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EncadrantLivrable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantLivrableFindFirstArgs} args - Arguments to find a EncadrantLivrable
     * @example
     * // Get one EncadrantLivrable
     * const encadrantLivrable = await prisma.encadrantLivrable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncadrantLivrableFindFirstArgs>(args?: SelectSubset<T, EncadrantLivrableFindFirstArgs<ExtArgs>>): Prisma__EncadrantLivrableClient<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EncadrantLivrable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantLivrableFindFirstOrThrowArgs} args - Arguments to find a EncadrantLivrable
     * @example
     * // Get one EncadrantLivrable
     * const encadrantLivrable = await prisma.encadrantLivrable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncadrantLivrableFindFirstOrThrowArgs>(args?: SelectSubset<T, EncadrantLivrableFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncadrantLivrableClient<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EncadrantLivrables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantLivrableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncadrantLivrables
     * const encadrantLivrables = await prisma.encadrantLivrable.findMany()
     * 
     * // Get first 10 EncadrantLivrables
     * const encadrantLivrables = await prisma.encadrantLivrable.findMany({ take: 10 })
     * 
     * // Only select the `idEncadrant`
     * const encadrantLivrableWithIdEncadrantOnly = await prisma.encadrantLivrable.findMany({ select: { idEncadrant: true } })
     * 
     */
    findMany<T extends EncadrantLivrableFindManyArgs>(args?: SelectSubset<T, EncadrantLivrableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EncadrantLivrable.
     * @param {EncadrantLivrableCreateArgs} args - Arguments to create a EncadrantLivrable.
     * @example
     * // Create one EncadrantLivrable
     * const EncadrantLivrable = await prisma.encadrantLivrable.create({
     *   data: {
     *     // ... data to create a EncadrantLivrable
     *   }
     * })
     * 
     */
    create<T extends EncadrantLivrableCreateArgs>(args: SelectSubset<T, EncadrantLivrableCreateArgs<ExtArgs>>): Prisma__EncadrantLivrableClient<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EncadrantLivrables.
     * @param {EncadrantLivrableCreateManyArgs} args - Arguments to create many EncadrantLivrables.
     * @example
     * // Create many EncadrantLivrables
     * const encadrantLivrable = await prisma.encadrantLivrable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncadrantLivrableCreateManyArgs>(args?: SelectSubset<T, EncadrantLivrableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EncadrantLivrable.
     * @param {EncadrantLivrableDeleteArgs} args - Arguments to delete one EncadrantLivrable.
     * @example
     * // Delete one EncadrantLivrable
     * const EncadrantLivrable = await prisma.encadrantLivrable.delete({
     *   where: {
     *     // ... filter to delete one EncadrantLivrable
     *   }
     * })
     * 
     */
    delete<T extends EncadrantLivrableDeleteArgs>(args: SelectSubset<T, EncadrantLivrableDeleteArgs<ExtArgs>>): Prisma__EncadrantLivrableClient<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EncadrantLivrable.
     * @param {EncadrantLivrableUpdateArgs} args - Arguments to update one EncadrantLivrable.
     * @example
     * // Update one EncadrantLivrable
     * const encadrantLivrable = await prisma.encadrantLivrable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncadrantLivrableUpdateArgs>(args: SelectSubset<T, EncadrantLivrableUpdateArgs<ExtArgs>>): Prisma__EncadrantLivrableClient<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EncadrantLivrables.
     * @param {EncadrantLivrableDeleteManyArgs} args - Arguments to filter EncadrantLivrables to delete.
     * @example
     * // Delete a few EncadrantLivrables
     * const { count } = await prisma.encadrantLivrable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncadrantLivrableDeleteManyArgs>(args?: SelectSubset<T, EncadrantLivrableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncadrantLivrables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantLivrableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncadrantLivrables
     * const encadrantLivrable = await prisma.encadrantLivrable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncadrantLivrableUpdateManyArgs>(args: SelectSubset<T, EncadrantLivrableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncadrantLivrable.
     * @param {EncadrantLivrableUpsertArgs} args - Arguments to update or create a EncadrantLivrable.
     * @example
     * // Update or create a EncadrantLivrable
     * const encadrantLivrable = await prisma.encadrantLivrable.upsert({
     *   create: {
     *     // ... data to create a EncadrantLivrable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncadrantLivrable we want to update
     *   }
     * })
     */
    upsert<T extends EncadrantLivrableUpsertArgs>(args: SelectSubset<T, EncadrantLivrableUpsertArgs<ExtArgs>>): Prisma__EncadrantLivrableClient<$Result.GetResult<Prisma.$EncadrantLivrablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EncadrantLivrables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantLivrableCountArgs} args - Arguments to filter EncadrantLivrables to count.
     * @example
     * // Count the number of EncadrantLivrables
     * const count = await prisma.encadrantLivrable.count({
     *   where: {
     *     // ... the filter for the EncadrantLivrables we want to count
     *   }
     * })
    **/
    count<T extends EncadrantLivrableCountArgs>(
      args?: Subset<T, EncadrantLivrableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncadrantLivrableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncadrantLivrable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantLivrableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncadrantLivrableAggregateArgs>(args: Subset<T, EncadrantLivrableAggregateArgs>): Prisma.PrismaPromise<GetEncadrantLivrableAggregateType<T>>

    /**
     * Group by EncadrantLivrable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantLivrableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncadrantLivrableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncadrantLivrableGroupByArgs['orderBy'] }
        : { orderBy?: EncadrantLivrableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncadrantLivrableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncadrantLivrableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncadrantLivrable model
   */
  readonly fields: EncadrantLivrableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncadrantLivrable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncadrantLivrableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encadrant<T extends EncadrantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncadrantDefaultArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    livrable<T extends LivrableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivrableDefaultArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncadrantLivrable model
   */ 
  interface EncadrantLivrableFieldRefs {
    readonly idEncadrant: FieldRef<"EncadrantLivrable", 'Int'>
    readonly idLivrable: FieldRef<"EncadrantLivrable", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EncadrantLivrable findUnique
   */
  export type EncadrantLivrableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    /**
     * Filter, which EncadrantLivrable to fetch.
     */
    where: EncadrantLivrableWhereUniqueInput
  }

  /**
   * EncadrantLivrable findUniqueOrThrow
   */
  export type EncadrantLivrableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    /**
     * Filter, which EncadrantLivrable to fetch.
     */
    where: EncadrantLivrableWhereUniqueInput
  }

  /**
   * EncadrantLivrable findFirst
   */
  export type EncadrantLivrableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    /**
     * Filter, which EncadrantLivrable to fetch.
     */
    where?: EncadrantLivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncadrantLivrables to fetch.
     */
    orderBy?: EncadrantLivrableOrderByWithRelationInput | EncadrantLivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncadrantLivrables.
     */
    cursor?: EncadrantLivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncadrantLivrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncadrantLivrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncadrantLivrables.
     */
    distinct?: EncadrantLivrableScalarFieldEnum | EncadrantLivrableScalarFieldEnum[]
  }

  /**
   * EncadrantLivrable findFirstOrThrow
   */
  export type EncadrantLivrableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    /**
     * Filter, which EncadrantLivrable to fetch.
     */
    where?: EncadrantLivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncadrantLivrables to fetch.
     */
    orderBy?: EncadrantLivrableOrderByWithRelationInput | EncadrantLivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncadrantLivrables.
     */
    cursor?: EncadrantLivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncadrantLivrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncadrantLivrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncadrantLivrables.
     */
    distinct?: EncadrantLivrableScalarFieldEnum | EncadrantLivrableScalarFieldEnum[]
  }

  /**
   * EncadrantLivrable findMany
   */
  export type EncadrantLivrableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    /**
     * Filter, which EncadrantLivrables to fetch.
     */
    where?: EncadrantLivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncadrantLivrables to fetch.
     */
    orderBy?: EncadrantLivrableOrderByWithRelationInput | EncadrantLivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncadrantLivrables.
     */
    cursor?: EncadrantLivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncadrantLivrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncadrantLivrables.
     */
    skip?: number
    distinct?: EncadrantLivrableScalarFieldEnum | EncadrantLivrableScalarFieldEnum[]
  }

  /**
   * EncadrantLivrable create
   */
  export type EncadrantLivrableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    /**
     * The data needed to create a EncadrantLivrable.
     */
    data: XOR<EncadrantLivrableCreateInput, EncadrantLivrableUncheckedCreateInput>
  }

  /**
   * EncadrantLivrable createMany
   */
  export type EncadrantLivrableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncadrantLivrables.
     */
    data: EncadrantLivrableCreateManyInput | EncadrantLivrableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncadrantLivrable update
   */
  export type EncadrantLivrableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    /**
     * The data needed to update a EncadrantLivrable.
     */
    data: XOR<EncadrantLivrableUpdateInput, EncadrantLivrableUncheckedUpdateInput>
    /**
     * Choose, which EncadrantLivrable to update.
     */
    where: EncadrantLivrableWhereUniqueInput
  }

  /**
   * EncadrantLivrable updateMany
   */
  export type EncadrantLivrableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncadrantLivrables.
     */
    data: XOR<EncadrantLivrableUpdateManyMutationInput, EncadrantLivrableUncheckedUpdateManyInput>
    /**
     * Filter which EncadrantLivrables to update
     */
    where?: EncadrantLivrableWhereInput
    /**
     * Limit how many EncadrantLivrables to update.
     */
    limit?: number
  }

  /**
   * EncadrantLivrable upsert
   */
  export type EncadrantLivrableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    /**
     * The filter to search for the EncadrantLivrable to update in case it exists.
     */
    where: EncadrantLivrableWhereUniqueInput
    /**
     * In case the EncadrantLivrable found by the `where` argument doesn't exist, create a new EncadrantLivrable with this data.
     */
    create: XOR<EncadrantLivrableCreateInput, EncadrantLivrableUncheckedCreateInput>
    /**
     * In case the EncadrantLivrable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncadrantLivrableUpdateInput, EncadrantLivrableUncheckedUpdateInput>
  }

  /**
   * EncadrantLivrable delete
   */
  export type EncadrantLivrableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
    /**
     * Filter which EncadrantLivrable to delete.
     */
    where: EncadrantLivrableWhereUniqueInput
  }

  /**
   * EncadrantLivrable deleteMany
   */
  export type EncadrantLivrableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncadrantLivrables to delete
     */
    where?: EncadrantLivrableWhereInput
    /**
     * Limit how many EncadrantLivrables to delete.
     */
    limit?: number
  }

  /**
   * EncadrantLivrable without action
   */
  export type EncadrantLivrableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantLivrable
     */
    select?: EncadrantLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantLivrable
     */
    omit?: EncadrantLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantLivrableInclude<ExtArgs> | null
  }


  /**
   * Model TuteurLivrable
   */

  export type AggregateTuteurLivrable = {
    _count: TuteurLivrableCountAggregateOutputType | null
    _avg: TuteurLivrableAvgAggregateOutputType | null
    _sum: TuteurLivrableSumAggregateOutputType | null
    _min: TuteurLivrableMinAggregateOutputType | null
    _max: TuteurLivrableMaxAggregateOutputType | null
  }

  export type TuteurLivrableAvgAggregateOutputType = {
    idTuteur: number | null
    idLivrable: number | null
  }

  export type TuteurLivrableSumAggregateOutputType = {
    idTuteur: number | null
    idLivrable: number | null
  }

  export type TuteurLivrableMinAggregateOutputType = {
    idTuteur: number | null
    idLivrable: number | null
  }

  export type TuteurLivrableMaxAggregateOutputType = {
    idTuteur: number | null
    idLivrable: number | null
  }

  export type TuteurLivrableCountAggregateOutputType = {
    idTuteur: number
    idLivrable: number
    _all: number
  }


  export type TuteurLivrableAvgAggregateInputType = {
    idTuteur?: true
    idLivrable?: true
  }

  export type TuteurLivrableSumAggregateInputType = {
    idTuteur?: true
    idLivrable?: true
  }

  export type TuteurLivrableMinAggregateInputType = {
    idTuteur?: true
    idLivrable?: true
  }

  export type TuteurLivrableMaxAggregateInputType = {
    idTuteur?: true
    idLivrable?: true
  }

  export type TuteurLivrableCountAggregateInputType = {
    idTuteur?: true
    idLivrable?: true
    _all?: true
  }

  export type TuteurLivrableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TuteurLivrable to aggregate.
     */
    where?: TuteurLivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TuteurLivrables to fetch.
     */
    orderBy?: TuteurLivrableOrderByWithRelationInput | TuteurLivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TuteurLivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TuteurLivrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TuteurLivrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TuteurLivrables
    **/
    _count?: true | TuteurLivrableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TuteurLivrableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TuteurLivrableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TuteurLivrableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TuteurLivrableMaxAggregateInputType
  }

  export type GetTuteurLivrableAggregateType<T extends TuteurLivrableAggregateArgs> = {
        [P in keyof T & keyof AggregateTuteurLivrable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTuteurLivrable[P]>
      : GetScalarType<T[P], AggregateTuteurLivrable[P]>
  }




  export type TuteurLivrableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TuteurLivrableWhereInput
    orderBy?: TuteurLivrableOrderByWithAggregationInput | TuteurLivrableOrderByWithAggregationInput[]
    by: TuteurLivrableScalarFieldEnum[] | TuteurLivrableScalarFieldEnum
    having?: TuteurLivrableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TuteurLivrableCountAggregateInputType | true
    _avg?: TuteurLivrableAvgAggregateInputType
    _sum?: TuteurLivrableSumAggregateInputType
    _min?: TuteurLivrableMinAggregateInputType
    _max?: TuteurLivrableMaxAggregateInputType
  }

  export type TuteurLivrableGroupByOutputType = {
    idTuteur: number
    idLivrable: number
    _count: TuteurLivrableCountAggregateOutputType | null
    _avg: TuteurLivrableAvgAggregateOutputType | null
    _sum: TuteurLivrableSumAggregateOutputType | null
    _min: TuteurLivrableMinAggregateOutputType | null
    _max: TuteurLivrableMaxAggregateOutputType | null
  }

  type GetTuteurLivrableGroupByPayload<T extends TuteurLivrableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TuteurLivrableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TuteurLivrableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TuteurLivrableGroupByOutputType[P]>
            : GetScalarType<T[P], TuteurLivrableGroupByOutputType[P]>
        }
      >
    >


  export type TuteurLivrableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idTuteur?: boolean
    idLivrable?: boolean
    tuteur?: boolean | TuteurDefaultArgs<ExtArgs>
    livrable?: boolean | LivrableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tuteurLivrable"]>



  export type TuteurLivrableSelectScalar = {
    idTuteur?: boolean
    idLivrable?: boolean
  }

  export type TuteurLivrableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idTuteur" | "idLivrable", ExtArgs["result"]["tuteurLivrable"]>
  export type TuteurLivrableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tuteur?: boolean | TuteurDefaultArgs<ExtArgs>
    livrable?: boolean | LivrableDefaultArgs<ExtArgs>
  }

  export type $TuteurLivrablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TuteurLivrable"
    objects: {
      tuteur: Prisma.$TuteurPayload<ExtArgs>
      livrable: Prisma.$LivrablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idTuteur: number
      idLivrable: number
    }, ExtArgs["result"]["tuteurLivrable"]>
    composites: {}
  }

  type TuteurLivrableGetPayload<S extends boolean | null | undefined | TuteurLivrableDefaultArgs> = $Result.GetResult<Prisma.$TuteurLivrablePayload, S>

  type TuteurLivrableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TuteurLivrableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TuteurLivrableCountAggregateInputType | true
    }

  export interface TuteurLivrableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TuteurLivrable'], meta: { name: 'TuteurLivrable' } }
    /**
     * Find zero or one TuteurLivrable that matches the filter.
     * @param {TuteurLivrableFindUniqueArgs} args - Arguments to find a TuteurLivrable
     * @example
     * // Get one TuteurLivrable
     * const tuteurLivrable = await prisma.tuteurLivrable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TuteurLivrableFindUniqueArgs>(args: SelectSubset<T, TuteurLivrableFindUniqueArgs<ExtArgs>>): Prisma__TuteurLivrableClient<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TuteurLivrable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TuteurLivrableFindUniqueOrThrowArgs} args - Arguments to find a TuteurLivrable
     * @example
     * // Get one TuteurLivrable
     * const tuteurLivrable = await prisma.tuteurLivrable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TuteurLivrableFindUniqueOrThrowArgs>(args: SelectSubset<T, TuteurLivrableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TuteurLivrableClient<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TuteurLivrable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurLivrableFindFirstArgs} args - Arguments to find a TuteurLivrable
     * @example
     * // Get one TuteurLivrable
     * const tuteurLivrable = await prisma.tuteurLivrable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TuteurLivrableFindFirstArgs>(args?: SelectSubset<T, TuteurLivrableFindFirstArgs<ExtArgs>>): Prisma__TuteurLivrableClient<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TuteurLivrable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurLivrableFindFirstOrThrowArgs} args - Arguments to find a TuteurLivrable
     * @example
     * // Get one TuteurLivrable
     * const tuteurLivrable = await prisma.tuteurLivrable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TuteurLivrableFindFirstOrThrowArgs>(args?: SelectSubset<T, TuteurLivrableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TuteurLivrableClient<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TuteurLivrables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurLivrableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TuteurLivrables
     * const tuteurLivrables = await prisma.tuteurLivrable.findMany()
     * 
     * // Get first 10 TuteurLivrables
     * const tuteurLivrables = await prisma.tuteurLivrable.findMany({ take: 10 })
     * 
     * // Only select the `idTuteur`
     * const tuteurLivrableWithIdTuteurOnly = await prisma.tuteurLivrable.findMany({ select: { idTuteur: true } })
     * 
     */
    findMany<T extends TuteurLivrableFindManyArgs>(args?: SelectSubset<T, TuteurLivrableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TuteurLivrable.
     * @param {TuteurLivrableCreateArgs} args - Arguments to create a TuteurLivrable.
     * @example
     * // Create one TuteurLivrable
     * const TuteurLivrable = await prisma.tuteurLivrable.create({
     *   data: {
     *     // ... data to create a TuteurLivrable
     *   }
     * })
     * 
     */
    create<T extends TuteurLivrableCreateArgs>(args: SelectSubset<T, TuteurLivrableCreateArgs<ExtArgs>>): Prisma__TuteurLivrableClient<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TuteurLivrables.
     * @param {TuteurLivrableCreateManyArgs} args - Arguments to create many TuteurLivrables.
     * @example
     * // Create many TuteurLivrables
     * const tuteurLivrable = await prisma.tuteurLivrable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TuteurLivrableCreateManyArgs>(args?: SelectSubset<T, TuteurLivrableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TuteurLivrable.
     * @param {TuteurLivrableDeleteArgs} args - Arguments to delete one TuteurLivrable.
     * @example
     * // Delete one TuteurLivrable
     * const TuteurLivrable = await prisma.tuteurLivrable.delete({
     *   where: {
     *     // ... filter to delete one TuteurLivrable
     *   }
     * })
     * 
     */
    delete<T extends TuteurLivrableDeleteArgs>(args: SelectSubset<T, TuteurLivrableDeleteArgs<ExtArgs>>): Prisma__TuteurLivrableClient<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TuteurLivrable.
     * @param {TuteurLivrableUpdateArgs} args - Arguments to update one TuteurLivrable.
     * @example
     * // Update one TuteurLivrable
     * const tuteurLivrable = await prisma.tuteurLivrable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TuteurLivrableUpdateArgs>(args: SelectSubset<T, TuteurLivrableUpdateArgs<ExtArgs>>): Prisma__TuteurLivrableClient<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TuteurLivrables.
     * @param {TuteurLivrableDeleteManyArgs} args - Arguments to filter TuteurLivrables to delete.
     * @example
     * // Delete a few TuteurLivrables
     * const { count } = await prisma.tuteurLivrable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TuteurLivrableDeleteManyArgs>(args?: SelectSubset<T, TuteurLivrableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TuteurLivrables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurLivrableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TuteurLivrables
     * const tuteurLivrable = await prisma.tuteurLivrable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TuteurLivrableUpdateManyArgs>(args: SelectSubset<T, TuteurLivrableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TuteurLivrable.
     * @param {TuteurLivrableUpsertArgs} args - Arguments to update or create a TuteurLivrable.
     * @example
     * // Update or create a TuteurLivrable
     * const tuteurLivrable = await prisma.tuteurLivrable.upsert({
     *   create: {
     *     // ... data to create a TuteurLivrable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TuteurLivrable we want to update
     *   }
     * })
     */
    upsert<T extends TuteurLivrableUpsertArgs>(args: SelectSubset<T, TuteurLivrableUpsertArgs<ExtArgs>>): Prisma__TuteurLivrableClient<$Result.GetResult<Prisma.$TuteurLivrablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TuteurLivrables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurLivrableCountArgs} args - Arguments to filter TuteurLivrables to count.
     * @example
     * // Count the number of TuteurLivrables
     * const count = await prisma.tuteurLivrable.count({
     *   where: {
     *     // ... the filter for the TuteurLivrables we want to count
     *   }
     * })
    **/
    count<T extends TuteurLivrableCountArgs>(
      args?: Subset<T, TuteurLivrableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TuteurLivrableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TuteurLivrable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurLivrableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TuteurLivrableAggregateArgs>(args: Subset<T, TuteurLivrableAggregateArgs>): Prisma.PrismaPromise<GetTuteurLivrableAggregateType<T>>

    /**
     * Group by TuteurLivrable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuteurLivrableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TuteurLivrableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TuteurLivrableGroupByArgs['orderBy'] }
        : { orderBy?: TuteurLivrableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TuteurLivrableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTuteurLivrableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TuteurLivrable model
   */
  readonly fields: TuteurLivrableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TuteurLivrable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TuteurLivrableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tuteur<T extends TuteurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TuteurDefaultArgs<ExtArgs>>): Prisma__TuteurClient<$Result.GetResult<Prisma.$TuteurPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    livrable<T extends LivrableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivrableDefaultArgs<ExtArgs>>): Prisma__LivrableClient<$Result.GetResult<Prisma.$LivrablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TuteurLivrable model
   */ 
  interface TuteurLivrableFieldRefs {
    readonly idTuteur: FieldRef<"TuteurLivrable", 'Int'>
    readonly idLivrable: FieldRef<"TuteurLivrable", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TuteurLivrable findUnique
   */
  export type TuteurLivrableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    /**
     * Filter, which TuteurLivrable to fetch.
     */
    where: TuteurLivrableWhereUniqueInput
  }

  /**
   * TuteurLivrable findUniqueOrThrow
   */
  export type TuteurLivrableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    /**
     * Filter, which TuteurLivrable to fetch.
     */
    where: TuteurLivrableWhereUniqueInput
  }

  /**
   * TuteurLivrable findFirst
   */
  export type TuteurLivrableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    /**
     * Filter, which TuteurLivrable to fetch.
     */
    where?: TuteurLivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TuteurLivrables to fetch.
     */
    orderBy?: TuteurLivrableOrderByWithRelationInput | TuteurLivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TuteurLivrables.
     */
    cursor?: TuteurLivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TuteurLivrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TuteurLivrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TuteurLivrables.
     */
    distinct?: TuteurLivrableScalarFieldEnum | TuteurLivrableScalarFieldEnum[]
  }

  /**
   * TuteurLivrable findFirstOrThrow
   */
  export type TuteurLivrableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    /**
     * Filter, which TuteurLivrable to fetch.
     */
    where?: TuteurLivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TuteurLivrables to fetch.
     */
    orderBy?: TuteurLivrableOrderByWithRelationInput | TuteurLivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TuteurLivrables.
     */
    cursor?: TuteurLivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TuteurLivrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TuteurLivrables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TuteurLivrables.
     */
    distinct?: TuteurLivrableScalarFieldEnum | TuteurLivrableScalarFieldEnum[]
  }

  /**
   * TuteurLivrable findMany
   */
  export type TuteurLivrableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    /**
     * Filter, which TuteurLivrables to fetch.
     */
    where?: TuteurLivrableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TuteurLivrables to fetch.
     */
    orderBy?: TuteurLivrableOrderByWithRelationInput | TuteurLivrableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TuteurLivrables.
     */
    cursor?: TuteurLivrableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TuteurLivrables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TuteurLivrables.
     */
    skip?: number
    distinct?: TuteurLivrableScalarFieldEnum | TuteurLivrableScalarFieldEnum[]
  }

  /**
   * TuteurLivrable create
   */
  export type TuteurLivrableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    /**
     * The data needed to create a TuteurLivrable.
     */
    data: XOR<TuteurLivrableCreateInput, TuteurLivrableUncheckedCreateInput>
  }

  /**
   * TuteurLivrable createMany
   */
  export type TuteurLivrableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TuteurLivrables.
     */
    data: TuteurLivrableCreateManyInput | TuteurLivrableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TuteurLivrable update
   */
  export type TuteurLivrableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    /**
     * The data needed to update a TuteurLivrable.
     */
    data: XOR<TuteurLivrableUpdateInput, TuteurLivrableUncheckedUpdateInput>
    /**
     * Choose, which TuteurLivrable to update.
     */
    where: TuteurLivrableWhereUniqueInput
  }

  /**
   * TuteurLivrable updateMany
   */
  export type TuteurLivrableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TuteurLivrables.
     */
    data: XOR<TuteurLivrableUpdateManyMutationInput, TuteurLivrableUncheckedUpdateManyInput>
    /**
     * Filter which TuteurLivrables to update
     */
    where?: TuteurLivrableWhereInput
    /**
     * Limit how many TuteurLivrables to update.
     */
    limit?: number
  }

  /**
   * TuteurLivrable upsert
   */
  export type TuteurLivrableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    /**
     * The filter to search for the TuteurLivrable to update in case it exists.
     */
    where: TuteurLivrableWhereUniqueInput
    /**
     * In case the TuteurLivrable found by the `where` argument doesn't exist, create a new TuteurLivrable with this data.
     */
    create: XOR<TuteurLivrableCreateInput, TuteurLivrableUncheckedCreateInput>
    /**
     * In case the TuteurLivrable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TuteurLivrableUpdateInput, TuteurLivrableUncheckedUpdateInput>
  }

  /**
   * TuteurLivrable delete
   */
  export type TuteurLivrableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
    /**
     * Filter which TuteurLivrable to delete.
     */
    where: TuteurLivrableWhereUniqueInput
  }

  /**
   * TuteurLivrable deleteMany
   */
  export type TuteurLivrableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TuteurLivrables to delete
     */
    where?: TuteurLivrableWhereInput
    /**
     * Limit how many TuteurLivrables to delete.
     */
    limit?: number
  }

  /**
   * TuteurLivrable without action
   */
  export type TuteurLivrableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuteurLivrable
     */
    select?: TuteurLivrableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TuteurLivrable
     */
    omit?: TuteurLivrableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuteurLivrableInclude<ExtArgs> | null
  }


  /**
   * Model EncadrantSoutenance
   */

  export type AggregateEncadrantSoutenance = {
    _count: EncadrantSoutenanceCountAggregateOutputType | null
    _avg: EncadrantSoutenanceAvgAggregateOutputType | null
    _sum: EncadrantSoutenanceSumAggregateOutputType | null
    _min: EncadrantSoutenanceMinAggregateOutputType | null
    _max: EncadrantSoutenanceMaxAggregateOutputType | null
  }

  export type EncadrantSoutenanceAvgAggregateOutputType = {
    idEncadrant: number | null
    idSoutenance: number | null
  }

  export type EncadrantSoutenanceSumAggregateOutputType = {
    idEncadrant: number | null
    idSoutenance: number | null
  }

  export type EncadrantSoutenanceMinAggregateOutputType = {
    idEncadrant: number | null
    idSoutenance: number | null
  }

  export type EncadrantSoutenanceMaxAggregateOutputType = {
    idEncadrant: number | null
    idSoutenance: number | null
  }

  export type EncadrantSoutenanceCountAggregateOutputType = {
    idEncadrant: number
    idSoutenance: number
    _all: number
  }


  export type EncadrantSoutenanceAvgAggregateInputType = {
    idEncadrant?: true
    idSoutenance?: true
  }

  export type EncadrantSoutenanceSumAggregateInputType = {
    idEncadrant?: true
    idSoutenance?: true
  }

  export type EncadrantSoutenanceMinAggregateInputType = {
    idEncadrant?: true
    idSoutenance?: true
  }

  export type EncadrantSoutenanceMaxAggregateInputType = {
    idEncadrant?: true
    idSoutenance?: true
  }

  export type EncadrantSoutenanceCountAggregateInputType = {
    idEncadrant?: true
    idSoutenance?: true
    _all?: true
  }

  export type EncadrantSoutenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncadrantSoutenance to aggregate.
     */
    where?: EncadrantSoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncadrantSoutenances to fetch.
     */
    orderBy?: EncadrantSoutenanceOrderByWithRelationInput | EncadrantSoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncadrantSoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncadrantSoutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncadrantSoutenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncadrantSoutenances
    **/
    _count?: true | EncadrantSoutenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncadrantSoutenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncadrantSoutenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncadrantSoutenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncadrantSoutenanceMaxAggregateInputType
  }

  export type GetEncadrantSoutenanceAggregateType<T extends EncadrantSoutenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateEncadrantSoutenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncadrantSoutenance[P]>
      : GetScalarType<T[P], AggregateEncadrantSoutenance[P]>
  }




  export type EncadrantSoutenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncadrantSoutenanceWhereInput
    orderBy?: EncadrantSoutenanceOrderByWithAggregationInput | EncadrantSoutenanceOrderByWithAggregationInput[]
    by: EncadrantSoutenanceScalarFieldEnum[] | EncadrantSoutenanceScalarFieldEnum
    having?: EncadrantSoutenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncadrantSoutenanceCountAggregateInputType | true
    _avg?: EncadrantSoutenanceAvgAggregateInputType
    _sum?: EncadrantSoutenanceSumAggregateInputType
    _min?: EncadrantSoutenanceMinAggregateInputType
    _max?: EncadrantSoutenanceMaxAggregateInputType
  }

  export type EncadrantSoutenanceGroupByOutputType = {
    idEncadrant: number
    idSoutenance: number
    _count: EncadrantSoutenanceCountAggregateOutputType | null
    _avg: EncadrantSoutenanceAvgAggregateOutputType | null
    _sum: EncadrantSoutenanceSumAggregateOutputType | null
    _min: EncadrantSoutenanceMinAggregateOutputType | null
    _max: EncadrantSoutenanceMaxAggregateOutputType | null
  }

  type GetEncadrantSoutenanceGroupByPayload<T extends EncadrantSoutenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncadrantSoutenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncadrantSoutenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncadrantSoutenanceGroupByOutputType[P]>
            : GetScalarType<T[P], EncadrantSoutenanceGroupByOutputType[P]>
        }
      >
    >


  export type EncadrantSoutenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEncadrant?: boolean
    idSoutenance?: boolean
    encadrant?: boolean | EncadrantDefaultArgs<ExtArgs>
    soutenance?: boolean | SoutenanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encadrantSoutenance"]>



  export type EncadrantSoutenanceSelectScalar = {
    idEncadrant?: boolean
    idSoutenance?: boolean
  }

  export type EncadrantSoutenanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idEncadrant" | "idSoutenance", ExtArgs["result"]["encadrantSoutenance"]>
  export type EncadrantSoutenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encadrant?: boolean | EncadrantDefaultArgs<ExtArgs>
    soutenance?: boolean | SoutenanceDefaultArgs<ExtArgs>
  }

  export type $EncadrantSoutenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncadrantSoutenance"
    objects: {
      encadrant: Prisma.$EncadrantPayload<ExtArgs>
      soutenance: Prisma.$SoutenancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idEncadrant: number
      idSoutenance: number
    }, ExtArgs["result"]["encadrantSoutenance"]>
    composites: {}
  }

  type EncadrantSoutenanceGetPayload<S extends boolean | null | undefined | EncadrantSoutenanceDefaultArgs> = $Result.GetResult<Prisma.$EncadrantSoutenancePayload, S>

  type EncadrantSoutenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncadrantSoutenanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncadrantSoutenanceCountAggregateInputType | true
    }

  export interface EncadrantSoutenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncadrantSoutenance'], meta: { name: 'EncadrantSoutenance' } }
    /**
     * Find zero or one EncadrantSoutenance that matches the filter.
     * @param {EncadrantSoutenanceFindUniqueArgs} args - Arguments to find a EncadrantSoutenance
     * @example
     * // Get one EncadrantSoutenance
     * const encadrantSoutenance = await prisma.encadrantSoutenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncadrantSoutenanceFindUniqueArgs>(args: SelectSubset<T, EncadrantSoutenanceFindUniqueArgs<ExtArgs>>): Prisma__EncadrantSoutenanceClient<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EncadrantSoutenance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncadrantSoutenanceFindUniqueOrThrowArgs} args - Arguments to find a EncadrantSoutenance
     * @example
     * // Get one EncadrantSoutenance
     * const encadrantSoutenance = await prisma.encadrantSoutenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncadrantSoutenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, EncadrantSoutenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncadrantSoutenanceClient<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EncadrantSoutenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantSoutenanceFindFirstArgs} args - Arguments to find a EncadrantSoutenance
     * @example
     * // Get one EncadrantSoutenance
     * const encadrantSoutenance = await prisma.encadrantSoutenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncadrantSoutenanceFindFirstArgs>(args?: SelectSubset<T, EncadrantSoutenanceFindFirstArgs<ExtArgs>>): Prisma__EncadrantSoutenanceClient<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EncadrantSoutenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantSoutenanceFindFirstOrThrowArgs} args - Arguments to find a EncadrantSoutenance
     * @example
     * // Get one EncadrantSoutenance
     * const encadrantSoutenance = await prisma.encadrantSoutenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncadrantSoutenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, EncadrantSoutenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncadrantSoutenanceClient<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EncadrantSoutenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantSoutenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncadrantSoutenances
     * const encadrantSoutenances = await prisma.encadrantSoutenance.findMany()
     * 
     * // Get first 10 EncadrantSoutenances
     * const encadrantSoutenances = await prisma.encadrantSoutenance.findMany({ take: 10 })
     * 
     * // Only select the `idEncadrant`
     * const encadrantSoutenanceWithIdEncadrantOnly = await prisma.encadrantSoutenance.findMany({ select: { idEncadrant: true } })
     * 
     */
    findMany<T extends EncadrantSoutenanceFindManyArgs>(args?: SelectSubset<T, EncadrantSoutenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EncadrantSoutenance.
     * @param {EncadrantSoutenanceCreateArgs} args - Arguments to create a EncadrantSoutenance.
     * @example
     * // Create one EncadrantSoutenance
     * const EncadrantSoutenance = await prisma.encadrantSoutenance.create({
     *   data: {
     *     // ... data to create a EncadrantSoutenance
     *   }
     * })
     * 
     */
    create<T extends EncadrantSoutenanceCreateArgs>(args: SelectSubset<T, EncadrantSoutenanceCreateArgs<ExtArgs>>): Prisma__EncadrantSoutenanceClient<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EncadrantSoutenances.
     * @param {EncadrantSoutenanceCreateManyArgs} args - Arguments to create many EncadrantSoutenances.
     * @example
     * // Create many EncadrantSoutenances
     * const encadrantSoutenance = await prisma.encadrantSoutenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncadrantSoutenanceCreateManyArgs>(args?: SelectSubset<T, EncadrantSoutenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EncadrantSoutenance.
     * @param {EncadrantSoutenanceDeleteArgs} args - Arguments to delete one EncadrantSoutenance.
     * @example
     * // Delete one EncadrantSoutenance
     * const EncadrantSoutenance = await prisma.encadrantSoutenance.delete({
     *   where: {
     *     // ... filter to delete one EncadrantSoutenance
     *   }
     * })
     * 
     */
    delete<T extends EncadrantSoutenanceDeleteArgs>(args: SelectSubset<T, EncadrantSoutenanceDeleteArgs<ExtArgs>>): Prisma__EncadrantSoutenanceClient<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EncadrantSoutenance.
     * @param {EncadrantSoutenanceUpdateArgs} args - Arguments to update one EncadrantSoutenance.
     * @example
     * // Update one EncadrantSoutenance
     * const encadrantSoutenance = await prisma.encadrantSoutenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncadrantSoutenanceUpdateArgs>(args: SelectSubset<T, EncadrantSoutenanceUpdateArgs<ExtArgs>>): Prisma__EncadrantSoutenanceClient<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EncadrantSoutenances.
     * @param {EncadrantSoutenanceDeleteManyArgs} args - Arguments to filter EncadrantSoutenances to delete.
     * @example
     * // Delete a few EncadrantSoutenances
     * const { count } = await prisma.encadrantSoutenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncadrantSoutenanceDeleteManyArgs>(args?: SelectSubset<T, EncadrantSoutenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncadrantSoutenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantSoutenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncadrantSoutenances
     * const encadrantSoutenance = await prisma.encadrantSoutenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncadrantSoutenanceUpdateManyArgs>(args: SelectSubset<T, EncadrantSoutenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncadrantSoutenance.
     * @param {EncadrantSoutenanceUpsertArgs} args - Arguments to update or create a EncadrantSoutenance.
     * @example
     * // Update or create a EncadrantSoutenance
     * const encadrantSoutenance = await prisma.encadrantSoutenance.upsert({
     *   create: {
     *     // ... data to create a EncadrantSoutenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncadrantSoutenance we want to update
     *   }
     * })
     */
    upsert<T extends EncadrantSoutenanceUpsertArgs>(args: SelectSubset<T, EncadrantSoutenanceUpsertArgs<ExtArgs>>): Prisma__EncadrantSoutenanceClient<$Result.GetResult<Prisma.$EncadrantSoutenancePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EncadrantSoutenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantSoutenanceCountArgs} args - Arguments to filter EncadrantSoutenances to count.
     * @example
     * // Count the number of EncadrantSoutenances
     * const count = await prisma.encadrantSoutenance.count({
     *   where: {
     *     // ... the filter for the EncadrantSoutenances we want to count
     *   }
     * })
    **/
    count<T extends EncadrantSoutenanceCountArgs>(
      args?: Subset<T, EncadrantSoutenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncadrantSoutenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncadrantSoutenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantSoutenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncadrantSoutenanceAggregateArgs>(args: Subset<T, EncadrantSoutenanceAggregateArgs>): Prisma.PrismaPromise<GetEncadrantSoutenanceAggregateType<T>>

    /**
     * Group by EncadrantSoutenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadrantSoutenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncadrantSoutenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncadrantSoutenanceGroupByArgs['orderBy'] }
        : { orderBy?: EncadrantSoutenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncadrantSoutenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncadrantSoutenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncadrantSoutenance model
   */
  readonly fields: EncadrantSoutenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncadrantSoutenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncadrantSoutenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encadrant<T extends EncadrantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncadrantDefaultArgs<ExtArgs>>): Prisma__EncadrantClient<$Result.GetResult<Prisma.$EncadrantPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    soutenance<T extends SoutenanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SoutenanceDefaultArgs<ExtArgs>>): Prisma__SoutenanceClient<$Result.GetResult<Prisma.$SoutenancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncadrantSoutenance model
   */ 
  interface EncadrantSoutenanceFieldRefs {
    readonly idEncadrant: FieldRef<"EncadrantSoutenance", 'Int'>
    readonly idSoutenance: FieldRef<"EncadrantSoutenance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EncadrantSoutenance findUnique
   */
  export type EncadrantSoutenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which EncadrantSoutenance to fetch.
     */
    where: EncadrantSoutenanceWhereUniqueInput
  }

  /**
   * EncadrantSoutenance findUniqueOrThrow
   */
  export type EncadrantSoutenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which EncadrantSoutenance to fetch.
     */
    where: EncadrantSoutenanceWhereUniqueInput
  }

  /**
   * EncadrantSoutenance findFirst
   */
  export type EncadrantSoutenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which EncadrantSoutenance to fetch.
     */
    where?: EncadrantSoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncadrantSoutenances to fetch.
     */
    orderBy?: EncadrantSoutenanceOrderByWithRelationInput | EncadrantSoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncadrantSoutenances.
     */
    cursor?: EncadrantSoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncadrantSoutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncadrantSoutenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncadrantSoutenances.
     */
    distinct?: EncadrantSoutenanceScalarFieldEnum | EncadrantSoutenanceScalarFieldEnum[]
  }

  /**
   * EncadrantSoutenance findFirstOrThrow
   */
  export type EncadrantSoutenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which EncadrantSoutenance to fetch.
     */
    where?: EncadrantSoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncadrantSoutenances to fetch.
     */
    orderBy?: EncadrantSoutenanceOrderByWithRelationInput | EncadrantSoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncadrantSoutenances.
     */
    cursor?: EncadrantSoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncadrantSoutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncadrantSoutenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncadrantSoutenances.
     */
    distinct?: EncadrantSoutenanceScalarFieldEnum | EncadrantSoutenanceScalarFieldEnum[]
  }

  /**
   * EncadrantSoutenance findMany
   */
  export type EncadrantSoutenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    /**
     * Filter, which EncadrantSoutenances to fetch.
     */
    where?: EncadrantSoutenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncadrantSoutenances to fetch.
     */
    orderBy?: EncadrantSoutenanceOrderByWithRelationInput | EncadrantSoutenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncadrantSoutenances.
     */
    cursor?: EncadrantSoutenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncadrantSoutenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncadrantSoutenances.
     */
    skip?: number
    distinct?: EncadrantSoutenanceScalarFieldEnum | EncadrantSoutenanceScalarFieldEnum[]
  }

  /**
   * EncadrantSoutenance create
   */
  export type EncadrantSoutenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a EncadrantSoutenance.
     */
    data: XOR<EncadrantSoutenanceCreateInput, EncadrantSoutenanceUncheckedCreateInput>
  }

  /**
   * EncadrantSoutenance createMany
   */
  export type EncadrantSoutenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncadrantSoutenances.
     */
    data: EncadrantSoutenanceCreateManyInput | EncadrantSoutenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncadrantSoutenance update
   */
  export type EncadrantSoutenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a EncadrantSoutenance.
     */
    data: XOR<EncadrantSoutenanceUpdateInput, EncadrantSoutenanceUncheckedUpdateInput>
    /**
     * Choose, which EncadrantSoutenance to update.
     */
    where: EncadrantSoutenanceWhereUniqueInput
  }

  /**
   * EncadrantSoutenance updateMany
   */
  export type EncadrantSoutenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncadrantSoutenances.
     */
    data: XOR<EncadrantSoutenanceUpdateManyMutationInput, EncadrantSoutenanceUncheckedUpdateManyInput>
    /**
     * Filter which EncadrantSoutenances to update
     */
    where?: EncadrantSoutenanceWhereInput
    /**
     * Limit how many EncadrantSoutenances to update.
     */
    limit?: number
  }

  /**
   * EncadrantSoutenance upsert
   */
  export type EncadrantSoutenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the EncadrantSoutenance to update in case it exists.
     */
    where: EncadrantSoutenanceWhereUniqueInput
    /**
     * In case the EncadrantSoutenance found by the `where` argument doesn't exist, create a new EncadrantSoutenance with this data.
     */
    create: XOR<EncadrantSoutenanceCreateInput, EncadrantSoutenanceUncheckedCreateInput>
    /**
     * In case the EncadrantSoutenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncadrantSoutenanceUpdateInput, EncadrantSoutenanceUncheckedUpdateInput>
  }

  /**
   * EncadrantSoutenance delete
   */
  export type EncadrantSoutenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
    /**
     * Filter which EncadrantSoutenance to delete.
     */
    where: EncadrantSoutenanceWhereUniqueInput
  }

  /**
   * EncadrantSoutenance deleteMany
   */
  export type EncadrantSoutenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncadrantSoutenances to delete
     */
    where?: EncadrantSoutenanceWhereInput
    /**
     * Limit how many EncadrantSoutenances to delete.
     */
    limit?: number
  }

  /**
   * EncadrantSoutenance without action
   */
  export type EncadrantSoutenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadrantSoutenance
     */
    select?: EncadrantSoutenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncadrantSoutenance
     */
    omit?: EncadrantSoutenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncadrantSoutenanceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ResponsableFiliereScalarFieldEnum: {
    idResponsableFiliere: 'idResponsableFiliere',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    motDePasse: 'motDePasse',
    departement: 'departement',
    annee: 'annee'
  };

  export type ResponsableFiliereScalarFieldEnum = (typeof ResponsableFiliereScalarFieldEnum)[keyof typeof ResponsableFiliereScalarFieldEnum]


  export const EncadrantScalarFieldEnum: {
    idEncadrant: 'idEncadrant',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    motDePasse: 'motDePasse',
    annee: 'annee',
    idResponsableFiliere: 'idResponsableFiliere'
  };

  export type EncadrantScalarFieldEnum = (typeof EncadrantScalarFieldEnum)[keyof typeof EncadrantScalarFieldEnum]


  export const TuteurScalarFieldEnum: {
    idTuteur: 'idTuteur',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    motDePasse: 'motDePasse',
    classe: 'classe',
    filiere: 'filiere',
    annee: 'annee'
  };

  export type TuteurScalarFieldEnum = (typeof TuteurScalarFieldEnum)[keyof typeof TuteurScalarFieldEnum]


  export const EtudiantScalarFieldEnum: {
    idEtudiant: 'idEtudiant',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    motDePasse: 'motDePasse',
    annee: 'annee',
    classe: 'classe',
    filiere: 'filiere'
  };

  export type EtudiantScalarFieldEnum = (typeof EtudiantScalarFieldEnum)[keyof typeof EtudiantScalarFieldEnum]


  export const GroupeScalarFieldEnum: {
    idGroupe: 'idGroupe',
    nomGroupe: 'nomGroupe',
    nbEtudiants: 'nbEtudiants'
  };

  export type GroupeScalarFieldEnum = (typeof GroupeScalarFieldEnum)[keyof typeof GroupeScalarFieldEnum]


  export const EtudiantGroupeScalarFieldEnum: {
    idEtudiant: 'idEtudiant',
    idGroupe: 'idGroupe'
  };

  export type EtudiantGroupeScalarFieldEnum = (typeof EtudiantGroupeScalarFieldEnum)[keyof typeof EtudiantGroupeScalarFieldEnum]


  export const SujetScalarFieldEnum: {
    idSujet: 'idSujet',
    titre: 'titre',
    description: 'description',
    annee: 'annee',
    idEncadrant: 'idEncadrant'
  };

  export type SujetScalarFieldEnum = (typeof SujetScalarFieldEnum)[keyof typeof SujetScalarFieldEnum]


  export const EtudiantSujetScalarFieldEnum: {
    idEtudiant: 'idEtudiant',
    idSujet: 'idSujet'
  };

  export type EtudiantSujetScalarFieldEnum = (typeof EtudiantSujetScalarFieldEnum)[keyof typeof EtudiantSujetScalarFieldEnum]


  export const JuryScalarFieldEnum: {
    idJury: 'idJury',
    valideDeliberation: 'valideDeliberation'
  };

  export type JuryScalarFieldEnum = (typeof JuryScalarFieldEnum)[keyof typeof JuryScalarFieldEnum]


  export const SoutenanceScalarFieldEnum: {
    idSoutenance: 'idSoutenance',
    date: 'date',
    heure: 'heure',
    idJury: 'idJury'
  };

  export type SoutenanceScalarFieldEnum = (typeof SoutenanceScalarFieldEnum)[keyof typeof SoutenanceScalarFieldEnum]


  export const EvaluationScalarFieldEnum: {
    idEvaluation: 'idEvaluation',
    note: 'note',
    feedback: 'feedback',
    idSoutenance: 'idSoutenance',
    idEtudiant: 'idEtudiant'
  };

  export type EvaluationScalarFieldEnum = (typeof EvaluationScalarFieldEnum)[keyof typeof EvaluationScalarFieldEnum]


  export const LivrableScalarFieldEnum: {
    idLivrable: 'idLivrable',
    type: 'type',
    nom: 'nom',
    annee: 'annee'
  };

  export type LivrableScalarFieldEnum = (typeof LivrableScalarFieldEnum)[keyof typeof LivrableScalarFieldEnum]


  export const PFEScalarFieldEnum: {
    idPFE: 'idPFE',
    statut: 'statut',
    annee: 'annee',
    idTuteur: 'idTuteur'
  };

  export type PFEScalarFieldEnum = (typeof PFEScalarFieldEnum)[keyof typeof PFEScalarFieldEnum]


  export const PFE_GroupeScalarFieldEnum: {
    idPFE: 'idPFE',
    idGroupe: 'idGroupe'
  };

  export type PFE_GroupeScalarFieldEnum = (typeof PFE_GroupeScalarFieldEnum)[keyof typeof PFE_GroupeScalarFieldEnum]


  export const PFE_LivrableScalarFieldEnum: {
    idPFE: 'idPFE',
    idLivrable: 'idLivrable'
  };

  export type PFE_LivrableScalarFieldEnum = (typeof PFE_LivrableScalarFieldEnum)[keyof typeof PFE_LivrableScalarFieldEnum]


  export const EncadrantLivrableScalarFieldEnum: {
    idEncadrant: 'idEncadrant',
    idLivrable: 'idLivrable'
  };

  export type EncadrantLivrableScalarFieldEnum = (typeof EncadrantLivrableScalarFieldEnum)[keyof typeof EncadrantLivrableScalarFieldEnum]


  export const TuteurLivrableScalarFieldEnum: {
    idTuteur: 'idTuteur',
    idLivrable: 'idLivrable'
  };

  export type TuteurLivrableScalarFieldEnum = (typeof TuteurLivrableScalarFieldEnum)[keyof typeof TuteurLivrableScalarFieldEnum]


  export const EncadrantSoutenanceScalarFieldEnum: {
    idEncadrant: 'idEncadrant',
    idSoutenance: 'idSoutenance'
  };

  export type EncadrantSoutenanceScalarFieldEnum = (typeof EncadrantSoutenanceScalarFieldEnum)[keyof typeof EncadrantSoutenanceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const ResponsableFiliereOrderByRelevanceFieldEnum: {
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    motDePasse: 'motDePasse',
    departement: 'departement'
  };

  export type ResponsableFiliereOrderByRelevanceFieldEnum = (typeof ResponsableFiliereOrderByRelevanceFieldEnum)[keyof typeof ResponsableFiliereOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const EncadrantOrderByRelevanceFieldEnum: {
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    motDePasse: 'motDePasse'
  };

  export type EncadrantOrderByRelevanceFieldEnum = (typeof EncadrantOrderByRelevanceFieldEnum)[keyof typeof EncadrantOrderByRelevanceFieldEnum]


  export const TuteurOrderByRelevanceFieldEnum: {
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    motDePasse: 'motDePasse',
    classe: 'classe',
    filiere: 'filiere'
  };

  export type TuteurOrderByRelevanceFieldEnum = (typeof TuteurOrderByRelevanceFieldEnum)[keyof typeof TuteurOrderByRelevanceFieldEnum]


  export const EtudiantOrderByRelevanceFieldEnum: {
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    motDePasse: 'motDePasse',
    classe: 'classe',
    filiere: 'filiere'
  };

  export type EtudiantOrderByRelevanceFieldEnum = (typeof EtudiantOrderByRelevanceFieldEnum)[keyof typeof EtudiantOrderByRelevanceFieldEnum]


  export const GroupeOrderByRelevanceFieldEnum: {
    nomGroupe: 'nomGroupe'
  };

  export type GroupeOrderByRelevanceFieldEnum = (typeof GroupeOrderByRelevanceFieldEnum)[keyof typeof GroupeOrderByRelevanceFieldEnum]


  export const SujetOrderByRelevanceFieldEnum: {
    titre: 'titre',
    description: 'description'
  };

  export type SujetOrderByRelevanceFieldEnum = (typeof SujetOrderByRelevanceFieldEnum)[keyof typeof SujetOrderByRelevanceFieldEnum]


  export const EvaluationOrderByRelevanceFieldEnum: {
    feedback: 'feedback'
  };

  export type EvaluationOrderByRelevanceFieldEnum = (typeof EvaluationOrderByRelevanceFieldEnum)[keyof typeof EvaluationOrderByRelevanceFieldEnum]


  export const LivrableOrderByRelevanceFieldEnum: {
    type: 'type',
    nom: 'nom'
  };

  export type LivrableOrderByRelevanceFieldEnum = (typeof LivrableOrderByRelevanceFieldEnum)[keyof typeof LivrableOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ResponsableFiliereWhereInput = {
    AND?: ResponsableFiliereWhereInput | ResponsableFiliereWhereInput[]
    OR?: ResponsableFiliereWhereInput[]
    NOT?: ResponsableFiliereWhereInput | ResponsableFiliereWhereInput[]
    idResponsableFiliere?: IntFilter<"ResponsableFiliere"> | number
    nom?: StringFilter<"ResponsableFiliere"> | string
    prenom?: StringFilter<"ResponsableFiliere"> | string
    email?: StringFilter<"ResponsableFiliere"> | string
    motDePasse?: StringFilter<"ResponsableFiliere"> | string
    departement?: StringFilter<"ResponsableFiliere"> | string
    annee?: IntFilter<"ResponsableFiliere"> | number
    encadrants?: EncadrantListRelationFilter
  }

  export type ResponsableFiliereOrderByWithRelationInput = {
    idResponsableFiliere?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    departement?: SortOrder
    annee?: SortOrder
    encadrants?: EncadrantOrderByRelationAggregateInput
    _relevance?: ResponsableFiliereOrderByRelevanceInput
  }

  export type ResponsableFiliereWhereUniqueInput = Prisma.AtLeast<{
    idResponsableFiliere?: number
    email?: string
    AND?: ResponsableFiliereWhereInput | ResponsableFiliereWhereInput[]
    OR?: ResponsableFiliereWhereInput[]
    NOT?: ResponsableFiliereWhereInput | ResponsableFiliereWhereInput[]
    nom?: StringFilter<"ResponsableFiliere"> | string
    prenom?: StringFilter<"ResponsableFiliere"> | string
    motDePasse?: StringFilter<"ResponsableFiliere"> | string
    departement?: StringFilter<"ResponsableFiliere"> | string
    annee?: IntFilter<"ResponsableFiliere"> | number
    encadrants?: EncadrantListRelationFilter
  }, "idResponsableFiliere" | "email">

  export type ResponsableFiliereOrderByWithAggregationInput = {
    idResponsableFiliere?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    departement?: SortOrder
    annee?: SortOrder
    _count?: ResponsableFiliereCountOrderByAggregateInput
    _avg?: ResponsableFiliereAvgOrderByAggregateInput
    _max?: ResponsableFiliereMaxOrderByAggregateInput
    _min?: ResponsableFiliereMinOrderByAggregateInput
    _sum?: ResponsableFiliereSumOrderByAggregateInput
  }

  export type ResponsableFiliereScalarWhereWithAggregatesInput = {
    AND?: ResponsableFiliereScalarWhereWithAggregatesInput | ResponsableFiliereScalarWhereWithAggregatesInput[]
    OR?: ResponsableFiliereScalarWhereWithAggregatesInput[]
    NOT?: ResponsableFiliereScalarWhereWithAggregatesInput | ResponsableFiliereScalarWhereWithAggregatesInput[]
    idResponsableFiliere?: IntWithAggregatesFilter<"ResponsableFiliere"> | number
    nom?: StringWithAggregatesFilter<"ResponsableFiliere"> | string
    prenom?: StringWithAggregatesFilter<"ResponsableFiliere"> | string
    email?: StringWithAggregatesFilter<"ResponsableFiliere"> | string
    motDePasse?: StringWithAggregatesFilter<"ResponsableFiliere"> | string
    departement?: StringWithAggregatesFilter<"ResponsableFiliere"> | string
    annee?: IntWithAggregatesFilter<"ResponsableFiliere"> | number
  }

  export type EncadrantWhereInput = {
    AND?: EncadrantWhereInput | EncadrantWhereInput[]
    OR?: EncadrantWhereInput[]
    NOT?: EncadrantWhereInput | EncadrantWhereInput[]
    idEncadrant?: IntFilter<"Encadrant"> | number
    nom?: StringFilter<"Encadrant"> | string
    prenom?: StringFilter<"Encadrant"> | string
    email?: StringFilter<"Encadrant"> | string
    motDePasse?: StringFilter<"Encadrant"> | string
    annee?: IntFilter<"Encadrant"> | number
    idResponsableFiliere?: IntNullableFilter<"Encadrant"> | number | null
    responsableFiliere?: XOR<ResponsableFiliereNullableScalarRelationFilter, ResponsableFiliereWhereInput> | null
    sujets?: SujetListRelationFilter
    soutenances?: EncadrantSoutenanceListRelationFilter
    livrables?: EncadrantLivrableListRelationFilter
  }

  export type EncadrantOrderByWithRelationInput = {
    idEncadrant?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    annee?: SortOrder
    idResponsableFiliere?: SortOrderInput | SortOrder
    responsableFiliere?: ResponsableFiliereOrderByWithRelationInput
    sujets?: SujetOrderByRelationAggregateInput
    soutenances?: EncadrantSoutenanceOrderByRelationAggregateInput
    livrables?: EncadrantLivrableOrderByRelationAggregateInput
    _relevance?: EncadrantOrderByRelevanceInput
  }

  export type EncadrantWhereUniqueInput = Prisma.AtLeast<{
    idEncadrant?: number
    email?: string
    AND?: EncadrantWhereInput | EncadrantWhereInput[]
    OR?: EncadrantWhereInput[]
    NOT?: EncadrantWhereInput | EncadrantWhereInput[]
    nom?: StringFilter<"Encadrant"> | string
    prenom?: StringFilter<"Encadrant"> | string
    motDePasse?: StringFilter<"Encadrant"> | string
    annee?: IntFilter<"Encadrant"> | number
    idResponsableFiliere?: IntNullableFilter<"Encadrant"> | number | null
    responsableFiliere?: XOR<ResponsableFiliereNullableScalarRelationFilter, ResponsableFiliereWhereInput> | null
    sujets?: SujetListRelationFilter
    soutenances?: EncadrantSoutenanceListRelationFilter
    livrables?: EncadrantLivrableListRelationFilter
  }, "idEncadrant" | "email">

  export type EncadrantOrderByWithAggregationInput = {
    idEncadrant?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    annee?: SortOrder
    idResponsableFiliere?: SortOrderInput | SortOrder
    _count?: EncadrantCountOrderByAggregateInput
    _avg?: EncadrantAvgOrderByAggregateInput
    _max?: EncadrantMaxOrderByAggregateInput
    _min?: EncadrantMinOrderByAggregateInput
    _sum?: EncadrantSumOrderByAggregateInput
  }

  export type EncadrantScalarWhereWithAggregatesInput = {
    AND?: EncadrantScalarWhereWithAggregatesInput | EncadrantScalarWhereWithAggregatesInput[]
    OR?: EncadrantScalarWhereWithAggregatesInput[]
    NOT?: EncadrantScalarWhereWithAggregatesInput | EncadrantScalarWhereWithAggregatesInput[]
    idEncadrant?: IntWithAggregatesFilter<"Encadrant"> | number
    nom?: StringWithAggregatesFilter<"Encadrant"> | string
    prenom?: StringWithAggregatesFilter<"Encadrant"> | string
    email?: StringWithAggregatesFilter<"Encadrant"> | string
    motDePasse?: StringWithAggregatesFilter<"Encadrant"> | string
    annee?: IntWithAggregatesFilter<"Encadrant"> | number
    idResponsableFiliere?: IntNullableWithAggregatesFilter<"Encadrant"> | number | null
  }

  export type TuteurWhereInput = {
    AND?: TuteurWhereInput | TuteurWhereInput[]
    OR?: TuteurWhereInput[]
    NOT?: TuteurWhereInput | TuteurWhereInput[]
    idTuteur?: IntFilter<"Tuteur"> | number
    nom?: StringFilter<"Tuteur"> | string
    prenom?: StringFilter<"Tuteur"> | string
    email?: StringFilter<"Tuteur"> | string
    motDePasse?: StringFilter<"Tuteur"> | string
    classe?: StringFilter<"Tuteur"> | string
    filiere?: StringFilter<"Tuteur"> | string
    annee?: IntFilter<"Tuteur"> | number
    PFEs?: PFEListRelationFilter
    livrables?: TuteurLivrableListRelationFilter
  }

  export type TuteurOrderByWithRelationInput = {
    idTuteur?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    classe?: SortOrder
    filiere?: SortOrder
    annee?: SortOrder
    PFEs?: PFEOrderByRelationAggregateInput
    livrables?: TuteurLivrableOrderByRelationAggregateInput
    _relevance?: TuteurOrderByRelevanceInput
  }

  export type TuteurWhereUniqueInput = Prisma.AtLeast<{
    idTuteur?: number
    email?: string
    AND?: TuteurWhereInput | TuteurWhereInput[]
    OR?: TuteurWhereInput[]
    NOT?: TuteurWhereInput | TuteurWhereInput[]
    nom?: StringFilter<"Tuteur"> | string
    prenom?: StringFilter<"Tuteur"> | string
    motDePasse?: StringFilter<"Tuteur"> | string
    classe?: StringFilter<"Tuteur"> | string
    filiere?: StringFilter<"Tuteur"> | string
    annee?: IntFilter<"Tuteur"> | number
    PFEs?: PFEListRelationFilter
    livrables?: TuteurLivrableListRelationFilter
  }, "idTuteur" | "email">

  export type TuteurOrderByWithAggregationInput = {
    idTuteur?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    classe?: SortOrder
    filiere?: SortOrder
    annee?: SortOrder
    _count?: TuteurCountOrderByAggregateInput
    _avg?: TuteurAvgOrderByAggregateInput
    _max?: TuteurMaxOrderByAggregateInput
    _min?: TuteurMinOrderByAggregateInput
    _sum?: TuteurSumOrderByAggregateInput
  }

  export type TuteurScalarWhereWithAggregatesInput = {
    AND?: TuteurScalarWhereWithAggregatesInput | TuteurScalarWhereWithAggregatesInput[]
    OR?: TuteurScalarWhereWithAggregatesInput[]
    NOT?: TuteurScalarWhereWithAggregatesInput | TuteurScalarWhereWithAggregatesInput[]
    idTuteur?: IntWithAggregatesFilter<"Tuteur"> | number
    nom?: StringWithAggregatesFilter<"Tuteur"> | string
    prenom?: StringWithAggregatesFilter<"Tuteur"> | string
    email?: StringWithAggregatesFilter<"Tuteur"> | string
    motDePasse?: StringWithAggregatesFilter<"Tuteur"> | string
    classe?: StringWithAggregatesFilter<"Tuteur"> | string
    filiere?: StringWithAggregatesFilter<"Tuteur"> | string
    annee?: IntWithAggregatesFilter<"Tuteur"> | number
  }

  export type EtudiantWhereInput = {
    AND?: EtudiantWhereInput | EtudiantWhereInput[]
    OR?: EtudiantWhereInput[]
    NOT?: EtudiantWhereInput | EtudiantWhereInput[]
    idEtudiant?: IntFilter<"Etudiant"> | number
    nom?: StringFilter<"Etudiant"> | string
    prenom?: StringFilter<"Etudiant"> | string
    email?: StringFilter<"Etudiant"> | string
    motDePasse?: StringFilter<"Etudiant"> | string
    annee?: IntFilter<"Etudiant"> | number
    classe?: StringFilter<"Etudiant"> | string
    filiere?: StringFilter<"Etudiant"> | string
    groupes?: EtudiantGroupeListRelationFilter
    sujets?: EtudiantSujetListRelationFilter
    evaluations?: EvaluationListRelationFilter
  }

  export type EtudiantOrderByWithRelationInput = {
    idEtudiant?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    annee?: SortOrder
    classe?: SortOrder
    filiere?: SortOrder
    groupes?: EtudiantGroupeOrderByRelationAggregateInput
    sujets?: EtudiantSujetOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    _relevance?: EtudiantOrderByRelevanceInput
  }

  export type EtudiantWhereUniqueInput = Prisma.AtLeast<{
    idEtudiant?: number
    email?: string
    AND?: EtudiantWhereInput | EtudiantWhereInput[]
    OR?: EtudiantWhereInput[]
    NOT?: EtudiantWhereInput | EtudiantWhereInput[]
    nom?: StringFilter<"Etudiant"> | string
    prenom?: StringFilter<"Etudiant"> | string
    motDePasse?: StringFilter<"Etudiant"> | string
    annee?: IntFilter<"Etudiant"> | number
    classe?: StringFilter<"Etudiant"> | string
    filiere?: StringFilter<"Etudiant"> | string
    groupes?: EtudiantGroupeListRelationFilter
    sujets?: EtudiantSujetListRelationFilter
    evaluations?: EvaluationListRelationFilter
  }, "idEtudiant" | "email">

  export type EtudiantOrderByWithAggregationInput = {
    idEtudiant?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    annee?: SortOrder
    classe?: SortOrder
    filiere?: SortOrder
    _count?: EtudiantCountOrderByAggregateInput
    _avg?: EtudiantAvgOrderByAggregateInput
    _max?: EtudiantMaxOrderByAggregateInput
    _min?: EtudiantMinOrderByAggregateInput
    _sum?: EtudiantSumOrderByAggregateInput
  }

  export type EtudiantScalarWhereWithAggregatesInput = {
    AND?: EtudiantScalarWhereWithAggregatesInput | EtudiantScalarWhereWithAggregatesInput[]
    OR?: EtudiantScalarWhereWithAggregatesInput[]
    NOT?: EtudiantScalarWhereWithAggregatesInput | EtudiantScalarWhereWithAggregatesInput[]
    idEtudiant?: IntWithAggregatesFilter<"Etudiant"> | number
    nom?: StringWithAggregatesFilter<"Etudiant"> | string
    prenom?: StringWithAggregatesFilter<"Etudiant"> | string
    email?: StringWithAggregatesFilter<"Etudiant"> | string
    motDePasse?: StringWithAggregatesFilter<"Etudiant"> | string
    annee?: IntWithAggregatesFilter<"Etudiant"> | number
    classe?: StringWithAggregatesFilter<"Etudiant"> | string
    filiere?: StringWithAggregatesFilter<"Etudiant"> | string
  }

  export type GroupeWhereInput = {
    AND?: GroupeWhereInput | GroupeWhereInput[]
    OR?: GroupeWhereInput[]
    NOT?: GroupeWhereInput | GroupeWhereInput[]
    idGroupe?: IntFilter<"Groupe"> | number
    nomGroupe?: StringFilter<"Groupe"> | string
    nbEtudiants?: IntFilter<"Groupe"> | number
    etudiants?: EtudiantGroupeListRelationFilter
    PFEs?: PFE_GroupeListRelationFilter
  }

  export type GroupeOrderByWithRelationInput = {
    idGroupe?: SortOrder
    nomGroupe?: SortOrder
    nbEtudiants?: SortOrder
    etudiants?: EtudiantGroupeOrderByRelationAggregateInput
    PFEs?: PFE_GroupeOrderByRelationAggregateInput
    _relevance?: GroupeOrderByRelevanceInput
  }

  export type GroupeWhereUniqueInput = Prisma.AtLeast<{
    idGroupe?: number
    AND?: GroupeWhereInput | GroupeWhereInput[]
    OR?: GroupeWhereInput[]
    NOT?: GroupeWhereInput | GroupeWhereInput[]
    nomGroupe?: StringFilter<"Groupe"> | string
    nbEtudiants?: IntFilter<"Groupe"> | number
    etudiants?: EtudiantGroupeListRelationFilter
    PFEs?: PFE_GroupeListRelationFilter
  }, "idGroupe">

  export type GroupeOrderByWithAggregationInput = {
    idGroupe?: SortOrder
    nomGroupe?: SortOrder
    nbEtudiants?: SortOrder
    _count?: GroupeCountOrderByAggregateInput
    _avg?: GroupeAvgOrderByAggregateInput
    _max?: GroupeMaxOrderByAggregateInput
    _min?: GroupeMinOrderByAggregateInput
    _sum?: GroupeSumOrderByAggregateInput
  }

  export type GroupeScalarWhereWithAggregatesInput = {
    AND?: GroupeScalarWhereWithAggregatesInput | GroupeScalarWhereWithAggregatesInput[]
    OR?: GroupeScalarWhereWithAggregatesInput[]
    NOT?: GroupeScalarWhereWithAggregatesInput | GroupeScalarWhereWithAggregatesInput[]
    idGroupe?: IntWithAggregatesFilter<"Groupe"> | number
    nomGroupe?: StringWithAggregatesFilter<"Groupe"> | string
    nbEtudiants?: IntWithAggregatesFilter<"Groupe"> | number
  }

  export type EtudiantGroupeWhereInput = {
    AND?: EtudiantGroupeWhereInput | EtudiantGroupeWhereInput[]
    OR?: EtudiantGroupeWhereInput[]
    NOT?: EtudiantGroupeWhereInput | EtudiantGroupeWhereInput[]
    idEtudiant?: IntFilter<"EtudiantGroupe"> | number
    idGroupe?: IntFilter<"EtudiantGroupe"> | number
    etudiant?: XOR<EtudiantScalarRelationFilter, EtudiantWhereInput>
    groupe?: XOR<GroupeScalarRelationFilter, GroupeWhereInput>
  }

  export type EtudiantGroupeOrderByWithRelationInput = {
    idEtudiant?: SortOrder
    idGroupe?: SortOrder
    etudiant?: EtudiantOrderByWithRelationInput
    groupe?: GroupeOrderByWithRelationInput
  }

  export type EtudiantGroupeWhereUniqueInput = Prisma.AtLeast<{
    idEtudiant_idGroupe?: EtudiantGroupeIdEtudiantIdGroupeCompoundUniqueInput
    AND?: EtudiantGroupeWhereInput | EtudiantGroupeWhereInput[]
    OR?: EtudiantGroupeWhereInput[]
    NOT?: EtudiantGroupeWhereInput | EtudiantGroupeWhereInput[]
    idEtudiant?: IntFilter<"EtudiantGroupe"> | number
    idGroupe?: IntFilter<"EtudiantGroupe"> | number
    etudiant?: XOR<EtudiantScalarRelationFilter, EtudiantWhereInput>
    groupe?: XOR<GroupeScalarRelationFilter, GroupeWhereInput>
  }, "idEtudiant_idGroupe">

  export type EtudiantGroupeOrderByWithAggregationInput = {
    idEtudiant?: SortOrder
    idGroupe?: SortOrder
    _count?: EtudiantGroupeCountOrderByAggregateInput
    _avg?: EtudiantGroupeAvgOrderByAggregateInput
    _max?: EtudiantGroupeMaxOrderByAggregateInput
    _min?: EtudiantGroupeMinOrderByAggregateInput
    _sum?: EtudiantGroupeSumOrderByAggregateInput
  }

  export type EtudiantGroupeScalarWhereWithAggregatesInput = {
    AND?: EtudiantGroupeScalarWhereWithAggregatesInput | EtudiantGroupeScalarWhereWithAggregatesInput[]
    OR?: EtudiantGroupeScalarWhereWithAggregatesInput[]
    NOT?: EtudiantGroupeScalarWhereWithAggregatesInput | EtudiantGroupeScalarWhereWithAggregatesInput[]
    idEtudiant?: IntWithAggregatesFilter<"EtudiantGroupe"> | number
    idGroupe?: IntWithAggregatesFilter<"EtudiantGroupe"> | number
  }

  export type SujetWhereInput = {
    AND?: SujetWhereInput | SujetWhereInput[]
    OR?: SujetWhereInput[]
    NOT?: SujetWhereInput | SujetWhereInput[]
    idSujet?: IntFilter<"Sujet"> | number
    titre?: StringFilter<"Sujet"> | string
    description?: StringFilter<"Sujet"> | string
    annee?: IntFilter<"Sujet"> | number
    idEncadrant?: IntFilter<"Sujet"> | number
    encadrant?: XOR<EncadrantScalarRelationFilter, EncadrantWhereInput>
    etudiants?: EtudiantSujetListRelationFilter
  }

  export type SujetOrderByWithRelationInput = {
    idSujet?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    annee?: SortOrder
    idEncadrant?: SortOrder
    encadrant?: EncadrantOrderByWithRelationInput
    etudiants?: EtudiantSujetOrderByRelationAggregateInput
    _relevance?: SujetOrderByRelevanceInput
  }

  export type SujetWhereUniqueInput = Prisma.AtLeast<{
    idSujet?: number
    AND?: SujetWhereInput | SujetWhereInput[]
    OR?: SujetWhereInput[]
    NOT?: SujetWhereInput | SujetWhereInput[]
    titre?: StringFilter<"Sujet"> | string
    description?: StringFilter<"Sujet"> | string
    annee?: IntFilter<"Sujet"> | number
    idEncadrant?: IntFilter<"Sujet"> | number
    encadrant?: XOR<EncadrantScalarRelationFilter, EncadrantWhereInput>
    etudiants?: EtudiantSujetListRelationFilter
  }, "idSujet">

  export type SujetOrderByWithAggregationInput = {
    idSujet?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    annee?: SortOrder
    idEncadrant?: SortOrder
    _count?: SujetCountOrderByAggregateInput
    _avg?: SujetAvgOrderByAggregateInput
    _max?: SujetMaxOrderByAggregateInput
    _min?: SujetMinOrderByAggregateInput
    _sum?: SujetSumOrderByAggregateInput
  }

  export type SujetScalarWhereWithAggregatesInput = {
    AND?: SujetScalarWhereWithAggregatesInput | SujetScalarWhereWithAggregatesInput[]
    OR?: SujetScalarWhereWithAggregatesInput[]
    NOT?: SujetScalarWhereWithAggregatesInput | SujetScalarWhereWithAggregatesInput[]
    idSujet?: IntWithAggregatesFilter<"Sujet"> | number
    titre?: StringWithAggregatesFilter<"Sujet"> | string
    description?: StringWithAggregatesFilter<"Sujet"> | string
    annee?: IntWithAggregatesFilter<"Sujet"> | number
    idEncadrant?: IntWithAggregatesFilter<"Sujet"> | number
  }

  export type EtudiantSujetWhereInput = {
    AND?: EtudiantSujetWhereInput | EtudiantSujetWhereInput[]
    OR?: EtudiantSujetWhereInput[]
    NOT?: EtudiantSujetWhereInput | EtudiantSujetWhereInput[]
    idEtudiant?: IntFilter<"EtudiantSujet"> | number
    idSujet?: IntFilter<"EtudiantSujet"> | number
    etudiant?: XOR<EtudiantScalarRelationFilter, EtudiantWhereInput>
    sujet?: XOR<SujetScalarRelationFilter, SujetWhereInput>
  }

  export type EtudiantSujetOrderByWithRelationInput = {
    idEtudiant?: SortOrder
    idSujet?: SortOrder
    etudiant?: EtudiantOrderByWithRelationInput
    sujet?: SujetOrderByWithRelationInput
  }

  export type EtudiantSujetWhereUniqueInput = Prisma.AtLeast<{
    idEtudiant_idSujet?: EtudiantSujetIdEtudiantIdSujetCompoundUniqueInput
    AND?: EtudiantSujetWhereInput | EtudiantSujetWhereInput[]
    OR?: EtudiantSujetWhereInput[]
    NOT?: EtudiantSujetWhereInput | EtudiantSujetWhereInput[]
    idEtudiant?: IntFilter<"EtudiantSujet"> | number
    idSujet?: IntFilter<"EtudiantSujet"> | number
    etudiant?: XOR<EtudiantScalarRelationFilter, EtudiantWhereInput>
    sujet?: XOR<SujetScalarRelationFilter, SujetWhereInput>
  }, "idEtudiant_idSujet">

  export type EtudiantSujetOrderByWithAggregationInput = {
    idEtudiant?: SortOrder
    idSujet?: SortOrder
    _count?: EtudiantSujetCountOrderByAggregateInput
    _avg?: EtudiantSujetAvgOrderByAggregateInput
    _max?: EtudiantSujetMaxOrderByAggregateInput
    _min?: EtudiantSujetMinOrderByAggregateInput
    _sum?: EtudiantSujetSumOrderByAggregateInput
  }

  export type EtudiantSujetScalarWhereWithAggregatesInput = {
    AND?: EtudiantSujetScalarWhereWithAggregatesInput | EtudiantSujetScalarWhereWithAggregatesInput[]
    OR?: EtudiantSujetScalarWhereWithAggregatesInput[]
    NOT?: EtudiantSujetScalarWhereWithAggregatesInput | EtudiantSujetScalarWhereWithAggregatesInput[]
    idEtudiant?: IntWithAggregatesFilter<"EtudiantSujet"> | number
    idSujet?: IntWithAggregatesFilter<"EtudiantSujet"> | number
  }

  export type JuryWhereInput = {
    AND?: JuryWhereInput | JuryWhereInput[]
    OR?: JuryWhereInput[]
    NOT?: JuryWhereInput | JuryWhereInput[]
    idJury?: IntFilter<"Jury"> | number
    valideDeliberation?: BoolFilter<"Jury"> | boolean
    soutenances?: SoutenanceListRelationFilter
  }

  export type JuryOrderByWithRelationInput = {
    idJury?: SortOrder
    valideDeliberation?: SortOrder
    soutenances?: SoutenanceOrderByRelationAggregateInput
  }

  export type JuryWhereUniqueInput = Prisma.AtLeast<{
    idJury?: number
    AND?: JuryWhereInput | JuryWhereInput[]
    OR?: JuryWhereInput[]
    NOT?: JuryWhereInput | JuryWhereInput[]
    valideDeliberation?: BoolFilter<"Jury"> | boolean
    soutenances?: SoutenanceListRelationFilter
  }, "idJury">

  export type JuryOrderByWithAggregationInput = {
    idJury?: SortOrder
    valideDeliberation?: SortOrder
    _count?: JuryCountOrderByAggregateInput
    _avg?: JuryAvgOrderByAggregateInput
    _max?: JuryMaxOrderByAggregateInput
    _min?: JuryMinOrderByAggregateInput
    _sum?: JurySumOrderByAggregateInput
  }

  export type JuryScalarWhereWithAggregatesInput = {
    AND?: JuryScalarWhereWithAggregatesInput | JuryScalarWhereWithAggregatesInput[]
    OR?: JuryScalarWhereWithAggregatesInput[]
    NOT?: JuryScalarWhereWithAggregatesInput | JuryScalarWhereWithAggregatesInput[]
    idJury?: IntWithAggregatesFilter<"Jury"> | number
    valideDeliberation?: BoolWithAggregatesFilter<"Jury"> | boolean
  }

  export type SoutenanceWhereInput = {
    AND?: SoutenanceWhereInput | SoutenanceWhereInput[]
    OR?: SoutenanceWhereInput[]
    NOT?: SoutenanceWhereInput | SoutenanceWhereInput[]
    idSoutenance?: IntFilter<"Soutenance"> | number
    date?: DateTimeFilter<"Soutenance"> | Date | string
    heure?: DateTimeFilter<"Soutenance"> | Date | string
    idJury?: IntFilter<"Soutenance"> | number
    jury?: XOR<JuryScalarRelationFilter, JuryWhereInput>
    encadrants?: EncadrantSoutenanceListRelationFilter
    evaluations?: EvaluationListRelationFilter
  }

  export type SoutenanceOrderByWithRelationInput = {
    idSoutenance?: SortOrder
    date?: SortOrder
    heure?: SortOrder
    idJury?: SortOrder
    jury?: JuryOrderByWithRelationInput
    encadrants?: EncadrantSoutenanceOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type SoutenanceWhereUniqueInput = Prisma.AtLeast<{
    idSoutenance?: number
    AND?: SoutenanceWhereInput | SoutenanceWhereInput[]
    OR?: SoutenanceWhereInput[]
    NOT?: SoutenanceWhereInput | SoutenanceWhereInput[]
    date?: DateTimeFilter<"Soutenance"> | Date | string
    heure?: DateTimeFilter<"Soutenance"> | Date | string
    idJury?: IntFilter<"Soutenance"> | number
    jury?: XOR<JuryScalarRelationFilter, JuryWhereInput>
    encadrants?: EncadrantSoutenanceListRelationFilter
    evaluations?: EvaluationListRelationFilter
  }, "idSoutenance">

  export type SoutenanceOrderByWithAggregationInput = {
    idSoutenance?: SortOrder
    date?: SortOrder
    heure?: SortOrder
    idJury?: SortOrder
    _count?: SoutenanceCountOrderByAggregateInput
    _avg?: SoutenanceAvgOrderByAggregateInput
    _max?: SoutenanceMaxOrderByAggregateInput
    _min?: SoutenanceMinOrderByAggregateInput
    _sum?: SoutenanceSumOrderByAggregateInput
  }

  export type SoutenanceScalarWhereWithAggregatesInput = {
    AND?: SoutenanceScalarWhereWithAggregatesInput | SoutenanceScalarWhereWithAggregatesInput[]
    OR?: SoutenanceScalarWhereWithAggregatesInput[]
    NOT?: SoutenanceScalarWhereWithAggregatesInput | SoutenanceScalarWhereWithAggregatesInput[]
    idSoutenance?: IntWithAggregatesFilter<"Soutenance"> | number
    date?: DateTimeWithAggregatesFilter<"Soutenance"> | Date | string
    heure?: DateTimeWithAggregatesFilter<"Soutenance"> | Date | string
    idJury?: IntWithAggregatesFilter<"Soutenance"> | number
  }

  export type EvaluationWhereInput = {
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    idEvaluation?: IntFilter<"Evaluation"> | number
    note?: FloatFilter<"Evaluation"> | number
    feedback?: StringNullableFilter<"Evaluation"> | string | null
    idSoutenance?: IntFilter<"Evaluation"> | number
    idEtudiant?: IntFilter<"Evaluation"> | number
    soutenance?: XOR<SoutenanceScalarRelationFilter, SoutenanceWhereInput>
    etudiant?: XOR<EtudiantScalarRelationFilter, EtudiantWhereInput>
  }

  export type EvaluationOrderByWithRelationInput = {
    idEvaluation?: SortOrder
    note?: SortOrder
    feedback?: SortOrderInput | SortOrder
    idSoutenance?: SortOrder
    idEtudiant?: SortOrder
    soutenance?: SoutenanceOrderByWithRelationInput
    etudiant?: EtudiantOrderByWithRelationInput
    _relevance?: EvaluationOrderByRelevanceInput
  }

  export type EvaluationWhereUniqueInput = Prisma.AtLeast<{
    idEvaluation?: number
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    note?: FloatFilter<"Evaluation"> | number
    feedback?: StringNullableFilter<"Evaluation"> | string | null
    idSoutenance?: IntFilter<"Evaluation"> | number
    idEtudiant?: IntFilter<"Evaluation"> | number
    soutenance?: XOR<SoutenanceScalarRelationFilter, SoutenanceWhereInput>
    etudiant?: XOR<EtudiantScalarRelationFilter, EtudiantWhereInput>
  }, "idEvaluation">

  export type EvaluationOrderByWithAggregationInput = {
    idEvaluation?: SortOrder
    note?: SortOrder
    feedback?: SortOrderInput | SortOrder
    idSoutenance?: SortOrder
    idEtudiant?: SortOrder
    _count?: EvaluationCountOrderByAggregateInput
    _avg?: EvaluationAvgOrderByAggregateInput
    _max?: EvaluationMaxOrderByAggregateInput
    _min?: EvaluationMinOrderByAggregateInput
    _sum?: EvaluationSumOrderByAggregateInput
  }

  export type EvaluationScalarWhereWithAggregatesInput = {
    AND?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    OR?: EvaluationScalarWhereWithAggregatesInput[]
    NOT?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    idEvaluation?: IntWithAggregatesFilter<"Evaluation"> | number
    note?: FloatWithAggregatesFilter<"Evaluation"> | number
    feedback?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    idSoutenance?: IntWithAggregatesFilter<"Evaluation"> | number
    idEtudiant?: IntWithAggregatesFilter<"Evaluation"> | number
  }

  export type LivrableWhereInput = {
    AND?: LivrableWhereInput | LivrableWhereInput[]
    OR?: LivrableWhereInput[]
    NOT?: LivrableWhereInput | LivrableWhereInput[]
    idLivrable?: IntFilter<"Livrable"> | number
    type?: StringFilter<"Livrable"> | string
    nom?: StringFilter<"Livrable"> | string
    annee?: IntFilter<"Livrable"> | number
    PFEs?: PFE_LivrableListRelationFilter
    encadrants?: EncadrantLivrableListRelationFilter
    tuteurs?: TuteurLivrableListRelationFilter
  }

  export type LivrableOrderByWithRelationInput = {
    idLivrable?: SortOrder
    type?: SortOrder
    nom?: SortOrder
    annee?: SortOrder
    PFEs?: PFE_LivrableOrderByRelationAggregateInput
    encadrants?: EncadrantLivrableOrderByRelationAggregateInput
    tuteurs?: TuteurLivrableOrderByRelationAggregateInput
    _relevance?: LivrableOrderByRelevanceInput
  }

  export type LivrableWhereUniqueInput = Prisma.AtLeast<{
    idLivrable?: number
    AND?: LivrableWhereInput | LivrableWhereInput[]
    OR?: LivrableWhereInput[]
    NOT?: LivrableWhereInput | LivrableWhereInput[]
    type?: StringFilter<"Livrable"> | string
    nom?: StringFilter<"Livrable"> | string
    annee?: IntFilter<"Livrable"> | number
    PFEs?: PFE_LivrableListRelationFilter
    encadrants?: EncadrantLivrableListRelationFilter
    tuteurs?: TuteurLivrableListRelationFilter
  }, "idLivrable">

  export type LivrableOrderByWithAggregationInput = {
    idLivrable?: SortOrder
    type?: SortOrder
    nom?: SortOrder
    annee?: SortOrder
    _count?: LivrableCountOrderByAggregateInput
    _avg?: LivrableAvgOrderByAggregateInput
    _max?: LivrableMaxOrderByAggregateInput
    _min?: LivrableMinOrderByAggregateInput
    _sum?: LivrableSumOrderByAggregateInput
  }

  export type LivrableScalarWhereWithAggregatesInput = {
    AND?: LivrableScalarWhereWithAggregatesInput | LivrableScalarWhereWithAggregatesInput[]
    OR?: LivrableScalarWhereWithAggregatesInput[]
    NOT?: LivrableScalarWhereWithAggregatesInput | LivrableScalarWhereWithAggregatesInput[]
    idLivrable?: IntWithAggregatesFilter<"Livrable"> | number
    type?: StringWithAggregatesFilter<"Livrable"> | string
    nom?: StringWithAggregatesFilter<"Livrable"> | string
    annee?: IntWithAggregatesFilter<"Livrable"> | number
  }

  export type PFEWhereInput = {
    AND?: PFEWhereInput | PFEWhereInput[]
    OR?: PFEWhereInput[]
    NOT?: PFEWhereInput | PFEWhereInput[]
    idPFE?: IntFilter<"PFE"> | number
    statut?: IntFilter<"PFE"> | number
    annee?: IntFilter<"PFE"> | number
    idTuteur?: IntFilter<"PFE"> | number
    tuteur?: XOR<TuteurScalarRelationFilter, TuteurWhereInput>
    groupes?: PFE_GroupeListRelationFilter
    livrables?: PFE_LivrableListRelationFilter
  }

  export type PFEOrderByWithRelationInput = {
    idPFE?: SortOrder
    statut?: SortOrder
    annee?: SortOrder
    idTuteur?: SortOrder
    tuteur?: TuteurOrderByWithRelationInput
    groupes?: PFE_GroupeOrderByRelationAggregateInput
    livrables?: PFE_LivrableOrderByRelationAggregateInput
  }

  export type PFEWhereUniqueInput = Prisma.AtLeast<{
    idPFE?: number
    AND?: PFEWhereInput | PFEWhereInput[]
    OR?: PFEWhereInput[]
    NOT?: PFEWhereInput | PFEWhereInput[]
    statut?: IntFilter<"PFE"> | number
    annee?: IntFilter<"PFE"> | number
    idTuteur?: IntFilter<"PFE"> | number
    tuteur?: XOR<TuteurScalarRelationFilter, TuteurWhereInput>
    groupes?: PFE_GroupeListRelationFilter
    livrables?: PFE_LivrableListRelationFilter
  }, "idPFE">

  export type PFEOrderByWithAggregationInput = {
    idPFE?: SortOrder
    statut?: SortOrder
    annee?: SortOrder
    idTuteur?: SortOrder
    _count?: PFECountOrderByAggregateInput
    _avg?: PFEAvgOrderByAggregateInput
    _max?: PFEMaxOrderByAggregateInput
    _min?: PFEMinOrderByAggregateInput
    _sum?: PFESumOrderByAggregateInput
  }

  export type PFEScalarWhereWithAggregatesInput = {
    AND?: PFEScalarWhereWithAggregatesInput | PFEScalarWhereWithAggregatesInput[]
    OR?: PFEScalarWhereWithAggregatesInput[]
    NOT?: PFEScalarWhereWithAggregatesInput | PFEScalarWhereWithAggregatesInput[]
    idPFE?: IntWithAggregatesFilter<"PFE"> | number
    statut?: IntWithAggregatesFilter<"PFE"> | number
    annee?: IntWithAggregatesFilter<"PFE"> | number
    idTuteur?: IntWithAggregatesFilter<"PFE"> | number
  }

  export type PFE_GroupeWhereInput = {
    AND?: PFE_GroupeWhereInput | PFE_GroupeWhereInput[]
    OR?: PFE_GroupeWhereInput[]
    NOT?: PFE_GroupeWhereInput | PFE_GroupeWhereInput[]
    idPFE?: IntFilter<"PFE_Groupe"> | number
    idGroupe?: IntFilter<"PFE_Groupe"> | number
    pfe?: XOR<PFEScalarRelationFilter, PFEWhereInput>
    groupe?: XOR<GroupeScalarRelationFilter, GroupeWhereInput>
  }

  export type PFE_GroupeOrderByWithRelationInput = {
    idPFE?: SortOrder
    idGroupe?: SortOrder
    pfe?: PFEOrderByWithRelationInput
    groupe?: GroupeOrderByWithRelationInput
  }

  export type PFE_GroupeWhereUniqueInput = Prisma.AtLeast<{
    idPFE_idGroupe?: PFE_GroupeIdPFEIdGroupeCompoundUniqueInput
    AND?: PFE_GroupeWhereInput | PFE_GroupeWhereInput[]
    OR?: PFE_GroupeWhereInput[]
    NOT?: PFE_GroupeWhereInput | PFE_GroupeWhereInput[]
    idPFE?: IntFilter<"PFE_Groupe"> | number
    idGroupe?: IntFilter<"PFE_Groupe"> | number
    pfe?: XOR<PFEScalarRelationFilter, PFEWhereInput>
    groupe?: XOR<GroupeScalarRelationFilter, GroupeWhereInput>
  }, "idPFE_idGroupe">

  export type PFE_GroupeOrderByWithAggregationInput = {
    idPFE?: SortOrder
    idGroupe?: SortOrder
    _count?: PFE_GroupeCountOrderByAggregateInput
    _avg?: PFE_GroupeAvgOrderByAggregateInput
    _max?: PFE_GroupeMaxOrderByAggregateInput
    _min?: PFE_GroupeMinOrderByAggregateInput
    _sum?: PFE_GroupeSumOrderByAggregateInput
  }

  export type PFE_GroupeScalarWhereWithAggregatesInput = {
    AND?: PFE_GroupeScalarWhereWithAggregatesInput | PFE_GroupeScalarWhereWithAggregatesInput[]
    OR?: PFE_GroupeScalarWhereWithAggregatesInput[]
    NOT?: PFE_GroupeScalarWhereWithAggregatesInput | PFE_GroupeScalarWhereWithAggregatesInput[]
    idPFE?: IntWithAggregatesFilter<"PFE_Groupe"> | number
    idGroupe?: IntWithAggregatesFilter<"PFE_Groupe"> | number
  }

  export type PFE_LivrableWhereInput = {
    AND?: PFE_LivrableWhereInput | PFE_LivrableWhereInput[]
    OR?: PFE_LivrableWhereInput[]
    NOT?: PFE_LivrableWhereInput | PFE_LivrableWhereInput[]
    idPFE?: IntFilter<"PFE_Livrable"> | number
    idLivrable?: IntFilter<"PFE_Livrable"> | number
    pfe?: XOR<PFEScalarRelationFilter, PFEWhereInput>
    livrable?: XOR<LivrableScalarRelationFilter, LivrableWhereInput>
  }

  export type PFE_LivrableOrderByWithRelationInput = {
    idPFE?: SortOrder
    idLivrable?: SortOrder
    pfe?: PFEOrderByWithRelationInput
    livrable?: LivrableOrderByWithRelationInput
  }

  export type PFE_LivrableWhereUniqueInput = Prisma.AtLeast<{
    idPFE_idLivrable?: PFE_LivrableIdPFEIdLivrableCompoundUniqueInput
    AND?: PFE_LivrableWhereInput | PFE_LivrableWhereInput[]
    OR?: PFE_LivrableWhereInput[]
    NOT?: PFE_LivrableWhereInput | PFE_LivrableWhereInput[]
    idPFE?: IntFilter<"PFE_Livrable"> | number
    idLivrable?: IntFilter<"PFE_Livrable"> | number
    pfe?: XOR<PFEScalarRelationFilter, PFEWhereInput>
    livrable?: XOR<LivrableScalarRelationFilter, LivrableWhereInput>
  }, "idPFE_idLivrable">

  export type PFE_LivrableOrderByWithAggregationInput = {
    idPFE?: SortOrder
    idLivrable?: SortOrder
    _count?: PFE_LivrableCountOrderByAggregateInput
    _avg?: PFE_LivrableAvgOrderByAggregateInput
    _max?: PFE_LivrableMaxOrderByAggregateInput
    _min?: PFE_LivrableMinOrderByAggregateInput
    _sum?: PFE_LivrableSumOrderByAggregateInput
  }

  export type PFE_LivrableScalarWhereWithAggregatesInput = {
    AND?: PFE_LivrableScalarWhereWithAggregatesInput | PFE_LivrableScalarWhereWithAggregatesInput[]
    OR?: PFE_LivrableScalarWhereWithAggregatesInput[]
    NOT?: PFE_LivrableScalarWhereWithAggregatesInput | PFE_LivrableScalarWhereWithAggregatesInput[]
    idPFE?: IntWithAggregatesFilter<"PFE_Livrable"> | number
    idLivrable?: IntWithAggregatesFilter<"PFE_Livrable"> | number
  }

  export type EncadrantLivrableWhereInput = {
    AND?: EncadrantLivrableWhereInput | EncadrantLivrableWhereInput[]
    OR?: EncadrantLivrableWhereInput[]
    NOT?: EncadrantLivrableWhereInput | EncadrantLivrableWhereInput[]
    idEncadrant?: IntFilter<"EncadrantLivrable"> | number
    idLivrable?: IntFilter<"EncadrantLivrable"> | number
    encadrant?: XOR<EncadrantScalarRelationFilter, EncadrantWhereInput>
    livrable?: XOR<LivrableScalarRelationFilter, LivrableWhereInput>
  }

  export type EncadrantLivrableOrderByWithRelationInput = {
    idEncadrant?: SortOrder
    idLivrable?: SortOrder
    encadrant?: EncadrantOrderByWithRelationInput
    livrable?: LivrableOrderByWithRelationInput
  }

  export type EncadrantLivrableWhereUniqueInput = Prisma.AtLeast<{
    idEncadrant_idLivrable?: EncadrantLivrableIdEncadrantIdLivrableCompoundUniqueInput
    AND?: EncadrantLivrableWhereInput | EncadrantLivrableWhereInput[]
    OR?: EncadrantLivrableWhereInput[]
    NOT?: EncadrantLivrableWhereInput | EncadrantLivrableWhereInput[]
    idEncadrant?: IntFilter<"EncadrantLivrable"> | number
    idLivrable?: IntFilter<"EncadrantLivrable"> | number
    encadrant?: XOR<EncadrantScalarRelationFilter, EncadrantWhereInput>
    livrable?: XOR<LivrableScalarRelationFilter, LivrableWhereInput>
  }, "idEncadrant_idLivrable">

  export type EncadrantLivrableOrderByWithAggregationInput = {
    idEncadrant?: SortOrder
    idLivrable?: SortOrder
    _count?: EncadrantLivrableCountOrderByAggregateInput
    _avg?: EncadrantLivrableAvgOrderByAggregateInput
    _max?: EncadrantLivrableMaxOrderByAggregateInput
    _min?: EncadrantLivrableMinOrderByAggregateInput
    _sum?: EncadrantLivrableSumOrderByAggregateInput
  }

  export type EncadrantLivrableScalarWhereWithAggregatesInput = {
    AND?: EncadrantLivrableScalarWhereWithAggregatesInput | EncadrantLivrableScalarWhereWithAggregatesInput[]
    OR?: EncadrantLivrableScalarWhereWithAggregatesInput[]
    NOT?: EncadrantLivrableScalarWhereWithAggregatesInput | EncadrantLivrableScalarWhereWithAggregatesInput[]
    idEncadrant?: IntWithAggregatesFilter<"EncadrantLivrable"> | number
    idLivrable?: IntWithAggregatesFilter<"EncadrantLivrable"> | number
  }

  export type TuteurLivrableWhereInput = {
    AND?: TuteurLivrableWhereInput | TuteurLivrableWhereInput[]
    OR?: TuteurLivrableWhereInput[]
    NOT?: TuteurLivrableWhereInput | TuteurLivrableWhereInput[]
    idTuteur?: IntFilter<"TuteurLivrable"> | number
    idLivrable?: IntFilter<"TuteurLivrable"> | number
    tuteur?: XOR<TuteurScalarRelationFilter, TuteurWhereInput>
    livrable?: XOR<LivrableScalarRelationFilter, LivrableWhereInput>
  }

  export type TuteurLivrableOrderByWithRelationInput = {
    idTuteur?: SortOrder
    idLivrable?: SortOrder
    tuteur?: TuteurOrderByWithRelationInput
    livrable?: LivrableOrderByWithRelationInput
  }

  export type TuteurLivrableWhereUniqueInput = Prisma.AtLeast<{
    idTuteur_idLivrable?: TuteurLivrableIdTuteurIdLivrableCompoundUniqueInput
    AND?: TuteurLivrableWhereInput | TuteurLivrableWhereInput[]
    OR?: TuteurLivrableWhereInput[]
    NOT?: TuteurLivrableWhereInput | TuteurLivrableWhereInput[]
    idTuteur?: IntFilter<"TuteurLivrable"> | number
    idLivrable?: IntFilter<"TuteurLivrable"> | number
    tuteur?: XOR<TuteurScalarRelationFilter, TuteurWhereInput>
    livrable?: XOR<LivrableScalarRelationFilter, LivrableWhereInput>
  }, "idTuteur_idLivrable">

  export type TuteurLivrableOrderByWithAggregationInput = {
    idTuteur?: SortOrder
    idLivrable?: SortOrder
    _count?: TuteurLivrableCountOrderByAggregateInput
    _avg?: TuteurLivrableAvgOrderByAggregateInput
    _max?: TuteurLivrableMaxOrderByAggregateInput
    _min?: TuteurLivrableMinOrderByAggregateInput
    _sum?: TuteurLivrableSumOrderByAggregateInput
  }

  export type TuteurLivrableScalarWhereWithAggregatesInput = {
    AND?: TuteurLivrableScalarWhereWithAggregatesInput | TuteurLivrableScalarWhereWithAggregatesInput[]
    OR?: TuteurLivrableScalarWhereWithAggregatesInput[]
    NOT?: TuteurLivrableScalarWhereWithAggregatesInput | TuteurLivrableScalarWhereWithAggregatesInput[]
    idTuteur?: IntWithAggregatesFilter<"TuteurLivrable"> | number
    idLivrable?: IntWithAggregatesFilter<"TuteurLivrable"> | number
  }

  export type EncadrantSoutenanceWhereInput = {
    AND?: EncadrantSoutenanceWhereInput | EncadrantSoutenanceWhereInput[]
    OR?: EncadrantSoutenanceWhereInput[]
    NOT?: EncadrantSoutenanceWhereInput | EncadrantSoutenanceWhereInput[]
    idEncadrant?: IntFilter<"EncadrantSoutenance"> | number
    idSoutenance?: IntFilter<"EncadrantSoutenance"> | number
    encadrant?: XOR<EncadrantScalarRelationFilter, EncadrantWhereInput>
    soutenance?: XOR<SoutenanceScalarRelationFilter, SoutenanceWhereInput>
  }

  export type EncadrantSoutenanceOrderByWithRelationInput = {
    idEncadrant?: SortOrder
    idSoutenance?: SortOrder
    encadrant?: EncadrantOrderByWithRelationInput
    soutenance?: SoutenanceOrderByWithRelationInput
  }

  export type EncadrantSoutenanceWhereUniqueInput = Prisma.AtLeast<{
    idEncadrant_idSoutenance?: EncadrantSoutenanceIdEncadrantIdSoutenanceCompoundUniqueInput
    AND?: EncadrantSoutenanceWhereInput | EncadrantSoutenanceWhereInput[]
    OR?: EncadrantSoutenanceWhereInput[]
    NOT?: EncadrantSoutenanceWhereInput | EncadrantSoutenanceWhereInput[]
    idEncadrant?: IntFilter<"EncadrantSoutenance"> | number
    idSoutenance?: IntFilter<"EncadrantSoutenance"> | number
    encadrant?: XOR<EncadrantScalarRelationFilter, EncadrantWhereInput>
    soutenance?: XOR<SoutenanceScalarRelationFilter, SoutenanceWhereInput>
  }, "idEncadrant_idSoutenance">

  export type EncadrantSoutenanceOrderByWithAggregationInput = {
    idEncadrant?: SortOrder
    idSoutenance?: SortOrder
    _count?: EncadrantSoutenanceCountOrderByAggregateInput
    _avg?: EncadrantSoutenanceAvgOrderByAggregateInput
    _max?: EncadrantSoutenanceMaxOrderByAggregateInput
    _min?: EncadrantSoutenanceMinOrderByAggregateInput
    _sum?: EncadrantSoutenanceSumOrderByAggregateInput
  }

  export type EncadrantSoutenanceScalarWhereWithAggregatesInput = {
    AND?: EncadrantSoutenanceScalarWhereWithAggregatesInput | EncadrantSoutenanceScalarWhereWithAggregatesInput[]
    OR?: EncadrantSoutenanceScalarWhereWithAggregatesInput[]
    NOT?: EncadrantSoutenanceScalarWhereWithAggregatesInput | EncadrantSoutenanceScalarWhereWithAggregatesInput[]
    idEncadrant?: IntWithAggregatesFilter<"EncadrantSoutenance"> | number
    idSoutenance?: IntWithAggregatesFilter<"EncadrantSoutenance"> | number
  }

  export type ResponsableFiliereCreateInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    departement: string
    annee: number
    encadrants?: EncadrantCreateNestedManyWithoutResponsableFiliereInput
  }

  export type ResponsableFiliereUncheckedCreateInput = {
    idResponsableFiliere?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    departement: string
    annee: number
    encadrants?: EncadrantUncheckedCreateNestedManyWithoutResponsableFiliereInput
  }

  export type ResponsableFiliereUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    encadrants?: EncadrantUpdateManyWithoutResponsableFiliereNestedInput
  }

  export type ResponsableFiliereUncheckedUpdateInput = {
    idResponsableFiliere?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    encadrants?: EncadrantUncheckedUpdateManyWithoutResponsableFiliereNestedInput
  }

  export type ResponsableFiliereCreateManyInput = {
    idResponsableFiliere?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    departement: string
    annee: number
  }

  export type ResponsableFiliereUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type ResponsableFiliereUncheckedUpdateManyInput = {
    idResponsableFiliere?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantCreateInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    responsableFiliere?: ResponsableFiliereCreateNestedOneWithoutEncadrantsInput
    sujets?: SujetCreateNestedManyWithoutEncadrantInput
    soutenances?: EncadrantSoutenanceCreateNestedManyWithoutEncadrantInput
    livrables?: EncadrantLivrableCreateNestedManyWithoutEncadrantInput
  }

  export type EncadrantUncheckedCreateInput = {
    idEncadrant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    idResponsableFiliere?: number | null
    sujets?: SujetUncheckedCreateNestedManyWithoutEncadrantInput
    soutenances?: EncadrantSoutenanceUncheckedCreateNestedManyWithoutEncadrantInput
    livrables?: EncadrantLivrableUncheckedCreateNestedManyWithoutEncadrantInput
  }

  export type EncadrantUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    responsableFiliere?: ResponsableFiliereUpdateOneWithoutEncadrantsNestedInput
    sujets?: SujetUpdateManyWithoutEncadrantNestedInput
    soutenances?: EncadrantSoutenanceUpdateManyWithoutEncadrantNestedInput
    livrables?: EncadrantLivrableUpdateManyWithoutEncadrantNestedInput
  }

  export type EncadrantUncheckedUpdateInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    idResponsableFiliere?: NullableIntFieldUpdateOperationsInput | number | null
    sujets?: SujetUncheckedUpdateManyWithoutEncadrantNestedInput
    soutenances?: EncadrantSoutenanceUncheckedUpdateManyWithoutEncadrantNestedInput
    livrables?: EncadrantLivrableUncheckedUpdateManyWithoutEncadrantNestedInput
  }

  export type EncadrantCreateManyInput = {
    idEncadrant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    idResponsableFiliere?: number | null
  }

  export type EncadrantUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantUncheckedUpdateManyInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    idResponsableFiliere?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TuteurCreateInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    classe: string
    filiere: string
    annee: number
    PFEs?: PFECreateNestedManyWithoutTuteurInput
    livrables?: TuteurLivrableCreateNestedManyWithoutTuteurInput
  }

  export type TuteurUncheckedCreateInput = {
    idTuteur?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    classe: string
    filiere: string
    annee: number
    PFEs?: PFEUncheckedCreateNestedManyWithoutTuteurInput
    livrables?: TuteurLivrableUncheckedCreateNestedManyWithoutTuteurInput
  }

  export type TuteurUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    PFEs?: PFEUpdateManyWithoutTuteurNestedInput
    livrables?: TuteurLivrableUpdateManyWithoutTuteurNestedInput
  }

  export type TuteurUncheckedUpdateInput = {
    idTuteur?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    PFEs?: PFEUncheckedUpdateManyWithoutTuteurNestedInput
    livrables?: TuteurLivrableUncheckedUpdateManyWithoutTuteurNestedInput
  }

  export type TuteurCreateManyInput = {
    idTuteur?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    classe: string
    filiere: string
    annee: number
  }

  export type TuteurUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type TuteurUncheckedUpdateManyInput = {
    idTuteur?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantCreateInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    classe: string
    filiere: string
    groupes?: EtudiantGroupeCreateNestedManyWithoutEtudiantInput
    sujets?: EtudiantSujetCreateNestedManyWithoutEtudiantInput
    evaluations?: EvaluationCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateInput = {
    idEtudiant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    classe: string
    filiere: string
    groupes?: EtudiantGroupeUncheckedCreateNestedManyWithoutEtudiantInput
    sujets?: EtudiantSujetUncheckedCreateNestedManyWithoutEtudiantInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    groupes?: EtudiantGroupeUpdateManyWithoutEtudiantNestedInput
    sujets?: EtudiantSujetUpdateManyWithoutEtudiantNestedInput
    evaluations?: EvaluationUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    groupes?: EtudiantGroupeUncheckedUpdateManyWithoutEtudiantNestedInput
    sujets?: EtudiantSujetUncheckedUpdateManyWithoutEtudiantNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantCreateManyInput = {
    idEtudiant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    classe: string
    filiere: string
  }

  export type EtudiantUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
  }

  export type EtudiantUncheckedUpdateManyInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
  }

  export type GroupeCreateInput = {
    nomGroupe: string
    nbEtudiants: number
    etudiants?: EtudiantGroupeCreateNestedManyWithoutGroupeInput
    PFEs?: PFE_GroupeCreateNestedManyWithoutGroupeInput
  }

  export type GroupeUncheckedCreateInput = {
    idGroupe?: number
    nomGroupe: string
    nbEtudiants: number
    etudiants?: EtudiantGroupeUncheckedCreateNestedManyWithoutGroupeInput
    PFEs?: PFE_GroupeUncheckedCreateNestedManyWithoutGroupeInput
  }

  export type GroupeUpdateInput = {
    nomGroupe?: StringFieldUpdateOperationsInput | string
    nbEtudiants?: IntFieldUpdateOperationsInput | number
    etudiants?: EtudiantGroupeUpdateManyWithoutGroupeNestedInput
    PFEs?: PFE_GroupeUpdateManyWithoutGroupeNestedInput
  }

  export type GroupeUncheckedUpdateInput = {
    idGroupe?: IntFieldUpdateOperationsInput | number
    nomGroupe?: StringFieldUpdateOperationsInput | string
    nbEtudiants?: IntFieldUpdateOperationsInput | number
    etudiants?: EtudiantGroupeUncheckedUpdateManyWithoutGroupeNestedInput
    PFEs?: PFE_GroupeUncheckedUpdateManyWithoutGroupeNestedInput
  }

  export type GroupeCreateManyInput = {
    idGroupe?: number
    nomGroupe: string
    nbEtudiants: number
  }

  export type GroupeUpdateManyMutationInput = {
    nomGroupe?: StringFieldUpdateOperationsInput | string
    nbEtudiants?: IntFieldUpdateOperationsInput | number
  }

  export type GroupeUncheckedUpdateManyInput = {
    idGroupe?: IntFieldUpdateOperationsInput | number
    nomGroupe?: StringFieldUpdateOperationsInput | string
    nbEtudiants?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantGroupeCreateInput = {
    etudiant: EtudiantCreateNestedOneWithoutGroupesInput
    groupe: GroupeCreateNestedOneWithoutEtudiantsInput
  }

  export type EtudiantGroupeUncheckedCreateInput = {
    idEtudiant: number
    idGroupe: number
  }

  export type EtudiantGroupeUpdateInput = {
    etudiant?: EtudiantUpdateOneRequiredWithoutGroupesNestedInput
    groupe?: GroupeUpdateOneRequiredWithoutEtudiantsNestedInput
  }

  export type EtudiantGroupeUncheckedUpdateInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
    idGroupe?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantGroupeCreateManyInput = {
    idEtudiant: number
    idGroupe: number
  }

  export type EtudiantGroupeUpdateManyMutationInput = {

  }

  export type EtudiantGroupeUncheckedUpdateManyInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
    idGroupe?: IntFieldUpdateOperationsInput | number
  }

  export type SujetCreateInput = {
    titre: string
    description: string
    annee: number
    encadrant: EncadrantCreateNestedOneWithoutSujetsInput
    etudiants?: EtudiantSujetCreateNestedManyWithoutSujetInput
  }

  export type SujetUncheckedCreateInput = {
    idSujet?: number
    titre: string
    description: string
    annee: number
    idEncadrant: number
    etudiants?: EtudiantSujetUncheckedCreateNestedManyWithoutSujetInput
  }

  export type SujetUpdateInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    encadrant?: EncadrantUpdateOneRequiredWithoutSujetsNestedInput
    etudiants?: EtudiantSujetUpdateManyWithoutSujetNestedInput
  }

  export type SujetUncheckedUpdateInput = {
    idSujet?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    idEncadrant?: IntFieldUpdateOperationsInput | number
    etudiants?: EtudiantSujetUncheckedUpdateManyWithoutSujetNestedInput
  }

  export type SujetCreateManyInput = {
    idSujet?: number
    titre: string
    description: string
    annee: number
    idEncadrant: number
  }

  export type SujetUpdateManyMutationInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type SujetUncheckedUpdateManyInput = {
    idSujet?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    idEncadrant?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantSujetCreateInput = {
    etudiant: EtudiantCreateNestedOneWithoutSujetsInput
    sujet: SujetCreateNestedOneWithoutEtudiantsInput
  }

  export type EtudiantSujetUncheckedCreateInput = {
    idEtudiant: number
    idSujet: number
  }

  export type EtudiantSujetUpdateInput = {
    etudiant?: EtudiantUpdateOneRequiredWithoutSujetsNestedInput
    sujet?: SujetUpdateOneRequiredWithoutEtudiantsNestedInput
  }

  export type EtudiantSujetUncheckedUpdateInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
    idSujet?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantSujetCreateManyInput = {
    idEtudiant: number
    idSujet: number
  }

  export type EtudiantSujetUpdateManyMutationInput = {

  }

  export type EtudiantSujetUncheckedUpdateManyInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
    idSujet?: IntFieldUpdateOperationsInput | number
  }

  export type JuryCreateInput = {
    valideDeliberation: boolean
    soutenances?: SoutenanceCreateNestedManyWithoutJuryInput
  }

  export type JuryUncheckedCreateInput = {
    idJury?: number
    valideDeliberation: boolean
    soutenances?: SoutenanceUncheckedCreateNestedManyWithoutJuryInput
  }

  export type JuryUpdateInput = {
    valideDeliberation?: BoolFieldUpdateOperationsInput | boolean
    soutenances?: SoutenanceUpdateManyWithoutJuryNestedInput
  }

  export type JuryUncheckedUpdateInput = {
    idJury?: IntFieldUpdateOperationsInput | number
    valideDeliberation?: BoolFieldUpdateOperationsInput | boolean
    soutenances?: SoutenanceUncheckedUpdateManyWithoutJuryNestedInput
  }

  export type JuryCreateManyInput = {
    idJury?: number
    valideDeliberation: boolean
  }

  export type JuryUpdateManyMutationInput = {
    valideDeliberation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JuryUncheckedUpdateManyInput = {
    idJury?: IntFieldUpdateOperationsInput | number
    valideDeliberation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SoutenanceCreateInput = {
    date: Date | string
    heure: Date | string
    jury: JuryCreateNestedOneWithoutSoutenancesInput
    encadrants?: EncadrantSoutenanceCreateNestedManyWithoutSoutenanceInput
    evaluations?: EvaluationCreateNestedManyWithoutSoutenanceInput
  }

  export type SoutenanceUncheckedCreateInput = {
    idSoutenance?: number
    date: Date | string
    heure: Date | string
    idJury: number
    encadrants?: EncadrantSoutenanceUncheckedCreateNestedManyWithoutSoutenanceInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSoutenanceInput
  }

  export type SoutenanceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
    jury?: JuryUpdateOneRequiredWithoutSoutenancesNestedInput
    encadrants?: EncadrantSoutenanceUpdateManyWithoutSoutenanceNestedInput
    evaluations?: EvaluationUpdateManyWithoutSoutenanceNestedInput
  }

  export type SoutenanceUncheckedUpdateInput = {
    idSoutenance?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
    idJury?: IntFieldUpdateOperationsInput | number
    encadrants?: EncadrantSoutenanceUncheckedUpdateManyWithoutSoutenanceNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutSoutenanceNestedInput
  }

  export type SoutenanceCreateManyInput = {
    idSoutenance?: number
    date: Date | string
    heure: Date | string
    idJury: number
  }

  export type SoutenanceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoutenanceUncheckedUpdateManyInput = {
    idSoutenance?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
    idJury?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluationCreateInput = {
    note: number
    feedback?: string | null
    soutenance: SoutenanceCreateNestedOneWithoutEvaluationsInput
    etudiant: EtudiantCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateInput = {
    idEvaluation?: number
    note: number
    feedback?: string | null
    idSoutenance: number
    idEtudiant: number
  }

  export type EvaluationUpdateInput = {
    note?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    soutenance?: SoutenanceUpdateOneRequiredWithoutEvaluationsNestedInput
    etudiant?: EtudiantUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateInput = {
    idEvaluation?: IntFieldUpdateOperationsInput | number
    note?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    idSoutenance?: IntFieldUpdateOperationsInput | number
    idEtudiant?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluationCreateManyInput = {
    idEvaluation?: number
    note: number
    feedback?: string | null
    idSoutenance: number
    idEtudiant: number
  }

  export type EvaluationUpdateManyMutationInput = {
    note?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaluationUncheckedUpdateManyInput = {
    idEvaluation?: IntFieldUpdateOperationsInput | number
    note?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    idSoutenance?: IntFieldUpdateOperationsInput | number
    idEtudiant?: IntFieldUpdateOperationsInput | number
  }

  export type LivrableCreateInput = {
    type: string
    nom: string
    annee: number
    PFEs?: PFE_LivrableCreateNestedManyWithoutLivrableInput
    encadrants?: EncadrantLivrableCreateNestedManyWithoutLivrableInput
    tuteurs?: TuteurLivrableCreateNestedManyWithoutLivrableInput
  }

  export type LivrableUncheckedCreateInput = {
    idLivrable?: number
    type: string
    nom: string
    annee: number
    PFEs?: PFE_LivrableUncheckedCreateNestedManyWithoutLivrableInput
    encadrants?: EncadrantLivrableUncheckedCreateNestedManyWithoutLivrableInput
    tuteurs?: TuteurLivrableUncheckedCreateNestedManyWithoutLivrableInput
  }

  export type LivrableUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    PFEs?: PFE_LivrableUpdateManyWithoutLivrableNestedInput
    encadrants?: EncadrantLivrableUpdateManyWithoutLivrableNestedInput
    tuteurs?: TuteurLivrableUpdateManyWithoutLivrableNestedInput
  }

  export type LivrableUncheckedUpdateInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    PFEs?: PFE_LivrableUncheckedUpdateManyWithoutLivrableNestedInput
    encadrants?: EncadrantLivrableUncheckedUpdateManyWithoutLivrableNestedInput
    tuteurs?: TuteurLivrableUncheckedUpdateManyWithoutLivrableNestedInput
  }

  export type LivrableCreateManyInput = {
    idLivrable?: number
    type: string
    nom: string
    annee: number
  }

  export type LivrableUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type LivrableUncheckedUpdateManyInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type PFECreateInput = {
    statut: number
    annee: number
    tuteur: TuteurCreateNestedOneWithoutPFEsInput
    groupes?: PFE_GroupeCreateNestedManyWithoutPfeInput
    livrables?: PFE_LivrableCreateNestedManyWithoutPfeInput
  }

  export type PFEUncheckedCreateInput = {
    idPFE?: number
    statut: number
    annee: number
    idTuteur: number
    groupes?: PFE_GroupeUncheckedCreateNestedManyWithoutPfeInput
    livrables?: PFE_LivrableUncheckedCreateNestedManyWithoutPfeInput
  }

  export type PFEUpdateInput = {
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    tuteur?: TuteurUpdateOneRequiredWithoutPFEsNestedInput
    groupes?: PFE_GroupeUpdateManyWithoutPfeNestedInput
    livrables?: PFE_LivrableUpdateManyWithoutPfeNestedInput
  }

  export type PFEUncheckedUpdateInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    idTuteur?: IntFieldUpdateOperationsInput | number
    groupes?: PFE_GroupeUncheckedUpdateManyWithoutPfeNestedInput
    livrables?: PFE_LivrableUncheckedUpdateManyWithoutPfeNestedInput
  }

  export type PFECreateManyInput = {
    idPFE?: number
    statut: number
    annee: number
    idTuteur: number
  }

  export type PFEUpdateManyMutationInput = {
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type PFEUncheckedUpdateManyInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    idTuteur?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_GroupeCreateInput = {
    pfe: PFECreateNestedOneWithoutGroupesInput
    groupe: GroupeCreateNestedOneWithoutPFEsInput
  }

  export type PFE_GroupeUncheckedCreateInput = {
    idPFE: number
    idGroupe: number
  }

  export type PFE_GroupeUpdateInput = {
    pfe?: PFEUpdateOneRequiredWithoutGroupesNestedInput
    groupe?: GroupeUpdateOneRequiredWithoutPFEsNestedInput
  }

  export type PFE_GroupeUncheckedUpdateInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
    idGroupe?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_GroupeCreateManyInput = {
    idPFE: number
    idGroupe: number
  }

  export type PFE_GroupeUpdateManyMutationInput = {

  }

  export type PFE_GroupeUncheckedUpdateManyInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
    idGroupe?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_LivrableCreateInput = {
    pfe: PFECreateNestedOneWithoutLivrablesInput
    livrable: LivrableCreateNestedOneWithoutPFEsInput
  }

  export type PFE_LivrableUncheckedCreateInput = {
    idPFE: number
    idLivrable: number
  }

  export type PFE_LivrableUpdateInput = {
    pfe?: PFEUpdateOneRequiredWithoutLivrablesNestedInput
    livrable?: LivrableUpdateOneRequiredWithoutPFEsNestedInput
  }

  export type PFE_LivrableUncheckedUpdateInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_LivrableCreateManyInput = {
    idPFE: number
    idLivrable: number
  }

  export type PFE_LivrableUpdateManyMutationInput = {

  }

  export type PFE_LivrableUncheckedUpdateManyInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantLivrableCreateInput = {
    encadrant: EncadrantCreateNestedOneWithoutLivrablesInput
    livrable: LivrableCreateNestedOneWithoutEncadrantsInput
  }

  export type EncadrantLivrableUncheckedCreateInput = {
    idEncadrant: number
    idLivrable: number
  }

  export type EncadrantLivrableUpdateInput = {
    encadrant?: EncadrantUpdateOneRequiredWithoutLivrablesNestedInput
    livrable?: LivrableUpdateOneRequiredWithoutEncadrantsNestedInput
  }

  export type EncadrantLivrableUncheckedUpdateInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantLivrableCreateManyInput = {
    idEncadrant: number
    idLivrable: number
  }

  export type EncadrantLivrableUpdateManyMutationInput = {

  }

  export type EncadrantLivrableUncheckedUpdateManyInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type TuteurLivrableCreateInput = {
    tuteur: TuteurCreateNestedOneWithoutLivrablesInput
    livrable: LivrableCreateNestedOneWithoutTuteursInput
  }

  export type TuteurLivrableUncheckedCreateInput = {
    idTuteur: number
    idLivrable: number
  }

  export type TuteurLivrableUpdateInput = {
    tuteur?: TuteurUpdateOneRequiredWithoutLivrablesNestedInput
    livrable?: LivrableUpdateOneRequiredWithoutTuteursNestedInput
  }

  export type TuteurLivrableUncheckedUpdateInput = {
    idTuteur?: IntFieldUpdateOperationsInput | number
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type TuteurLivrableCreateManyInput = {
    idTuteur: number
    idLivrable: number
  }

  export type TuteurLivrableUpdateManyMutationInput = {

  }

  export type TuteurLivrableUncheckedUpdateManyInput = {
    idTuteur?: IntFieldUpdateOperationsInput | number
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantSoutenanceCreateInput = {
    encadrant: EncadrantCreateNestedOneWithoutSoutenancesInput
    soutenance: SoutenanceCreateNestedOneWithoutEncadrantsInput
  }

  export type EncadrantSoutenanceUncheckedCreateInput = {
    idEncadrant: number
    idSoutenance: number
  }

  export type EncadrantSoutenanceUpdateInput = {
    encadrant?: EncadrantUpdateOneRequiredWithoutSoutenancesNestedInput
    soutenance?: SoutenanceUpdateOneRequiredWithoutEncadrantsNestedInput
  }

  export type EncadrantSoutenanceUncheckedUpdateInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    idSoutenance?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantSoutenanceCreateManyInput = {
    idEncadrant: number
    idSoutenance: number
  }

  export type EncadrantSoutenanceUpdateManyMutationInput = {

  }

  export type EncadrantSoutenanceUncheckedUpdateManyInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    idSoutenance?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EncadrantListRelationFilter = {
    every?: EncadrantWhereInput
    some?: EncadrantWhereInput
    none?: EncadrantWhereInput
  }

  export type EncadrantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResponsableFiliereOrderByRelevanceInput = {
    fields: ResponsableFiliereOrderByRelevanceFieldEnum | ResponsableFiliereOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ResponsableFiliereCountOrderByAggregateInput = {
    idResponsableFiliere?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    departement?: SortOrder
    annee?: SortOrder
  }

  export type ResponsableFiliereAvgOrderByAggregateInput = {
    idResponsableFiliere?: SortOrder
    annee?: SortOrder
  }

  export type ResponsableFiliereMaxOrderByAggregateInput = {
    idResponsableFiliere?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    departement?: SortOrder
    annee?: SortOrder
  }

  export type ResponsableFiliereMinOrderByAggregateInput = {
    idResponsableFiliere?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    departement?: SortOrder
    annee?: SortOrder
  }

  export type ResponsableFiliereSumOrderByAggregateInput = {
    idResponsableFiliere?: SortOrder
    annee?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ResponsableFiliereNullableScalarRelationFilter = {
    is?: ResponsableFiliereWhereInput | null
    isNot?: ResponsableFiliereWhereInput | null
  }

  export type SujetListRelationFilter = {
    every?: SujetWhereInput
    some?: SujetWhereInput
    none?: SujetWhereInput
  }

  export type EncadrantSoutenanceListRelationFilter = {
    every?: EncadrantSoutenanceWhereInput
    some?: EncadrantSoutenanceWhereInput
    none?: EncadrantSoutenanceWhereInput
  }

  export type EncadrantLivrableListRelationFilter = {
    every?: EncadrantLivrableWhereInput
    some?: EncadrantLivrableWhereInput
    none?: EncadrantLivrableWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SujetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncadrantSoutenanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncadrantLivrableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncadrantOrderByRelevanceInput = {
    fields: EncadrantOrderByRelevanceFieldEnum | EncadrantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EncadrantCountOrderByAggregateInput = {
    idEncadrant?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    annee?: SortOrder
    idResponsableFiliere?: SortOrder
  }

  export type EncadrantAvgOrderByAggregateInput = {
    idEncadrant?: SortOrder
    annee?: SortOrder
    idResponsableFiliere?: SortOrder
  }

  export type EncadrantMaxOrderByAggregateInput = {
    idEncadrant?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    annee?: SortOrder
    idResponsableFiliere?: SortOrder
  }

  export type EncadrantMinOrderByAggregateInput = {
    idEncadrant?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    annee?: SortOrder
    idResponsableFiliere?: SortOrder
  }

  export type EncadrantSumOrderByAggregateInput = {
    idEncadrant?: SortOrder
    annee?: SortOrder
    idResponsableFiliere?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PFEListRelationFilter = {
    every?: PFEWhereInput
    some?: PFEWhereInput
    none?: PFEWhereInput
  }

  export type TuteurLivrableListRelationFilter = {
    every?: TuteurLivrableWhereInput
    some?: TuteurLivrableWhereInput
    none?: TuteurLivrableWhereInput
  }

  export type PFEOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TuteurLivrableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TuteurOrderByRelevanceInput = {
    fields: TuteurOrderByRelevanceFieldEnum | TuteurOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TuteurCountOrderByAggregateInput = {
    idTuteur?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    classe?: SortOrder
    filiere?: SortOrder
    annee?: SortOrder
  }

  export type TuteurAvgOrderByAggregateInput = {
    idTuteur?: SortOrder
    annee?: SortOrder
  }

  export type TuteurMaxOrderByAggregateInput = {
    idTuteur?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    classe?: SortOrder
    filiere?: SortOrder
    annee?: SortOrder
  }

  export type TuteurMinOrderByAggregateInput = {
    idTuteur?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    classe?: SortOrder
    filiere?: SortOrder
    annee?: SortOrder
  }

  export type TuteurSumOrderByAggregateInput = {
    idTuteur?: SortOrder
    annee?: SortOrder
  }

  export type EtudiantGroupeListRelationFilter = {
    every?: EtudiantGroupeWhereInput
    some?: EtudiantGroupeWhereInput
    none?: EtudiantGroupeWhereInput
  }

  export type EtudiantSujetListRelationFilter = {
    every?: EtudiantSujetWhereInput
    some?: EtudiantSujetWhereInput
    none?: EtudiantSujetWhereInput
  }

  export type EvaluationListRelationFilter = {
    every?: EvaluationWhereInput
    some?: EvaluationWhereInput
    none?: EvaluationWhereInput
  }

  export type EtudiantGroupeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EtudiantSujetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EtudiantOrderByRelevanceInput = {
    fields: EtudiantOrderByRelevanceFieldEnum | EtudiantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EtudiantCountOrderByAggregateInput = {
    idEtudiant?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    annee?: SortOrder
    classe?: SortOrder
    filiere?: SortOrder
  }

  export type EtudiantAvgOrderByAggregateInput = {
    idEtudiant?: SortOrder
    annee?: SortOrder
  }

  export type EtudiantMaxOrderByAggregateInput = {
    idEtudiant?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    annee?: SortOrder
    classe?: SortOrder
    filiere?: SortOrder
  }

  export type EtudiantMinOrderByAggregateInput = {
    idEtudiant?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    annee?: SortOrder
    classe?: SortOrder
    filiere?: SortOrder
  }

  export type EtudiantSumOrderByAggregateInput = {
    idEtudiant?: SortOrder
    annee?: SortOrder
  }

  export type PFE_GroupeListRelationFilter = {
    every?: PFE_GroupeWhereInput
    some?: PFE_GroupeWhereInput
    none?: PFE_GroupeWhereInput
  }

  export type PFE_GroupeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupeOrderByRelevanceInput = {
    fields: GroupeOrderByRelevanceFieldEnum | GroupeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GroupeCountOrderByAggregateInput = {
    idGroupe?: SortOrder
    nomGroupe?: SortOrder
    nbEtudiants?: SortOrder
  }

  export type GroupeAvgOrderByAggregateInput = {
    idGroupe?: SortOrder
    nbEtudiants?: SortOrder
  }

  export type GroupeMaxOrderByAggregateInput = {
    idGroupe?: SortOrder
    nomGroupe?: SortOrder
    nbEtudiants?: SortOrder
  }

  export type GroupeMinOrderByAggregateInput = {
    idGroupe?: SortOrder
    nomGroupe?: SortOrder
    nbEtudiants?: SortOrder
  }

  export type GroupeSumOrderByAggregateInput = {
    idGroupe?: SortOrder
    nbEtudiants?: SortOrder
  }

  export type EtudiantScalarRelationFilter = {
    is?: EtudiantWhereInput
    isNot?: EtudiantWhereInput
  }

  export type GroupeScalarRelationFilter = {
    is?: GroupeWhereInput
    isNot?: GroupeWhereInput
  }

  export type EtudiantGroupeIdEtudiantIdGroupeCompoundUniqueInput = {
    idEtudiant: number
    idGroupe: number
  }

  export type EtudiantGroupeCountOrderByAggregateInput = {
    idEtudiant?: SortOrder
    idGroupe?: SortOrder
  }

  export type EtudiantGroupeAvgOrderByAggregateInput = {
    idEtudiant?: SortOrder
    idGroupe?: SortOrder
  }

  export type EtudiantGroupeMaxOrderByAggregateInput = {
    idEtudiant?: SortOrder
    idGroupe?: SortOrder
  }

  export type EtudiantGroupeMinOrderByAggregateInput = {
    idEtudiant?: SortOrder
    idGroupe?: SortOrder
  }

  export type EtudiantGroupeSumOrderByAggregateInput = {
    idEtudiant?: SortOrder
    idGroupe?: SortOrder
  }

  export type EncadrantScalarRelationFilter = {
    is?: EncadrantWhereInput
    isNot?: EncadrantWhereInput
  }

  export type SujetOrderByRelevanceInput = {
    fields: SujetOrderByRelevanceFieldEnum | SujetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SujetCountOrderByAggregateInput = {
    idSujet?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    annee?: SortOrder
    idEncadrant?: SortOrder
  }

  export type SujetAvgOrderByAggregateInput = {
    idSujet?: SortOrder
    annee?: SortOrder
    idEncadrant?: SortOrder
  }

  export type SujetMaxOrderByAggregateInput = {
    idSujet?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    annee?: SortOrder
    idEncadrant?: SortOrder
  }

  export type SujetMinOrderByAggregateInput = {
    idSujet?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    annee?: SortOrder
    idEncadrant?: SortOrder
  }

  export type SujetSumOrderByAggregateInput = {
    idSujet?: SortOrder
    annee?: SortOrder
    idEncadrant?: SortOrder
  }

  export type SujetScalarRelationFilter = {
    is?: SujetWhereInput
    isNot?: SujetWhereInput
  }

  export type EtudiantSujetIdEtudiantIdSujetCompoundUniqueInput = {
    idEtudiant: number
    idSujet: number
  }

  export type EtudiantSujetCountOrderByAggregateInput = {
    idEtudiant?: SortOrder
    idSujet?: SortOrder
  }

  export type EtudiantSujetAvgOrderByAggregateInput = {
    idEtudiant?: SortOrder
    idSujet?: SortOrder
  }

  export type EtudiantSujetMaxOrderByAggregateInput = {
    idEtudiant?: SortOrder
    idSujet?: SortOrder
  }

  export type EtudiantSujetMinOrderByAggregateInput = {
    idEtudiant?: SortOrder
    idSujet?: SortOrder
  }

  export type EtudiantSujetSumOrderByAggregateInput = {
    idEtudiant?: SortOrder
    idSujet?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SoutenanceListRelationFilter = {
    every?: SoutenanceWhereInput
    some?: SoutenanceWhereInput
    none?: SoutenanceWhereInput
  }

  export type SoutenanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JuryCountOrderByAggregateInput = {
    idJury?: SortOrder
    valideDeliberation?: SortOrder
  }

  export type JuryAvgOrderByAggregateInput = {
    idJury?: SortOrder
  }

  export type JuryMaxOrderByAggregateInput = {
    idJury?: SortOrder
    valideDeliberation?: SortOrder
  }

  export type JuryMinOrderByAggregateInput = {
    idJury?: SortOrder
    valideDeliberation?: SortOrder
  }

  export type JurySumOrderByAggregateInput = {
    idJury?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type JuryScalarRelationFilter = {
    is?: JuryWhereInput
    isNot?: JuryWhereInput
  }

  export type SoutenanceCountOrderByAggregateInput = {
    idSoutenance?: SortOrder
    date?: SortOrder
    heure?: SortOrder
    idJury?: SortOrder
  }

  export type SoutenanceAvgOrderByAggregateInput = {
    idSoutenance?: SortOrder
    idJury?: SortOrder
  }

  export type SoutenanceMaxOrderByAggregateInput = {
    idSoutenance?: SortOrder
    date?: SortOrder
    heure?: SortOrder
    idJury?: SortOrder
  }

  export type SoutenanceMinOrderByAggregateInput = {
    idSoutenance?: SortOrder
    date?: SortOrder
    heure?: SortOrder
    idJury?: SortOrder
  }

  export type SoutenanceSumOrderByAggregateInput = {
    idSoutenance?: SortOrder
    idJury?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SoutenanceScalarRelationFilter = {
    is?: SoutenanceWhereInput
    isNot?: SoutenanceWhereInput
  }

  export type EvaluationOrderByRelevanceInput = {
    fields: EvaluationOrderByRelevanceFieldEnum | EvaluationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EvaluationCountOrderByAggregateInput = {
    idEvaluation?: SortOrder
    note?: SortOrder
    feedback?: SortOrder
    idSoutenance?: SortOrder
    idEtudiant?: SortOrder
  }

  export type EvaluationAvgOrderByAggregateInput = {
    idEvaluation?: SortOrder
    note?: SortOrder
    idSoutenance?: SortOrder
    idEtudiant?: SortOrder
  }

  export type EvaluationMaxOrderByAggregateInput = {
    idEvaluation?: SortOrder
    note?: SortOrder
    feedback?: SortOrder
    idSoutenance?: SortOrder
    idEtudiant?: SortOrder
  }

  export type EvaluationMinOrderByAggregateInput = {
    idEvaluation?: SortOrder
    note?: SortOrder
    feedback?: SortOrder
    idSoutenance?: SortOrder
    idEtudiant?: SortOrder
  }

  export type EvaluationSumOrderByAggregateInput = {
    idEvaluation?: SortOrder
    note?: SortOrder
    idSoutenance?: SortOrder
    idEtudiant?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PFE_LivrableListRelationFilter = {
    every?: PFE_LivrableWhereInput
    some?: PFE_LivrableWhereInput
    none?: PFE_LivrableWhereInput
  }

  export type PFE_LivrableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LivrableOrderByRelevanceInput = {
    fields: LivrableOrderByRelevanceFieldEnum | LivrableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LivrableCountOrderByAggregateInput = {
    idLivrable?: SortOrder
    type?: SortOrder
    nom?: SortOrder
    annee?: SortOrder
  }

  export type LivrableAvgOrderByAggregateInput = {
    idLivrable?: SortOrder
    annee?: SortOrder
  }

  export type LivrableMaxOrderByAggregateInput = {
    idLivrable?: SortOrder
    type?: SortOrder
    nom?: SortOrder
    annee?: SortOrder
  }

  export type LivrableMinOrderByAggregateInput = {
    idLivrable?: SortOrder
    type?: SortOrder
    nom?: SortOrder
    annee?: SortOrder
  }

  export type LivrableSumOrderByAggregateInput = {
    idLivrable?: SortOrder
    annee?: SortOrder
  }

  export type TuteurScalarRelationFilter = {
    is?: TuteurWhereInput
    isNot?: TuteurWhereInput
  }

  export type PFECountOrderByAggregateInput = {
    idPFE?: SortOrder
    statut?: SortOrder
    annee?: SortOrder
    idTuteur?: SortOrder
  }

  export type PFEAvgOrderByAggregateInput = {
    idPFE?: SortOrder
    statut?: SortOrder
    annee?: SortOrder
    idTuteur?: SortOrder
  }

  export type PFEMaxOrderByAggregateInput = {
    idPFE?: SortOrder
    statut?: SortOrder
    annee?: SortOrder
    idTuteur?: SortOrder
  }

  export type PFEMinOrderByAggregateInput = {
    idPFE?: SortOrder
    statut?: SortOrder
    annee?: SortOrder
    idTuteur?: SortOrder
  }

  export type PFESumOrderByAggregateInput = {
    idPFE?: SortOrder
    statut?: SortOrder
    annee?: SortOrder
    idTuteur?: SortOrder
  }

  export type PFEScalarRelationFilter = {
    is?: PFEWhereInput
    isNot?: PFEWhereInput
  }

  export type PFE_GroupeIdPFEIdGroupeCompoundUniqueInput = {
    idPFE: number
    idGroupe: number
  }

  export type PFE_GroupeCountOrderByAggregateInput = {
    idPFE?: SortOrder
    idGroupe?: SortOrder
  }

  export type PFE_GroupeAvgOrderByAggregateInput = {
    idPFE?: SortOrder
    idGroupe?: SortOrder
  }

  export type PFE_GroupeMaxOrderByAggregateInput = {
    idPFE?: SortOrder
    idGroupe?: SortOrder
  }

  export type PFE_GroupeMinOrderByAggregateInput = {
    idPFE?: SortOrder
    idGroupe?: SortOrder
  }

  export type PFE_GroupeSumOrderByAggregateInput = {
    idPFE?: SortOrder
    idGroupe?: SortOrder
  }

  export type LivrableScalarRelationFilter = {
    is?: LivrableWhereInput
    isNot?: LivrableWhereInput
  }

  export type PFE_LivrableIdPFEIdLivrableCompoundUniqueInput = {
    idPFE: number
    idLivrable: number
  }

  export type PFE_LivrableCountOrderByAggregateInput = {
    idPFE?: SortOrder
    idLivrable?: SortOrder
  }

  export type PFE_LivrableAvgOrderByAggregateInput = {
    idPFE?: SortOrder
    idLivrable?: SortOrder
  }

  export type PFE_LivrableMaxOrderByAggregateInput = {
    idPFE?: SortOrder
    idLivrable?: SortOrder
  }

  export type PFE_LivrableMinOrderByAggregateInput = {
    idPFE?: SortOrder
    idLivrable?: SortOrder
  }

  export type PFE_LivrableSumOrderByAggregateInput = {
    idPFE?: SortOrder
    idLivrable?: SortOrder
  }

  export type EncadrantLivrableIdEncadrantIdLivrableCompoundUniqueInput = {
    idEncadrant: number
    idLivrable: number
  }

  export type EncadrantLivrableCountOrderByAggregateInput = {
    idEncadrant?: SortOrder
    idLivrable?: SortOrder
  }

  export type EncadrantLivrableAvgOrderByAggregateInput = {
    idEncadrant?: SortOrder
    idLivrable?: SortOrder
  }

  export type EncadrantLivrableMaxOrderByAggregateInput = {
    idEncadrant?: SortOrder
    idLivrable?: SortOrder
  }

  export type EncadrantLivrableMinOrderByAggregateInput = {
    idEncadrant?: SortOrder
    idLivrable?: SortOrder
  }

  export type EncadrantLivrableSumOrderByAggregateInput = {
    idEncadrant?: SortOrder
    idLivrable?: SortOrder
  }

  export type TuteurLivrableIdTuteurIdLivrableCompoundUniqueInput = {
    idTuteur: number
    idLivrable: number
  }

  export type TuteurLivrableCountOrderByAggregateInput = {
    idTuteur?: SortOrder
    idLivrable?: SortOrder
  }

  export type TuteurLivrableAvgOrderByAggregateInput = {
    idTuteur?: SortOrder
    idLivrable?: SortOrder
  }

  export type TuteurLivrableMaxOrderByAggregateInput = {
    idTuteur?: SortOrder
    idLivrable?: SortOrder
  }

  export type TuteurLivrableMinOrderByAggregateInput = {
    idTuteur?: SortOrder
    idLivrable?: SortOrder
  }

  export type TuteurLivrableSumOrderByAggregateInput = {
    idTuteur?: SortOrder
    idLivrable?: SortOrder
  }

  export type EncadrantSoutenanceIdEncadrantIdSoutenanceCompoundUniqueInput = {
    idEncadrant: number
    idSoutenance: number
  }

  export type EncadrantSoutenanceCountOrderByAggregateInput = {
    idEncadrant?: SortOrder
    idSoutenance?: SortOrder
  }

  export type EncadrantSoutenanceAvgOrderByAggregateInput = {
    idEncadrant?: SortOrder
    idSoutenance?: SortOrder
  }

  export type EncadrantSoutenanceMaxOrderByAggregateInput = {
    idEncadrant?: SortOrder
    idSoutenance?: SortOrder
  }

  export type EncadrantSoutenanceMinOrderByAggregateInput = {
    idEncadrant?: SortOrder
    idSoutenance?: SortOrder
  }

  export type EncadrantSoutenanceSumOrderByAggregateInput = {
    idEncadrant?: SortOrder
    idSoutenance?: SortOrder
  }

  export type EncadrantCreateNestedManyWithoutResponsableFiliereInput = {
    create?: XOR<EncadrantCreateWithoutResponsableFiliereInput, EncadrantUncheckedCreateWithoutResponsableFiliereInput> | EncadrantCreateWithoutResponsableFiliereInput[] | EncadrantUncheckedCreateWithoutResponsableFiliereInput[]
    connectOrCreate?: EncadrantCreateOrConnectWithoutResponsableFiliereInput | EncadrantCreateOrConnectWithoutResponsableFiliereInput[]
    createMany?: EncadrantCreateManyResponsableFiliereInputEnvelope
    connect?: EncadrantWhereUniqueInput | EncadrantWhereUniqueInput[]
  }

  export type EncadrantUncheckedCreateNestedManyWithoutResponsableFiliereInput = {
    create?: XOR<EncadrantCreateWithoutResponsableFiliereInput, EncadrantUncheckedCreateWithoutResponsableFiliereInput> | EncadrantCreateWithoutResponsableFiliereInput[] | EncadrantUncheckedCreateWithoutResponsableFiliereInput[]
    connectOrCreate?: EncadrantCreateOrConnectWithoutResponsableFiliereInput | EncadrantCreateOrConnectWithoutResponsableFiliereInput[]
    createMany?: EncadrantCreateManyResponsableFiliereInputEnvelope
    connect?: EncadrantWhereUniqueInput | EncadrantWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EncadrantUpdateManyWithoutResponsableFiliereNestedInput = {
    create?: XOR<EncadrantCreateWithoutResponsableFiliereInput, EncadrantUncheckedCreateWithoutResponsableFiliereInput> | EncadrantCreateWithoutResponsableFiliereInput[] | EncadrantUncheckedCreateWithoutResponsableFiliereInput[]
    connectOrCreate?: EncadrantCreateOrConnectWithoutResponsableFiliereInput | EncadrantCreateOrConnectWithoutResponsableFiliereInput[]
    upsert?: EncadrantUpsertWithWhereUniqueWithoutResponsableFiliereInput | EncadrantUpsertWithWhereUniqueWithoutResponsableFiliereInput[]
    createMany?: EncadrantCreateManyResponsableFiliereInputEnvelope
    set?: EncadrantWhereUniqueInput | EncadrantWhereUniqueInput[]
    disconnect?: EncadrantWhereUniqueInput | EncadrantWhereUniqueInput[]
    delete?: EncadrantWhereUniqueInput | EncadrantWhereUniqueInput[]
    connect?: EncadrantWhereUniqueInput | EncadrantWhereUniqueInput[]
    update?: EncadrantUpdateWithWhereUniqueWithoutResponsableFiliereInput | EncadrantUpdateWithWhereUniqueWithoutResponsableFiliereInput[]
    updateMany?: EncadrantUpdateManyWithWhereWithoutResponsableFiliereInput | EncadrantUpdateManyWithWhereWithoutResponsableFiliereInput[]
    deleteMany?: EncadrantScalarWhereInput | EncadrantScalarWhereInput[]
  }

  export type EncadrantUncheckedUpdateManyWithoutResponsableFiliereNestedInput = {
    create?: XOR<EncadrantCreateWithoutResponsableFiliereInput, EncadrantUncheckedCreateWithoutResponsableFiliereInput> | EncadrantCreateWithoutResponsableFiliereInput[] | EncadrantUncheckedCreateWithoutResponsableFiliereInput[]
    connectOrCreate?: EncadrantCreateOrConnectWithoutResponsableFiliereInput | EncadrantCreateOrConnectWithoutResponsableFiliereInput[]
    upsert?: EncadrantUpsertWithWhereUniqueWithoutResponsableFiliereInput | EncadrantUpsertWithWhereUniqueWithoutResponsableFiliereInput[]
    createMany?: EncadrantCreateManyResponsableFiliereInputEnvelope
    set?: EncadrantWhereUniqueInput | EncadrantWhereUniqueInput[]
    disconnect?: EncadrantWhereUniqueInput | EncadrantWhereUniqueInput[]
    delete?: EncadrantWhereUniqueInput | EncadrantWhereUniqueInput[]
    connect?: EncadrantWhereUniqueInput | EncadrantWhereUniqueInput[]
    update?: EncadrantUpdateWithWhereUniqueWithoutResponsableFiliereInput | EncadrantUpdateWithWhereUniqueWithoutResponsableFiliereInput[]
    updateMany?: EncadrantUpdateManyWithWhereWithoutResponsableFiliereInput | EncadrantUpdateManyWithWhereWithoutResponsableFiliereInput[]
    deleteMany?: EncadrantScalarWhereInput | EncadrantScalarWhereInput[]
  }

  export type ResponsableFiliereCreateNestedOneWithoutEncadrantsInput = {
    create?: XOR<ResponsableFiliereCreateWithoutEncadrantsInput, ResponsableFiliereUncheckedCreateWithoutEncadrantsInput>
    connectOrCreate?: ResponsableFiliereCreateOrConnectWithoutEncadrantsInput
    connect?: ResponsableFiliereWhereUniqueInput
  }

  export type SujetCreateNestedManyWithoutEncadrantInput = {
    create?: XOR<SujetCreateWithoutEncadrantInput, SujetUncheckedCreateWithoutEncadrantInput> | SujetCreateWithoutEncadrantInput[] | SujetUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: SujetCreateOrConnectWithoutEncadrantInput | SujetCreateOrConnectWithoutEncadrantInput[]
    createMany?: SujetCreateManyEncadrantInputEnvelope
    connect?: SujetWhereUniqueInput | SujetWhereUniqueInput[]
  }

  export type EncadrantSoutenanceCreateNestedManyWithoutEncadrantInput = {
    create?: XOR<EncadrantSoutenanceCreateWithoutEncadrantInput, EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput> | EncadrantSoutenanceCreateWithoutEncadrantInput[] | EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: EncadrantSoutenanceCreateOrConnectWithoutEncadrantInput | EncadrantSoutenanceCreateOrConnectWithoutEncadrantInput[]
    createMany?: EncadrantSoutenanceCreateManyEncadrantInputEnvelope
    connect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
  }

  export type EncadrantLivrableCreateNestedManyWithoutEncadrantInput = {
    create?: XOR<EncadrantLivrableCreateWithoutEncadrantInput, EncadrantLivrableUncheckedCreateWithoutEncadrantInput> | EncadrantLivrableCreateWithoutEncadrantInput[] | EncadrantLivrableUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: EncadrantLivrableCreateOrConnectWithoutEncadrantInput | EncadrantLivrableCreateOrConnectWithoutEncadrantInput[]
    createMany?: EncadrantLivrableCreateManyEncadrantInputEnvelope
    connect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
  }

  export type SujetUncheckedCreateNestedManyWithoutEncadrantInput = {
    create?: XOR<SujetCreateWithoutEncadrantInput, SujetUncheckedCreateWithoutEncadrantInput> | SujetCreateWithoutEncadrantInput[] | SujetUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: SujetCreateOrConnectWithoutEncadrantInput | SujetCreateOrConnectWithoutEncadrantInput[]
    createMany?: SujetCreateManyEncadrantInputEnvelope
    connect?: SujetWhereUniqueInput | SujetWhereUniqueInput[]
  }

  export type EncadrantSoutenanceUncheckedCreateNestedManyWithoutEncadrantInput = {
    create?: XOR<EncadrantSoutenanceCreateWithoutEncadrantInput, EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput> | EncadrantSoutenanceCreateWithoutEncadrantInput[] | EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: EncadrantSoutenanceCreateOrConnectWithoutEncadrantInput | EncadrantSoutenanceCreateOrConnectWithoutEncadrantInput[]
    createMany?: EncadrantSoutenanceCreateManyEncadrantInputEnvelope
    connect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
  }

  export type EncadrantLivrableUncheckedCreateNestedManyWithoutEncadrantInput = {
    create?: XOR<EncadrantLivrableCreateWithoutEncadrantInput, EncadrantLivrableUncheckedCreateWithoutEncadrantInput> | EncadrantLivrableCreateWithoutEncadrantInput[] | EncadrantLivrableUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: EncadrantLivrableCreateOrConnectWithoutEncadrantInput | EncadrantLivrableCreateOrConnectWithoutEncadrantInput[]
    createMany?: EncadrantLivrableCreateManyEncadrantInputEnvelope
    connect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
  }

  export type ResponsableFiliereUpdateOneWithoutEncadrantsNestedInput = {
    create?: XOR<ResponsableFiliereCreateWithoutEncadrantsInput, ResponsableFiliereUncheckedCreateWithoutEncadrantsInput>
    connectOrCreate?: ResponsableFiliereCreateOrConnectWithoutEncadrantsInput
    upsert?: ResponsableFiliereUpsertWithoutEncadrantsInput
    disconnect?: ResponsableFiliereWhereInput | boolean
    delete?: ResponsableFiliereWhereInput | boolean
    connect?: ResponsableFiliereWhereUniqueInput
    update?: XOR<XOR<ResponsableFiliereUpdateToOneWithWhereWithoutEncadrantsInput, ResponsableFiliereUpdateWithoutEncadrantsInput>, ResponsableFiliereUncheckedUpdateWithoutEncadrantsInput>
  }

  export type SujetUpdateManyWithoutEncadrantNestedInput = {
    create?: XOR<SujetCreateWithoutEncadrantInput, SujetUncheckedCreateWithoutEncadrantInput> | SujetCreateWithoutEncadrantInput[] | SujetUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: SujetCreateOrConnectWithoutEncadrantInput | SujetCreateOrConnectWithoutEncadrantInput[]
    upsert?: SujetUpsertWithWhereUniqueWithoutEncadrantInput | SujetUpsertWithWhereUniqueWithoutEncadrantInput[]
    createMany?: SujetCreateManyEncadrantInputEnvelope
    set?: SujetWhereUniqueInput | SujetWhereUniqueInput[]
    disconnect?: SujetWhereUniqueInput | SujetWhereUniqueInput[]
    delete?: SujetWhereUniqueInput | SujetWhereUniqueInput[]
    connect?: SujetWhereUniqueInput | SujetWhereUniqueInput[]
    update?: SujetUpdateWithWhereUniqueWithoutEncadrantInput | SujetUpdateWithWhereUniqueWithoutEncadrantInput[]
    updateMany?: SujetUpdateManyWithWhereWithoutEncadrantInput | SujetUpdateManyWithWhereWithoutEncadrantInput[]
    deleteMany?: SujetScalarWhereInput | SujetScalarWhereInput[]
  }

  export type EncadrantSoutenanceUpdateManyWithoutEncadrantNestedInput = {
    create?: XOR<EncadrantSoutenanceCreateWithoutEncadrantInput, EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput> | EncadrantSoutenanceCreateWithoutEncadrantInput[] | EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: EncadrantSoutenanceCreateOrConnectWithoutEncadrantInput | EncadrantSoutenanceCreateOrConnectWithoutEncadrantInput[]
    upsert?: EncadrantSoutenanceUpsertWithWhereUniqueWithoutEncadrantInput | EncadrantSoutenanceUpsertWithWhereUniqueWithoutEncadrantInput[]
    createMany?: EncadrantSoutenanceCreateManyEncadrantInputEnvelope
    set?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    disconnect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    delete?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    connect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    update?: EncadrantSoutenanceUpdateWithWhereUniqueWithoutEncadrantInput | EncadrantSoutenanceUpdateWithWhereUniqueWithoutEncadrantInput[]
    updateMany?: EncadrantSoutenanceUpdateManyWithWhereWithoutEncadrantInput | EncadrantSoutenanceUpdateManyWithWhereWithoutEncadrantInput[]
    deleteMany?: EncadrantSoutenanceScalarWhereInput | EncadrantSoutenanceScalarWhereInput[]
  }

  export type EncadrantLivrableUpdateManyWithoutEncadrantNestedInput = {
    create?: XOR<EncadrantLivrableCreateWithoutEncadrantInput, EncadrantLivrableUncheckedCreateWithoutEncadrantInput> | EncadrantLivrableCreateWithoutEncadrantInput[] | EncadrantLivrableUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: EncadrantLivrableCreateOrConnectWithoutEncadrantInput | EncadrantLivrableCreateOrConnectWithoutEncadrantInput[]
    upsert?: EncadrantLivrableUpsertWithWhereUniqueWithoutEncadrantInput | EncadrantLivrableUpsertWithWhereUniqueWithoutEncadrantInput[]
    createMany?: EncadrantLivrableCreateManyEncadrantInputEnvelope
    set?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    disconnect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    delete?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    connect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    update?: EncadrantLivrableUpdateWithWhereUniqueWithoutEncadrantInput | EncadrantLivrableUpdateWithWhereUniqueWithoutEncadrantInput[]
    updateMany?: EncadrantLivrableUpdateManyWithWhereWithoutEncadrantInput | EncadrantLivrableUpdateManyWithWhereWithoutEncadrantInput[]
    deleteMany?: EncadrantLivrableScalarWhereInput | EncadrantLivrableScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SujetUncheckedUpdateManyWithoutEncadrantNestedInput = {
    create?: XOR<SujetCreateWithoutEncadrantInput, SujetUncheckedCreateWithoutEncadrantInput> | SujetCreateWithoutEncadrantInput[] | SujetUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: SujetCreateOrConnectWithoutEncadrantInput | SujetCreateOrConnectWithoutEncadrantInput[]
    upsert?: SujetUpsertWithWhereUniqueWithoutEncadrantInput | SujetUpsertWithWhereUniqueWithoutEncadrantInput[]
    createMany?: SujetCreateManyEncadrantInputEnvelope
    set?: SujetWhereUniqueInput | SujetWhereUniqueInput[]
    disconnect?: SujetWhereUniqueInput | SujetWhereUniqueInput[]
    delete?: SujetWhereUniqueInput | SujetWhereUniqueInput[]
    connect?: SujetWhereUniqueInput | SujetWhereUniqueInput[]
    update?: SujetUpdateWithWhereUniqueWithoutEncadrantInput | SujetUpdateWithWhereUniqueWithoutEncadrantInput[]
    updateMany?: SujetUpdateManyWithWhereWithoutEncadrantInput | SujetUpdateManyWithWhereWithoutEncadrantInput[]
    deleteMany?: SujetScalarWhereInput | SujetScalarWhereInput[]
  }

  export type EncadrantSoutenanceUncheckedUpdateManyWithoutEncadrantNestedInput = {
    create?: XOR<EncadrantSoutenanceCreateWithoutEncadrantInput, EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput> | EncadrantSoutenanceCreateWithoutEncadrantInput[] | EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: EncadrantSoutenanceCreateOrConnectWithoutEncadrantInput | EncadrantSoutenanceCreateOrConnectWithoutEncadrantInput[]
    upsert?: EncadrantSoutenanceUpsertWithWhereUniqueWithoutEncadrantInput | EncadrantSoutenanceUpsertWithWhereUniqueWithoutEncadrantInput[]
    createMany?: EncadrantSoutenanceCreateManyEncadrantInputEnvelope
    set?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    disconnect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    delete?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    connect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    update?: EncadrantSoutenanceUpdateWithWhereUniqueWithoutEncadrantInput | EncadrantSoutenanceUpdateWithWhereUniqueWithoutEncadrantInput[]
    updateMany?: EncadrantSoutenanceUpdateManyWithWhereWithoutEncadrantInput | EncadrantSoutenanceUpdateManyWithWhereWithoutEncadrantInput[]
    deleteMany?: EncadrantSoutenanceScalarWhereInput | EncadrantSoutenanceScalarWhereInput[]
  }

  export type EncadrantLivrableUncheckedUpdateManyWithoutEncadrantNestedInput = {
    create?: XOR<EncadrantLivrableCreateWithoutEncadrantInput, EncadrantLivrableUncheckedCreateWithoutEncadrantInput> | EncadrantLivrableCreateWithoutEncadrantInput[] | EncadrantLivrableUncheckedCreateWithoutEncadrantInput[]
    connectOrCreate?: EncadrantLivrableCreateOrConnectWithoutEncadrantInput | EncadrantLivrableCreateOrConnectWithoutEncadrantInput[]
    upsert?: EncadrantLivrableUpsertWithWhereUniqueWithoutEncadrantInput | EncadrantLivrableUpsertWithWhereUniqueWithoutEncadrantInput[]
    createMany?: EncadrantLivrableCreateManyEncadrantInputEnvelope
    set?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    disconnect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    delete?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    connect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    update?: EncadrantLivrableUpdateWithWhereUniqueWithoutEncadrantInput | EncadrantLivrableUpdateWithWhereUniqueWithoutEncadrantInput[]
    updateMany?: EncadrantLivrableUpdateManyWithWhereWithoutEncadrantInput | EncadrantLivrableUpdateManyWithWhereWithoutEncadrantInput[]
    deleteMany?: EncadrantLivrableScalarWhereInput | EncadrantLivrableScalarWhereInput[]
  }

  export type PFECreateNestedManyWithoutTuteurInput = {
    create?: XOR<PFECreateWithoutTuteurInput, PFEUncheckedCreateWithoutTuteurInput> | PFECreateWithoutTuteurInput[] | PFEUncheckedCreateWithoutTuteurInput[]
    connectOrCreate?: PFECreateOrConnectWithoutTuteurInput | PFECreateOrConnectWithoutTuteurInput[]
    createMany?: PFECreateManyTuteurInputEnvelope
    connect?: PFEWhereUniqueInput | PFEWhereUniqueInput[]
  }

  export type TuteurLivrableCreateNestedManyWithoutTuteurInput = {
    create?: XOR<TuteurLivrableCreateWithoutTuteurInput, TuteurLivrableUncheckedCreateWithoutTuteurInput> | TuteurLivrableCreateWithoutTuteurInput[] | TuteurLivrableUncheckedCreateWithoutTuteurInput[]
    connectOrCreate?: TuteurLivrableCreateOrConnectWithoutTuteurInput | TuteurLivrableCreateOrConnectWithoutTuteurInput[]
    createMany?: TuteurLivrableCreateManyTuteurInputEnvelope
    connect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
  }

  export type PFEUncheckedCreateNestedManyWithoutTuteurInput = {
    create?: XOR<PFECreateWithoutTuteurInput, PFEUncheckedCreateWithoutTuteurInput> | PFECreateWithoutTuteurInput[] | PFEUncheckedCreateWithoutTuteurInput[]
    connectOrCreate?: PFECreateOrConnectWithoutTuteurInput | PFECreateOrConnectWithoutTuteurInput[]
    createMany?: PFECreateManyTuteurInputEnvelope
    connect?: PFEWhereUniqueInput | PFEWhereUniqueInput[]
  }

  export type TuteurLivrableUncheckedCreateNestedManyWithoutTuteurInput = {
    create?: XOR<TuteurLivrableCreateWithoutTuteurInput, TuteurLivrableUncheckedCreateWithoutTuteurInput> | TuteurLivrableCreateWithoutTuteurInput[] | TuteurLivrableUncheckedCreateWithoutTuteurInput[]
    connectOrCreate?: TuteurLivrableCreateOrConnectWithoutTuteurInput | TuteurLivrableCreateOrConnectWithoutTuteurInput[]
    createMany?: TuteurLivrableCreateManyTuteurInputEnvelope
    connect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
  }

  export type PFEUpdateManyWithoutTuteurNestedInput = {
    create?: XOR<PFECreateWithoutTuteurInput, PFEUncheckedCreateWithoutTuteurInput> | PFECreateWithoutTuteurInput[] | PFEUncheckedCreateWithoutTuteurInput[]
    connectOrCreate?: PFECreateOrConnectWithoutTuteurInput | PFECreateOrConnectWithoutTuteurInput[]
    upsert?: PFEUpsertWithWhereUniqueWithoutTuteurInput | PFEUpsertWithWhereUniqueWithoutTuteurInput[]
    createMany?: PFECreateManyTuteurInputEnvelope
    set?: PFEWhereUniqueInput | PFEWhereUniqueInput[]
    disconnect?: PFEWhereUniqueInput | PFEWhereUniqueInput[]
    delete?: PFEWhereUniqueInput | PFEWhereUniqueInput[]
    connect?: PFEWhereUniqueInput | PFEWhereUniqueInput[]
    update?: PFEUpdateWithWhereUniqueWithoutTuteurInput | PFEUpdateWithWhereUniqueWithoutTuteurInput[]
    updateMany?: PFEUpdateManyWithWhereWithoutTuteurInput | PFEUpdateManyWithWhereWithoutTuteurInput[]
    deleteMany?: PFEScalarWhereInput | PFEScalarWhereInput[]
  }

  export type TuteurLivrableUpdateManyWithoutTuteurNestedInput = {
    create?: XOR<TuteurLivrableCreateWithoutTuteurInput, TuteurLivrableUncheckedCreateWithoutTuteurInput> | TuteurLivrableCreateWithoutTuteurInput[] | TuteurLivrableUncheckedCreateWithoutTuteurInput[]
    connectOrCreate?: TuteurLivrableCreateOrConnectWithoutTuteurInput | TuteurLivrableCreateOrConnectWithoutTuteurInput[]
    upsert?: TuteurLivrableUpsertWithWhereUniqueWithoutTuteurInput | TuteurLivrableUpsertWithWhereUniqueWithoutTuteurInput[]
    createMany?: TuteurLivrableCreateManyTuteurInputEnvelope
    set?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    disconnect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    delete?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    connect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    update?: TuteurLivrableUpdateWithWhereUniqueWithoutTuteurInput | TuteurLivrableUpdateWithWhereUniqueWithoutTuteurInput[]
    updateMany?: TuteurLivrableUpdateManyWithWhereWithoutTuteurInput | TuteurLivrableUpdateManyWithWhereWithoutTuteurInput[]
    deleteMany?: TuteurLivrableScalarWhereInput | TuteurLivrableScalarWhereInput[]
  }

  export type PFEUncheckedUpdateManyWithoutTuteurNestedInput = {
    create?: XOR<PFECreateWithoutTuteurInput, PFEUncheckedCreateWithoutTuteurInput> | PFECreateWithoutTuteurInput[] | PFEUncheckedCreateWithoutTuteurInput[]
    connectOrCreate?: PFECreateOrConnectWithoutTuteurInput | PFECreateOrConnectWithoutTuteurInput[]
    upsert?: PFEUpsertWithWhereUniqueWithoutTuteurInput | PFEUpsertWithWhereUniqueWithoutTuteurInput[]
    createMany?: PFECreateManyTuteurInputEnvelope
    set?: PFEWhereUniqueInput | PFEWhereUniqueInput[]
    disconnect?: PFEWhereUniqueInput | PFEWhereUniqueInput[]
    delete?: PFEWhereUniqueInput | PFEWhereUniqueInput[]
    connect?: PFEWhereUniqueInput | PFEWhereUniqueInput[]
    update?: PFEUpdateWithWhereUniqueWithoutTuteurInput | PFEUpdateWithWhereUniqueWithoutTuteurInput[]
    updateMany?: PFEUpdateManyWithWhereWithoutTuteurInput | PFEUpdateManyWithWhereWithoutTuteurInput[]
    deleteMany?: PFEScalarWhereInput | PFEScalarWhereInput[]
  }

  export type TuteurLivrableUncheckedUpdateManyWithoutTuteurNestedInput = {
    create?: XOR<TuteurLivrableCreateWithoutTuteurInput, TuteurLivrableUncheckedCreateWithoutTuteurInput> | TuteurLivrableCreateWithoutTuteurInput[] | TuteurLivrableUncheckedCreateWithoutTuteurInput[]
    connectOrCreate?: TuteurLivrableCreateOrConnectWithoutTuteurInput | TuteurLivrableCreateOrConnectWithoutTuteurInput[]
    upsert?: TuteurLivrableUpsertWithWhereUniqueWithoutTuteurInput | TuteurLivrableUpsertWithWhereUniqueWithoutTuteurInput[]
    createMany?: TuteurLivrableCreateManyTuteurInputEnvelope
    set?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    disconnect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    delete?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    connect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    update?: TuteurLivrableUpdateWithWhereUniqueWithoutTuteurInput | TuteurLivrableUpdateWithWhereUniqueWithoutTuteurInput[]
    updateMany?: TuteurLivrableUpdateManyWithWhereWithoutTuteurInput | TuteurLivrableUpdateManyWithWhereWithoutTuteurInput[]
    deleteMany?: TuteurLivrableScalarWhereInput | TuteurLivrableScalarWhereInput[]
  }

  export type EtudiantGroupeCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<EtudiantGroupeCreateWithoutEtudiantInput, EtudiantGroupeUncheckedCreateWithoutEtudiantInput> | EtudiantGroupeCreateWithoutEtudiantInput[] | EtudiantGroupeUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EtudiantGroupeCreateOrConnectWithoutEtudiantInput | EtudiantGroupeCreateOrConnectWithoutEtudiantInput[]
    createMany?: EtudiantGroupeCreateManyEtudiantInputEnvelope
    connect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
  }

  export type EtudiantSujetCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<EtudiantSujetCreateWithoutEtudiantInput, EtudiantSujetUncheckedCreateWithoutEtudiantInput> | EtudiantSujetCreateWithoutEtudiantInput[] | EtudiantSujetUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EtudiantSujetCreateOrConnectWithoutEtudiantInput | EtudiantSujetCreateOrConnectWithoutEtudiantInput[]
    createMany?: EtudiantSujetCreateManyEtudiantInputEnvelope
    connect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<EvaluationCreateWithoutEtudiantInput, EvaluationUncheckedCreateWithoutEtudiantInput> | EvaluationCreateWithoutEtudiantInput[] | EvaluationUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEtudiantInput | EvaluationCreateOrConnectWithoutEtudiantInput[]
    createMany?: EvaluationCreateManyEtudiantInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EtudiantGroupeUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<EtudiantGroupeCreateWithoutEtudiantInput, EtudiantGroupeUncheckedCreateWithoutEtudiantInput> | EtudiantGroupeCreateWithoutEtudiantInput[] | EtudiantGroupeUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EtudiantGroupeCreateOrConnectWithoutEtudiantInput | EtudiantGroupeCreateOrConnectWithoutEtudiantInput[]
    createMany?: EtudiantGroupeCreateManyEtudiantInputEnvelope
    connect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
  }

  export type EtudiantSujetUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<EtudiantSujetCreateWithoutEtudiantInput, EtudiantSujetUncheckedCreateWithoutEtudiantInput> | EtudiantSujetCreateWithoutEtudiantInput[] | EtudiantSujetUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EtudiantSujetCreateOrConnectWithoutEtudiantInput | EtudiantSujetCreateOrConnectWithoutEtudiantInput[]
    createMany?: EtudiantSujetCreateManyEtudiantInputEnvelope
    connect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<EvaluationCreateWithoutEtudiantInput, EvaluationUncheckedCreateWithoutEtudiantInput> | EvaluationCreateWithoutEtudiantInput[] | EvaluationUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEtudiantInput | EvaluationCreateOrConnectWithoutEtudiantInput[]
    createMany?: EvaluationCreateManyEtudiantInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EtudiantGroupeUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<EtudiantGroupeCreateWithoutEtudiantInput, EtudiantGroupeUncheckedCreateWithoutEtudiantInput> | EtudiantGroupeCreateWithoutEtudiantInput[] | EtudiantGroupeUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EtudiantGroupeCreateOrConnectWithoutEtudiantInput | EtudiantGroupeCreateOrConnectWithoutEtudiantInput[]
    upsert?: EtudiantGroupeUpsertWithWhereUniqueWithoutEtudiantInput | EtudiantGroupeUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: EtudiantGroupeCreateManyEtudiantInputEnvelope
    set?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    disconnect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    delete?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    connect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    update?: EtudiantGroupeUpdateWithWhereUniqueWithoutEtudiantInput | EtudiantGroupeUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: EtudiantGroupeUpdateManyWithWhereWithoutEtudiantInput | EtudiantGroupeUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: EtudiantGroupeScalarWhereInput | EtudiantGroupeScalarWhereInput[]
  }

  export type EtudiantSujetUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<EtudiantSujetCreateWithoutEtudiantInput, EtudiantSujetUncheckedCreateWithoutEtudiantInput> | EtudiantSujetCreateWithoutEtudiantInput[] | EtudiantSujetUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EtudiantSujetCreateOrConnectWithoutEtudiantInput | EtudiantSujetCreateOrConnectWithoutEtudiantInput[]
    upsert?: EtudiantSujetUpsertWithWhereUniqueWithoutEtudiantInput | EtudiantSujetUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: EtudiantSujetCreateManyEtudiantInputEnvelope
    set?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    disconnect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    delete?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    connect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    update?: EtudiantSujetUpdateWithWhereUniqueWithoutEtudiantInput | EtudiantSujetUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: EtudiantSujetUpdateManyWithWhereWithoutEtudiantInput | EtudiantSujetUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: EtudiantSujetScalarWhereInput | EtudiantSujetScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<EvaluationCreateWithoutEtudiantInput, EvaluationUncheckedCreateWithoutEtudiantInput> | EvaluationCreateWithoutEtudiantInput[] | EvaluationUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEtudiantInput | EvaluationCreateOrConnectWithoutEtudiantInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutEtudiantInput | EvaluationUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: EvaluationCreateManyEtudiantInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutEtudiantInput | EvaluationUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutEtudiantInput | EvaluationUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EtudiantGroupeUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<EtudiantGroupeCreateWithoutEtudiantInput, EtudiantGroupeUncheckedCreateWithoutEtudiantInput> | EtudiantGroupeCreateWithoutEtudiantInput[] | EtudiantGroupeUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EtudiantGroupeCreateOrConnectWithoutEtudiantInput | EtudiantGroupeCreateOrConnectWithoutEtudiantInput[]
    upsert?: EtudiantGroupeUpsertWithWhereUniqueWithoutEtudiantInput | EtudiantGroupeUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: EtudiantGroupeCreateManyEtudiantInputEnvelope
    set?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    disconnect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    delete?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    connect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    update?: EtudiantGroupeUpdateWithWhereUniqueWithoutEtudiantInput | EtudiantGroupeUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: EtudiantGroupeUpdateManyWithWhereWithoutEtudiantInput | EtudiantGroupeUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: EtudiantGroupeScalarWhereInput | EtudiantGroupeScalarWhereInput[]
  }

  export type EtudiantSujetUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<EtudiantSujetCreateWithoutEtudiantInput, EtudiantSujetUncheckedCreateWithoutEtudiantInput> | EtudiantSujetCreateWithoutEtudiantInput[] | EtudiantSujetUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EtudiantSujetCreateOrConnectWithoutEtudiantInput | EtudiantSujetCreateOrConnectWithoutEtudiantInput[]
    upsert?: EtudiantSujetUpsertWithWhereUniqueWithoutEtudiantInput | EtudiantSujetUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: EtudiantSujetCreateManyEtudiantInputEnvelope
    set?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    disconnect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    delete?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    connect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    update?: EtudiantSujetUpdateWithWhereUniqueWithoutEtudiantInput | EtudiantSujetUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: EtudiantSujetUpdateManyWithWhereWithoutEtudiantInput | EtudiantSujetUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: EtudiantSujetScalarWhereInput | EtudiantSujetScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<EvaluationCreateWithoutEtudiantInput, EvaluationUncheckedCreateWithoutEtudiantInput> | EvaluationCreateWithoutEtudiantInput[] | EvaluationUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEtudiantInput | EvaluationCreateOrConnectWithoutEtudiantInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutEtudiantInput | EvaluationUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: EvaluationCreateManyEtudiantInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutEtudiantInput | EvaluationUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutEtudiantInput | EvaluationUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EtudiantGroupeCreateNestedManyWithoutGroupeInput = {
    create?: XOR<EtudiantGroupeCreateWithoutGroupeInput, EtudiantGroupeUncheckedCreateWithoutGroupeInput> | EtudiantGroupeCreateWithoutGroupeInput[] | EtudiantGroupeUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: EtudiantGroupeCreateOrConnectWithoutGroupeInput | EtudiantGroupeCreateOrConnectWithoutGroupeInput[]
    createMany?: EtudiantGroupeCreateManyGroupeInputEnvelope
    connect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
  }

  export type PFE_GroupeCreateNestedManyWithoutGroupeInput = {
    create?: XOR<PFE_GroupeCreateWithoutGroupeInput, PFE_GroupeUncheckedCreateWithoutGroupeInput> | PFE_GroupeCreateWithoutGroupeInput[] | PFE_GroupeUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: PFE_GroupeCreateOrConnectWithoutGroupeInput | PFE_GroupeCreateOrConnectWithoutGroupeInput[]
    createMany?: PFE_GroupeCreateManyGroupeInputEnvelope
    connect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
  }

  export type EtudiantGroupeUncheckedCreateNestedManyWithoutGroupeInput = {
    create?: XOR<EtudiantGroupeCreateWithoutGroupeInput, EtudiantGroupeUncheckedCreateWithoutGroupeInput> | EtudiantGroupeCreateWithoutGroupeInput[] | EtudiantGroupeUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: EtudiantGroupeCreateOrConnectWithoutGroupeInput | EtudiantGroupeCreateOrConnectWithoutGroupeInput[]
    createMany?: EtudiantGroupeCreateManyGroupeInputEnvelope
    connect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
  }

  export type PFE_GroupeUncheckedCreateNestedManyWithoutGroupeInput = {
    create?: XOR<PFE_GroupeCreateWithoutGroupeInput, PFE_GroupeUncheckedCreateWithoutGroupeInput> | PFE_GroupeCreateWithoutGroupeInput[] | PFE_GroupeUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: PFE_GroupeCreateOrConnectWithoutGroupeInput | PFE_GroupeCreateOrConnectWithoutGroupeInput[]
    createMany?: PFE_GroupeCreateManyGroupeInputEnvelope
    connect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
  }

  export type EtudiantGroupeUpdateManyWithoutGroupeNestedInput = {
    create?: XOR<EtudiantGroupeCreateWithoutGroupeInput, EtudiantGroupeUncheckedCreateWithoutGroupeInput> | EtudiantGroupeCreateWithoutGroupeInput[] | EtudiantGroupeUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: EtudiantGroupeCreateOrConnectWithoutGroupeInput | EtudiantGroupeCreateOrConnectWithoutGroupeInput[]
    upsert?: EtudiantGroupeUpsertWithWhereUniqueWithoutGroupeInput | EtudiantGroupeUpsertWithWhereUniqueWithoutGroupeInput[]
    createMany?: EtudiantGroupeCreateManyGroupeInputEnvelope
    set?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    disconnect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    delete?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    connect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    update?: EtudiantGroupeUpdateWithWhereUniqueWithoutGroupeInput | EtudiantGroupeUpdateWithWhereUniqueWithoutGroupeInput[]
    updateMany?: EtudiantGroupeUpdateManyWithWhereWithoutGroupeInput | EtudiantGroupeUpdateManyWithWhereWithoutGroupeInput[]
    deleteMany?: EtudiantGroupeScalarWhereInput | EtudiantGroupeScalarWhereInput[]
  }

  export type PFE_GroupeUpdateManyWithoutGroupeNestedInput = {
    create?: XOR<PFE_GroupeCreateWithoutGroupeInput, PFE_GroupeUncheckedCreateWithoutGroupeInput> | PFE_GroupeCreateWithoutGroupeInput[] | PFE_GroupeUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: PFE_GroupeCreateOrConnectWithoutGroupeInput | PFE_GroupeCreateOrConnectWithoutGroupeInput[]
    upsert?: PFE_GroupeUpsertWithWhereUniqueWithoutGroupeInput | PFE_GroupeUpsertWithWhereUniqueWithoutGroupeInput[]
    createMany?: PFE_GroupeCreateManyGroupeInputEnvelope
    set?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    disconnect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    delete?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    connect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    update?: PFE_GroupeUpdateWithWhereUniqueWithoutGroupeInput | PFE_GroupeUpdateWithWhereUniqueWithoutGroupeInput[]
    updateMany?: PFE_GroupeUpdateManyWithWhereWithoutGroupeInput | PFE_GroupeUpdateManyWithWhereWithoutGroupeInput[]
    deleteMany?: PFE_GroupeScalarWhereInput | PFE_GroupeScalarWhereInput[]
  }

  export type EtudiantGroupeUncheckedUpdateManyWithoutGroupeNestedInput = {
    create?: XOR<EtudiantGroupeCreateWithoutGroupeInput, EtudiantGroupeUncheckedCreateWithoutGroupeInput> | EtudiantGroupeCreateWithoutGroupeInput[] | EtudiantGroupeUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: EtudiantGroupeCreateOrConnectWithoutGroupeInput | EtudiantGroupeCreateOrConnectWithoutGroupeInput[]
    upsert?: EtudiantGroupeUpsertWithWhereUniqueWithoutGroupeInput | EtudiantGroupeUpsertWithWhereUniqueWithoutGroupeInput[]
    createMany?: EtudiantGroupeCreateManyGroupeInputEnvelope
    set?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    disconnect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    delete?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    connect?: EtudiantGroupeWhereUniqueInput | EtudiantGroupeWhereUniqueInput[]
    update?: EtudiantGroupeUpdateWithWhereUniqueWithoutGroupeInput | EtudiantGroupeUpdateWithWhereUniqueWithoutGroupeInput[]
    updateMany?: EtudiantGroupeUpdateManyWithWhereWithoutGroupeInput | EtudiantGroupeUpdateManyWithWhereWithoutGroupeInput[]
    deleteMany?: EtudiantGroupeScalarWhereInput | EtudiantGroupeScalarWhereInput[]
  }

  export type PFE_GroupeUncheckedUpdateManyWithoutGroupeNestedInput = {
    create?: XOR<PFE_GroupeCreateWithoutGroupeInput, PFE_GroupeUncheckedCreateWithoutGroupeInput> | PFE_GroupeCreateWithoutGroupeInput[] | PFE_GroupeUncheckedCreateWithoutGroupeInput[]
    connectOrCreate?: PFE_GroupeCreateOrConnectWithoutGroupeInput | PFE_GroupeCreateOrConnectWithoutGroupeInput[]
    upsert?: PFE_GroupeUpsertWithWhereUniqueWithoutGroupeInput | PFE_GroupeUpsertWithWhereUniqueWithoutGroupeInput[]
    createMany?: PFE_GroupeCreateManyGroupeInputEnvelope
    set?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    disconnect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    delete?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    connect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    update?: PFE_GroupeUpdateWithWhereUniqueWithoutGroupeInput | PFE_GroupeUpdateWithWhereUniqueWithoutGroupeInput[]
    updateMany?: PFE_GroupeUpdateManyWithWhereWithoutGroupeInput | PFE_GroupeUpdateManyWithWhereWithoutGroupeInput[]
    deleteMany?: PFE_GroupeScalarWhereInput | PFE_GroupeScalarWhereInput[]
  }

  export type EtudiantCreateNestedOneWithoutGroupesInput = {
    create?: XOR<EtudiantCreateWithoutGroupesInput, EtudiantUncheckedCreateWithoutGroupesInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutGroupesInput
    connect?: EtudiantWhereUniqueInput
  }

  export type GroupeCreateNestedOneWithoutEtudiantsInput = {
    create?: XOR<GroupeCreateWithoutEtudiantsInput, GroupeUncheckedCreateWithoutEtudiantsInput>
    connectOrCreate?: GroupeCreateOrConnectWithoutEtudiantsInput
    connect?: GroupeWhereUniqueInput
  }

  export type EtudiantUpdateOneRequiredWithoutGroupesNestedInput = {
    create?: XOR<EtudiantCreateWithoutGroupesInput, EtudiantUncheckedCreateWithoutGroupesInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutGroupesInput
    upsert?: EtudiantUpsertWithoutGroupesInput
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutGroupesInput, EtudiantUpdateWithoutGroupesInput>, EtudiantUncheckedUpdateWithoutGroupesInput>
  }

  export type GroupeUpdateOneRequiredWithoutEtudiantsNestedInput = {
    create?: XOR<GroupeCreateWithoutEtudiantsInput, GroupeUncheckedCreateWithoutEtudiantsInput>
    connectOrCreate?: GroupeCreateOrConnectWithoutEtudiantsInput
    upsert?: GroupeUpsertWithoutEtudiantsInput
    connect?: GroupeWhereUniqueInput
    update?: XOR<XOR<GroupeUpdateToOneWithWhereWithoutEtudiantsInput, GroupeUpdateWithoutEtudiantsInput>, GroupeUncheckedUpdateWithoutEtudiantsInput>
  }

  export type EncadrantCreateNestedOneWithoutSujetsInput = {
    create?: XOR<EncadrantCreateWithoutSujetsInput, EncadrantUncheckedCreateWithoutSujetsInput>
    connectOrCreate?: EncadrantCreateOrConnectWithoutSujetsInput
    connect?: EncadrantWhereUniqueInput
  }

  export type EtudiantSujetCreateNestedManyWithoutSujetInput = {
    create?: XOR<EtudiantSujetCreateWithoutSujetInput, EtudiantSujetUncheckedCreateWithoutSujetInput> | EtudiantSujetCreateWithoutSujetInput[] | EtudiantSujetUncheckedCreateWithoutSujetInput[]
    connectOrCreate?: EtudiantSujetCreateOrConnectWithoutSujetInput | EtudiantSujetCreateOrConnectWithoutSujetInput[]
    createMany?: EtudiantSujetCreateManySujetInputEnvelope
    connect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
  }

  export type EtudiantSujetUncheckedCreateNestedManyWithoutSujetInput = {
    create?: XOR<EtudiantSujetCreateWithoutSujetInput, EtudiantSujetUncheckedCreateWithoutSujetInput> | EtudiantSujetCreateWithoutSujetInput[] | EtudiantSujetUncheckedCreateWithoutSujetInput[]
    connectOrCreate?: EtudiantSujetCreateOrConnectWithoutSujetInput | EtudiantSujetCreateOrConnectWithoutSujetInput[]
    createMany?: EtudiantSujetCreateManySujetInputEnvelope
    connect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
  }

  export type EncadrantUpdateOneRequiredWithoutSujetsNestedInput = {
    create?: XOR<EncadrantCreateWithoutSujetsInput, EncadrantUncheckedCreateWithoutSujetsInput>
    connectOrCreate?: EncadrantCreateOrConnectWithoutSujetsInput
    upsert?: EncadrantUpsertWithoutSujetsInput
    connect?: EncadrantWhereUniqueInput
    update?: XOR<XOR<EncadrantUpdateToOneWithWhereWithoutSujetsInput, EncadrantUpdateWithoutSujetsInput>, EncadrantUncheckedUpdateWithoutSujetsInput>
  }

  export type EtudiantSujetUpdateManyWithoutSujetNestedInput = {
    create?: XOR<EtudiantSujetCreateWithoutSujetInput, EtudiantSujetUncheckedCreateWithoutSujetInput> | EtudiantSujetCreateWithoutSujetInput[] | EtudiantSujetUncheckedCreateWithoutSujetInput[]
    connectOrCreate?: EtudiantSujetCreateOrConnectWithoutSujetInput | EtudiantSujetCreateOrConnectWithoutSujetInput[]
    upsert?: EtudiantSujetUpsertWithWhereUniqueWithoutSujetInput | EtudiantSujetUpsertWithWhereUniqueWithoutSujetInput[]
    createMany?: EtudiantSujetCreateManySujetInputEnvelope
    set?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    disconnect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    delete?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    connect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    update?: EtudiantSujetUpdateWithWhereUniqueWithoutSujetInput | EtudiantSujetUpdateWithWhereUniqueWithoutSujetInput[]
    updateMany?: EtudiantSujetUpdateManyWithWhereWithoutSujetInput | EtudiantSujetUpdateManyWithWhereWithoutSujetInput[]
    deleteMany?: EtudiantSujetScalarWhereInput | EtudiantSujetScalarWhereInput[]
  }

  export type EtudiantSujetUncheckedUpdateManyWithoutSujetNestedInput = {
    create?: XOR<EtudiantSujetCreateWithoutSujetInput, EtudiantSujetUncheckedCreateWithoutSujetInput> | EtudiantSujetCreateWithoutSujetInput[] | EtudiantSujetUncheckedCreateWithoutSujetInput[]
    connectOrCreate?: EtudiantSujetCreateOrConnectWithoutSujetInput | EtudiantSujetCreateOrConnectWithoutSujetInput[]
    upsert?: EtudiantSujetUpsertWithWhereUniqueWithoutSujetInput | EtudiantSujetUpsertWithWhereUniqueWithoutSujetInput[]
    createMany?: EtudiantSujetCreateManySujetInputEnvelope
    set?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    disconnect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    delete?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    connect?: EtudiantSujetWhereUniqueInput | EtudiantSujetWhereUniqueInput[]
    update?: EtudiantSujetUpdateWithWhereUniqueWithoutSujetInput | EtudiantSujetUpdateWithWhereUniqueWithoutSujetInput[]
    updateMany?: EtudiantSujetUpdateManyWithWhereWithoutSujetInput | EtudiantSujetUpdateManyWithWhereWithoutSujetInput[]
    deleteMany?: EtudiantSujetScalarWhereInput | EtudiantSujetScalarWhereInput[]
  }

  export type EtudiantCreateNestedOneWithoutSujetsInput = {
    create?: XOR<EtudiantCreateWithoutSujetsInput, EtudiantUncheckedCreateWithoutSujetsInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutSujetsInput
    connect?: EtudiantWhereUniqueInput
  }

  export type SujetCreateNestedOneWithoutEtudiantsInput = {
    create?: XOR<SujetCreateWithoutEtudiantsInput, SujetUncheckedCreateWithoutEtudiantsInput>
    connectOrCreate?: SujetCreateOrConnectWithoutEtudiantsInput
    connect?: SujetWhereUniqueInput
  }

  export type EtudiantUpdateOneRequiredWithoutSujetsNestedInput = {
    create?: XOR<EtudiantCreateWithoutSujetsInput, EtudiantUncheckedCreateWithoutSujetsInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutSujetsInput
    upsert?: EtudiantUpsertWithoutSujetsInput
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutSujetsInput, EtudiantUpdateWithoutSujetsInput>, EtudiantUncheckedUpdateWithoutSujetsInput>
  }

  export type SujetUpdateOneRequiredWithoutEtudiantsNestedInput = {
    create?: XOR<SujetCreateWithoutEtudiantsInput, SujetUncheckedCreateWithoutEtudiantsInput>
    connectOrCreate?: SujetCreateOrConnectWithoutEtudiantsInput
    upsert?: SujetUpsertWithoutEtudiantsInput
    connect?: SujetWhereUniqueInput
    update?: XOR<XOR<SujetUpdateToOneWithWhereWithoutEtudiantsInput, SujetUpdateWithoutEtudiantsInput>, SujetUncheckedUpdateWithoutEtudiantsInput>
  }

  export type SoutenanceCreateNestedManyWithoutJuryInput = {
    create?: XOR<SoutenanceCreateWithoutJuryInput, SoutenanceUncheckedCreateWithoutJuryInput> | SoutenanceCreateWithoutJuryInput[] | SoutenanceUncheckedCreateWithoutJuryInput[]
    connectOrCreate?: SoutenanceCreateOrConnectWithoutJuryInput | SoutenanceCreateOrConnectWithoutJuryInput[]
    createMany?: SoutenanceCreateManyJuryInputEnvelope
    connect?: SoutenanceWhereUniqueInput | SoutenanceWhereUniqueInput[]
  }

  export type SoutenanceUncheckedCreateNestedManyWithoutJuryInput = {
    create?: XOR<SoutenanceCreateWithoutJuryInput, SoutenanceUncheckedCreateWithoutJuryInput> | SoutenanceCreateWithoutJuryInput[] | SoutenanceUncheckedCreateWithoutJuryInput[]
    connectOrCreate?: SoutenanceCreateOrConnectWithoutJuryInput | SoutenanceCreateOrConnectWithoutJuryInput[]
    createMany?: SoutenanceCreateManyJuryInputEnvelope
    connect?: SoutenanceWhereUniqueInput | SoutenanceWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SoutenanceUpdateManyWithoutJuryNestedInput = {
    create?: XOR<SoutenanceCreateWithoutJuryInput, SoutenanceUncheckedCreateWithoutJuryInput> | SoutenanceCreateWithoutJuryInput[] | SoutenanceUncheckedCreateWithoutJuryInput[]
    connectOrCreate?: SoutenanceCreateOrConnectWithoutJuryInput | SoutenanceCreateOrConnectWithoutJuryInput[]
    upsert?: SoutenanceUpsertWithWhereUniqueWithoutJuryInput | SoutenanceUpsertWithWhereUniqueWithoutJuryInput[]
    createMany?: SoutenanceCreateManyJuryInputEnvelope
    set?: SoutenanceWhereUniqueInput | SoutenanceWhereUniqueInput[]
    disconnect?: SoutenanceWhereUniqueInput | SoutenanceWhereUniqueInput[]
    delete?: SoutenanceWhereUniqueInput | SoutenanceWhereUniqueInput[]
    connect?: SoutenanceWhereUniqueInput | SoutenanceWhereUniqueInput[]
    update?: SoutenanceUpdateWithWhereUniqueWithoutJuryInput | SoutenanceUpdateWithWhereUniqueWithoutJuryInput[]
    updateMany?: SoutenanceUpdateManyWithWhereWithoutJuryInput | SoutenanceUpdateManyWithWhereWithoutJuryInput[]
    deleteMany?: SoutenanceScalarWhereInput | SoutenanceScalarWhereInput[]
  }

  export type SoutenanceUncheckedUpdateManyWithoutJuryNestedInput = {
    create?: XOR<SoutenanceCreateWithoutJuryInput, SoutenanceUncheckedCreateWithoutJuryInput> | SoutenanceCreateWithoutJuryInput[] | SoutenanceUncheckedCreateWithoutJuryInput[]
    connectOrCreate?: SoutenanceCreateOrConnectWithoutJuryInput | SoutenanceCreateOrConnectWithoutJuryInput[]
    upsert?: SoutenanceUpsertWithWhereUniqueWithoutJuryInput | SoutenanceUpsertWithWhereUniqueWithoutJuryInput[]
    createMany?: SoutenanceCreateManyJuryInputEnvelope
    set?: SoutenanceWhereUniqueInput | SoutenanceWhereUniqueInput[]
    disconnect?: SoutenanceWhereUniqueInput | SoutenanceWhereUniqueInput[]
    delete?: SoutenanceWhereUniqueInput | SoutenanceWhereUniqueInput[]
    connect?: SoutenanceWhereUniqueInput | SoutenanceWhereUniqueInput[]
    update?: SoutenanceUpdateWithWhereUniqueWithoutJuryInput | SoutenanceUpdateWithWhereUniqueWithoutJuryInput[]
    updateMany?: SoutenanceUpdateManyWithWhereWithoutJuryInput | SoutenanceUpdateManyWithWhereWithoutJuryInput[]
    deleteMany?: SoutenanceScalarWhereInput | SoutenanceScalarWhereInput[]
  }

  export type JuryCreateNestedOneWithoutSoutenancesInput = {
    create?: XOR<JuryCreateWithoutSoutenancesInput, JuryUncheckedCreateWithoutSoutenancesInput>
    connectOrCreate?: JuryCreateOrConnectWithoutSoutenancesInput
    connect?: JuryWhereUniqueInput
  }

  export type EncadrantSoutenanceCreateNestedManyWithoutSoutenanceInput = {
    create?: XOR<EncadrantSoutenanceCreateWithoutSoutenanceInput, EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput> | EncadrantSoutenanceCreateWithoutSoutenanceInput[] | EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: EncadrantSoutenanceCreateOrConnectWithoutSoutenanceInput | EncadrantSoutenanceCreateOrConnectWithoutSoutenanceInput[]
    createMany?: EncadrantSoutenanceCreateManySoutenanceInputEnvelope
    connect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutSoutenanceInput = {
    create?: XOR<EvaluationCreateWithoutSoutenanceInput, EvaluationUncheckedCreateWithoutSoutenanceInput> | EvaluationCreateWithoutSoutenanceInput[] | EvaluationUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutSoutenanceInput | EvaluationCreateOrConnectWithoutSoutenanceInput[]
    createMany?: EvaluationCreateManySoutenanceInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EncadrantSoutenanceUncheckedCreateNestedManyWithoutSoutenanceInput = {
    create?: XOR<EncadrantSoutenanceCreateWithoutSoutenanceInput, EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput> | EncadrantSoutenanceCreateWithoutSoutenanceInput[] | EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: EncadrantSoutenanceCreateOrConnectWithoutSoutenanceInput | EncadrantSoutenanceCreateOrConnectWithoutSoutenanceInput[]
    createMany?: EncadrantSoutenanceCreateManySoutenanceInputEnvelope
    connect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutSoutenanceInput = {
    create?: XOR<EvaluationCreateWithoutSoutenanceInput, EvaluationUncheckedCreateWithoutSoutenanceInput> | EvaluationCreateWithoutSoutenanceInput[] | EvaluationUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutSoutenanceInput | EvaluationCreateOrConnectWithoutSoutenanceInput[]
    createMany?: EvaluationCreateManySoutenanceInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type JuryUpdateOneRequiredWithoutSoutenancesNestedInput = {
    create?: XOR<JuryCreateWithoutSoutenancesInput, JuryUncheckedCreateWithoutSoutenancesInput>
    connectOrCreate?: JuryCreateOrConnectWithoutSoutenancesInput
    upsert?: JuryUpsertWithoutSoutenancesInput
    connect?: JuryWhereUniqueInput
    update?: XOR<XOR<JuryUpdateToOneWithWhereWithoutSoutenancesInput, JuryUpdateWithoutSoutenancesInput>, JuryUncheckedUpdateWithoutSoutenancesInput>
  }

  export type EncadrantSoutenanceUpdateManyWithoutSoutenanceNestedInput = {
    create?: XOR<EncadrantSoutenanceCreateWithoutSoutenanceInput, EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput> | EncadrantSoutenanceCreateWithoutSoutenanceInput[] | EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: EncadrantSoutenanceCreateOrConnectWithoutSoutenanceInput | EncadrantSoutenanceCreateOrConnectWithoutSoutenanceInput[]
    upsert?: EncadrantSoutenanceUpsertWithWhereUniqueWithoutSoutenanceInput | EncadrantSoutenanceUpsertWithWhereUniqueWithoutSoutenanceInput[]
    createMany?: EncadrantSoutenanceCreateManySoutenanceInputEnvelope
    set?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    disconnect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    delete?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    connect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    update?: EncadrantSoutenanceUpdateWithWhereUniqueWithoutSoutenanceInput | EncadrantSoutenanceUpdateWithWhereUniqueWithoutSoutenanceInput[]
    updateMany?: EncadrantSoutenanceUpdateManyWithWhereWithoutSoutenanceInput | EncadrantSoutenanceUpdateManyWithWhereWithoutSoutenanceInput[]
    deleteMany?: EncadrantSoutenanceScalarWhereInput | EncadrantSoutenanceScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutSoutenanceNestedInput = {
    create?: XOR<EvaluationCreateWithoutSoutenanceInput, EvaluationUncheckedCreateWithoutSoutenanceInput> | EvaluationCreateWithoutSoutenanceInput[] | EvaluationUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutSoutenanceInput | EvaluationCreateOrConnectWithoutSoutenanceInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutSoutenanceInput | EvaluationUpsertWithWhereUniqueWithoutSoutenanceInput[]
    createMany?: EvaluationCreateManySoutenanceInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutSoutenanceInput | EvaluationUpdateWithWhereUniqueWithoutSoutenanceInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutSoutenanceInput | EvaluationUpdateManyWithWhereWithoutSoutenanceInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EncadrantSoutenanceUncheckedUpdateManyWithoutSoutenanceNestedInput = {
    create?: XOR<EncadrantSoutenanceCreateWithoutSoutenanceInput, EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput> | EncadrantSoutenanceCreateWithoutSoutenanceInput[] | EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: EncadrantSoutenanceCreateOrConnectWithoutSoutenanceInput | EncadrantSoutenanceCreateOrConnectWithoutSoutenanceInput[]
    upsert?: EncadrantSoutenanceUpsertWithWhereUniqueWithoutSoutenanceInput | EncadrantSoutenanceUpsertWithWhereUniqueWithoutSoutenanceInput[]
    createMany?: EncadrantSoutenanceCreateManySoutenanceInputEnvelope
    set?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    disconnect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    delete?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    connect?: EncadrantSoutenanceWhereUniqueInput | EncadrantSoutenanceWhereUniqueInput[]
    update?: EncadrantSoutenanceUpdateWithWhereUniqueWithoutSoutenanceInput | EncadrantSoutenanceUpdateWithWhereUniqueWithoutSoutenanceInput[]
    updateMany?: EncadrantSoutenanceUpdateManyWithWhereWithoutSoutenanceInput | EncadrantSoutenanceUpdateManyWithWhereWithoutSoutenanceInput[]
    deleteMany?: EncadrantSoutenanceScalarWhereInput | EncadrantSoutenanceScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutSoutenanceNestedInput = {
    create?: XOR<EvaluationCreateWithoutSoutenanceInput, EvaluationUncheckedCreateWithoutSoutenanceInput> | EvaluationCreateWithoutSoutenanceInput[] | EvaluationUncheckedCreateWithoutSoutenanceInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutSoutenanceInput | EvaluationCreateOrConnectWithoutSoutenanceInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutSoutenanceInput | EvaluationUpsertWithWhereUniqueWithoutSoutenanceInput[]
    createMany?: EvaluationCreateManySoutenanceInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutSoutenanceInput | EvaluationUpdateWithWhereUniqueWithoutSoutenanceInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutSoutenanceInput | EvaluationUpdateManyWithWhereWithoutSoutenanceInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type SoutenanceCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<SoutenanceCreateWithoutEvaluationsInput, SoutenanceUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: SoutenanceCreateOrConnectWithoutEvaluationsInput
    connect?: SoutenanceWhereUniqueInput
  }

  export type EtudiantCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<EtudiantCreateWithoutEvaluationsInput, EtudiantUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutEvaluationsInput
    connect?: EtudiantWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type SoutenanceUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<SoutenanceCreateWithoutEvaluationsInput, SoutenanceUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: SoutenanceCreateOrConnectWithoutEvaluationsInput
    upsert?: SoutenanceUpsertWithoutEvaluationsInput
    connect?: SoutenanceWhereUniqueInput
    update?: XOR<XOR<SoutenanceUpdateToOneWithWhereWithoutEvaluationsInput, SoutenanceUpdateWithoutEvaluationsInput>, SoutenanceUncheckedUpdateWithoutEvaluationsInput>
  }

  export type EtudiantUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<EtudiantCreateWithoutEvaluationsInput, EtudiantUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: EtudiantCreateOrConnectWithoutEvaluationsInput
    upsert?: EtudiantUpsertWithoutEvaluationsInput
    connect?: EtudiantWhereUniqueInput
    update?: XOR<XOR<EtudiantUpdateToOneWithWhereWithoutEvaluationsInput, EtudiantUpdateWithoutEvaluationsInput>, EtudiantUncheckedUpdateWithoutEvaluationsInput>
  }

  export type PFE_LivrableCreateNestedManyWithoutLivrableInput = {
    create?: XOR<PFE_LivrableCreateWithoutLivrableInput, PFE_LivrableUncheckedCreateWithoutLivrableInput> | PFE_LivrableCreateWithoutLivrableInput[] | PFE_LivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: PFE_LivrableCreateOrConnectWithoutLivrableInput | PFE_LivrableCreateOrConnectWithoutLivrableInput[]
    createMany?: PFE_LivrableCreateManyLivrableInputEnvelope
    connect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
  }

  export type EncadrantLivrableCreateNestedManyWithoutLivrableInput = {
    create?: XOR<EncadrantLivrableCreateWithoutLivrableInput, EncadrantLivrableUncheckedCreateWithoutLivrableInput> | EncadrantLivrableCreateWithoutLivrableInput[] | EncadrantLivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: EncadrantLivrableCreateOrConnectWithoutLivrableInput | EncadrantLivrableCreateOrConnectWithoutLivrableInput[]
    createMany?: EncadrantLivrableCreateManyLivrableInputEnvelope
    connect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
  }

  export type TuteurLivrableCreateNestedManyWithoutLivrableInput = {
    create?: XOR<TuteurLivrableCreateWithoutLivrableInput, TuteurLivrableUncheckedCreateWithoutLivrableInput> | TuteurLivrableCreateWithoutLivrableInput[] | TuteurLivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: TuteurLivrableCreateOrConnectWithoutLivrableInput | TuteurLivrableCreateOrConnectWithoutLivrableInput[]
    createMany?: TuteurLivrableCreateManyLivrableInputEnvelope
    connect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
  }

  export type PFE_LivrableUncheckedCreateNestedManyWithoutLivrableInput = {
    create?: XOR<PFE_LivrableCreateWithoutLivrableInput, PFE_LivrableUncheckedCreateWithoutLivrableInput> | PFE_LivrableCreateWithoutLivrableInput[] | PFE_LivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: PFE_LivrableCreateOrConnectWithoutLivrableInput | PFE_LivrableCreateOrConnectWithoutLivrableInput[]
    createMany?: PFE_LivrableCreateManyLivrableInputEnvelope
    connect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
  }

  export type EncadrantLivrableUncheckedCreateNestedManyWithoutLivrableInput = {
    create?: XOR<EncadrantLivrableCreateWithoutLivrableInput, EncadrantLivrableUncheckedCreateWithoutLivrableInput> | EncadrantLivrableCreateWithoutLivrableInput[] | EncadrantLivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: EncadrantLivrableCreateOrConnectWithoutLivrableInput | EncadrantLivrableCreateOrConnectWithoutLivrableInput[]
    createMany?: EncadrantLivrableCreateManyLivrableInputEnvelope
    connect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
  }

  export type TuteurLivrableUncheckedCreateNestedManyWithoutLivrableInput = {
    create?: XOR<TuteurLivrableCreateWithoutLivrableInput, TuteurLivrableUncheckedCreateWithoutLivrableInput> | TuteurLivrableCreateWithoutLivrableInput[] | TuteurLivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: TuteurLivrableCreateOrConnectWithoutLivrableInput | TuteurLivrableCreateOrConnectWithoutLivrableInput[]
    createMany?: TuteurLivrableCreateManyLivrableInputEnvelope
    connect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
  }

  export type PFE_LivrableUpdateManyWithoutLivrableNestedInput = {
    create?: XOR<PFE_LivrableCreateWithoutLivrableInput, PFE_LivrableUncheckedCreateWithoutLivrableInput> | PFE_LivrableCreateWithoutLivrableInput[] | PFE_LivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: PFE_LivrableCreateOrConnectWithoutLivrableInput | PFE_LivrableCreateOrConnectWithoutLivrableInput[]
    upsert?: PFE_LivrableUpsertWithWhereUniqueWithoutLivrableInput | PFE_LivrableUpsertWithWhereUniqueWithoutLivrableInput[]
    createMany?: PFE_LivrableCreateManyLivrableInputEnvelope
    set?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    disconnect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    delete?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    connect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    update?: PFE_LivrableUpdateWithWhereUniqueWithoutLivrableInput | PFE_LivrableUpdateWithWhereUniqueWithoutLivrableInput[]
    updateMany?: PFE_LivrableUpdateManyWithWhereWithoutLivrableInput | PFE_LivrableUpdateManyWithWhereWithoutLivrableInput[]
    deleteMany?: PFE_LivrableScalarWhereInput | PFE_LivrableScalarWhereInput[]
  }

  export type EncadrantLivrableUpdateManyWithoutLivrableNestedInput = {
    create?: XOR<EncadrantLivrableCreateWithoutLivrableInput, EncadrantLivrableUncheckedCreateWithoutLivrableInput> | EncadrantLivrableCreateWithoutLivrableInput[] | EncadrantLivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: EncadrantLivrableCreateOrConnectWithoutLivrableInput | EncadrantLivrableCreateOrConnectWithoutLivrableInput[]
    upsert?: EncadrantLivrableUpsertWithWhereUniqueWithoutLivrableInput | EncadrantLivrableUpsertWithWhereUniqueWithoutLivrableInput[]
    createMany?: EncadrantLivrableCreateManyLivrableInputEnvelope
    set?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    disconnect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    delete?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    connect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    update?: EncadrantLivrableUpdateWithWhereUniqueWithoutLivrableInput | EncadrantLivrableUpdateWithWhereUniqueWithoutLivrableInput[]
    updateMany?: EncadrantLivrableUpdateManyWithWhereWithoutLivrableInput | EncadrantLivrableUpdateManyWithWhereWithoutLivrableInput[]
    deleteMany?: EncadrantLivrableScalarWhereInput | EncadrantLivrableScalarWhereInput[]
  }

  export type TuteurLivrableUpdateManyWithoutLivrableNestedInput = {
    create?: XOR<TuteurLivrableCreateWithoutLivrableInput, TuteurLivrableUncheckedCreateWithoutLivrableInput> | TuteurLivrableCreateWithoutLivrableInput[] | TuteurLivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: TuteurLivrableCreateOrConnectWithoutLivrableInput | TuteurLivrableCreateOrConnectWithoutLivrableInput[]
    upsert?: TuteurLivrableUpsertWithWhereUniqueWithoutLivrableInput | TuteurLivrableUpsertWithWhereUniqueWithoutLivrableInput[]
    createMany?: TuteurLivrableCreateManyLivrableInputEnvelope
    set?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    disconnect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    delete?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    connect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    update?: TuteurLivrableUpdateWithWhereUniqueWithoutLivrableInput | TuteurLivrableUpdateWithWhereUniqueWithoutLivrableInput[]
    updateMany?: TuteurLivrableUpdateManyWithWhereWithoutLivrableInput | TuteurLivrableUpdateManyWithWhereWithoutLivrableInput[]
    deleteMany?: TuteurLivrableScalarWhereInput | TuteurLivrableScalarWhereInput[]
  }

  export type PFE_LivrableUncheckedUpdateManyWithoutLivrableNestedInput = {
    create?: XOR<PFE_LivrableCreateWithoutLivrableInput, PFE_LivrableUncheckedCreateWithoutLivrableInput> | PFE_LivrableCreateWithoutLivrableInput[] | PFE_LivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: PFE_LivrableCreateOrConnectWithoutLivrableInput | PFE_LivrableCreateOrConnectWithoutLivrableInput[]
    upsert?: PFE_LivrableUpsertWithWhereUniqueWithoutLivrableInput | PFE_LivrableUpsertWithWhereUniqueWithoutLivrableInput[]
    createMany?: PFE_LivrableCreateManyLivrableInputEnvelope
    set?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    disconnect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    delete?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    connect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    update?: PFE_LivrableUpdateWithWhereUniqueWithoutLivrableInput | PFE_LivrableUpdateWithWhereUniqueWithoutLivrableInput[]
    updateMany?: PFE_LivrableUpdateManyWithWhereWithoutLivrableInput | PFE_LivrableUpdateManyWithWhereWithoutLivrableInput[]
    deleteMany?: PFE_LivrableScalarWhereInput | PFE_LivrableScalarWhereInput[]
  }

  export type EncadrantLivrableUncheckedUpdateManyWithoutLivrableNestedInput = {
    create?: XOR<EncadrantLivrableCreateWithoutLivrableInput, EncadrantLivrableUncheckedCreateWithoutLivrableInput> | EncadrantLivrableCreateWithoutLivrableInput[] | EncadrantLivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: EncadrantLivrableCreateOrConnectWithoutLivrableInput | EncadrantLivrableCreateOrConnectWithoutLivrableInput[]
    upsert?: EncadrantLivrableUpsertWithWhereUniqueWithoutLivrableInput | EncadrantLivrableUpsertWithWhereUniqueWithoutLivrableInput[]
    createMany?: EncadrantLivrableCreateManyLivrableInputEnvelope
    set?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    disconnect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    delete?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    connect?: EncadrantLivrableWhereUniqueInput | EncadrantLivrableWhereUniqueInput[]
    update?: EncadrantLivrableUpdateWithWhereUniqueWithoutLivrableInput | EncadrantLivrableUpdateWithWhereUniqueWithoutLivrableInput[]
    updateMany?: EncadrantLivrableUpdateManyWithWhereWithoutLivrableInput | EncadrantLivrableUpdateManyWithWhereWithoutLivrableInput[]
    deleteMany?: EncadrantLivrableScalarWhereInput | EncadrantLivrableScalarWhereInput[]
  }

  export type TuteurLivrableUncheckedUpdateManyWithoutLivrableNestedInput = {
    create?: XOR<TuteurLivrableCreateWithoutLivrableInput, TuteurLivrableUncheckedCreateWithoutLivrableInput> | TuteurLivrableCreateWithoutLivrableInput[] | TuteurLivrableUncheckedCreateWithoutLivrableInput[]
    connectOrCreate?: TuteurLivrableCreateOrConnectWithoutLivrableInput | TuteurLivrableCreateOrConnectWithoutLivrableInput[]
    upsert?: TuteurLivrableUpsertWithWhereUniqueWithoutLivrableInput | TuteurLivrableUpsertWithWhereUniqueWithoutLivrableInput[]
    createMany?: TuteurLivrableCreateManyLivrableInputEnvelope
    set?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    disconnect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    delete?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    connect?: TuteurLivrableWhereUniqueInput | TuteurLivrableWhereUniqueInput[]
    update?: TuteurLivrableUpdateWithWhereUniqueWithoutLivrableInput | TuteurLivrableUpdateWithWhereUniqueWithoutLivrableInput[]
    updateMany?: TuteurLivrableUpdateManyWithWhereWithoutLivrableInput | TuteurLivrableUpdateManyWithWhereWithoutLivrableInput[]
    deleteMany?: TuteurLivrableScalarWhereInput | TuteurLivrableScalarWhereInput[]
  }

  export type TuteurCreateNestedOneWithoutPFEsInput = {
    create?: XOR<TuteurCreateWithoutPFEsInput, TuteurUncheckedCreateWithoutPFEsInput>
    connectOrCreate?: TuteurCreateOrConnectWithoutPFEsInput
    connect?: TuteurWhereUniqueInput
  }

  export type PFE_GroupeCreateNestedManyWithoutPfeInput = {
    create?: XOR<PFE_GroupeCreateWithoutPfeInput, PFE_GroupeUncheckedCreateWithoutPfeInput> | PFE_GroupeCreateWithoutPfeInput[] | PFE_GroupeUncheckedCreateWithoutPfeInput[]
    connectOrCreate?: PFE_GroupeCreateOrConnectWithoutPfeInput | PFE_GroupeCreateOrConnectWithoutPfeInput[]
    createMany?: PFE_GroupeCreateManyPfeInputEnvelope
    connect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
  }

  export type PFE_LivrableCreateNestedManyWithoutPfeInput = {
    create?: XOR<PFE_LivrableCreateWithoutPfeInput, PFE_LivrableUncheckedCreateWithoutPfeInput> | PFE_LivrableCreateWithoutPfeInput[] | PFE_LivrableUncheckedCreateWithoutPfeInput[]
    connectOrCreate?: PFE_LivrableCreateOrConnectWithoutPfeInput | PFE_LivrableCreateOrConnectWithoutPfeInput[]
    createMany?: PFE_LivrableCreateManyPfeInputEnvelope
    connect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
  }

  export type PFE_GroupeUncheckedCreateNestedManyWithoutPfeInput = {
    create?: XOR<PFE_GroupeCreateWithoutPfeInput, PFE_GroupeUncheckedCreateWithoutPfeInput> | PFE_GroupeCreateWithoutPfeInput[] | PFE_GroupeUncheckedCreateWithoutPfeInput[]
    connectOrCreate?: PFE_GroupeCreateOrConnectWithoutPfeInput | PFE_GroupeCreateOrConnectWithoutPfeInput[]
    createMany?: PFE_GroupeCreateManyPfeInputEnvelope
    connect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
  }

  export type PFE_LivrableUncheckedCreateNestedManyWithoutPfeInput = {
    create?: XOR<PFE_LivrableCreateWithoutPfeInput, PFE_LivrableUncheckedCreateWithoutPfeInput> | PFE_LivrableCreateWithoutPfeInput[] | PFE_LivrableUncheckedCreateWithoutPfeInput[]
    connectOrCreate?: PFE_LivrableCreateOrConnectWithoutPfeInput | PFE_LivrableCreateOrConnectWithoutPfeInput[]
    createMany?: PFE_LivrableCreateManyPfeInputEnvelope
    connect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
  }

  export type TuteurUpdateOneRequiredWithoutPFEsNestedInput = {
    create?: XOR<TuteurCreateWithoutPFEsInput, TuteurUncheckedCreateWithoutPFEsInput>
    connectOrCreate?: TuteurCreateOrConnectWithoutPFEsInput
    upsert?: TuteurUpsertWithoutPFEsInput
    connect?: TuteurWhereUniqueInput
    update?: XOR<XOR<TuteurUpdateToOneWithWhereWithoutPFEsInput, TuteurUpdateWithoutPFEsInput>, TuteurUncheckedUpdateWithoutPFEsInput>
  }

  export type PFE_GroupeUpdateManyWithoutPfeNestedInput = {
    create?: XOR<PFE_GroupeCreateWithoutPfeInput, PFE_GroupeUncheckedCreateWithoutPfeInput> | PFE_GroupeCreateWithoutPfeInput[] | PFE_GroupeUncheckedCreateWithoutPfeInput[]
    connectOrCreate?: PFE_GroupeCreateOrConnectWithoutPfeInput | PFE_GroupeCreateOrConnectWithoutPfeInput[]
    upsert?: PFE_GroupeUpsertWithWhereUniqueWithoutPfeInput | PFE_GroupeUpsertWithWhereUniqueWithoutPfeInput[]
    createMany?: PFE_GroupeCreateManyPfeInputEnvelope
    set?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    disconnect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    delete?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    connect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    update?: PFE_GroupeUpdateWithWhereUniqueWithoutPfeInput | PFE_GroupeUpdateWithWhereUniqueWithoutPfeInput[]
    updateMany?: PFE_GroupeUpdateManyWithWhereWithoutPfeInput | PFE_GroupeUpdateManyWithWhereWithoutPfeInput[]
    deleteMany?: PFE_GroupeScalarWhereInput | PFE_GroupeScalarWhereInput[]
  }

  export type PFE_LivrableUpdateManyWithoutPfeNestedInput = {
    create?: XOR<PFE_LivrableCreateWithoutPfeInput, PFE_LivrableUncheckedCreateWithoutPfeInput> | PFE_LivrableCreateWithoutPfeInput[] | PFE_LivrableUncheckedCreateWithoutPfeInput[]
    connectOrCreate?: PFE_LivrableCreateOrConnectWithoutPfeInput | PFE_LivrableCreateOrConnectWithoutPfeInput[]
    upsert?: PFE_LivrableUpsertWithWhereUniqueWithoutPfeInput | PFE_LivrableUpsertWithWhereUniqueWithoutPfeInput[]
    createMany?: PFE_LivrableCreateManyPfeInputEnvelope
    set?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    disconnect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    delete?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    connect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    update?: PFE_LivrableUpdateWithWhereUniqueWithoutPfeInput | PFE_LivrableUpdateWithWhereUniqueWithoutPfeInput[]
    updateMany?: PFE_LivrableUpdateManyWithWhereWithoutPfeInput | PFE_LivrableUpdateManyWithWhereWithoutPfeInput[]
    deleteMany?: PFE_LivrableScalarWhereInput | PFE_LivrableScalarWhereInput[]
  }

  export type PFE_GroupeUncheckedUpdateManyWithoutPfeNestedInput = {
    create?: XOR<PFE_GroupeCreateWithoutPfeInput, PFE_GroupeUncheckedCreateWithoutPfeInput> | PFE_GroupeCreateWithoutPfeInput[] | PFE_GroupeUncheckedCreateWithoutPfeInput[]
    connectOrCreate?: PFE_GroupeCreateOrConnectWithoutPfeInput | PFE_GroupeCreateOrConnectWithoutPfeInput[]
    upsert?: PFE_GroupeUpsertWithWhereUniqueWithoutPfeInput | PFE_GroupeUpsertWithWhereUniqueWithoutPfeInput[]
    createMany?: PFE_GroupeCreateManyPfeInputEnvelope
    set?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    disconnect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    delete?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    connect?: PFE_GroupeWhereUniqueInput | PFE_GroupeWhereUniqueInput[]
    update?: PFE_GroupeUpdateWithWhereUniqueWithoutPfeInput | PFE_GroupeUpdateWithWhereUniqueWithoutPfeInput[]
    updateMany?: PFE_GroupeUpdateManyWithWhereWithoutPfeInput | PFE_GroupeUpdateManyWithWhereWithoutPfeInput[]
    deleteMany?: PFE_GroupeScalarWhereInput | PFE_GroupeScalarWhereInput[]
  }

  export type PFE_LivrableUncheckedUpdateManyWithoutPfeNestedInput = {
    create?: XOR<PFE_LivrableCreateWithoutPfeInput, PFE_LivrableUncheckedCreateWithoutPfeInput> | PFE_LivrableCreateWithoutPfeInput[] | PFE_LivrableUncheckedCreateWithoutPfeInput[]
    connectOrCreate?: PFE_LivrableCreateOrConnectWithoutPfeInput | PFE_LivrableCreateOrConnectWithoutPfeInput[]
    upsert?: PFE_LivrableUpsertWithWhereUniqueWithoutPfeInput | PFE_LivrableUpsertWithWhereUniqueWithoutPfeInput[]
    createMany?: PFE_LivrableCreateManyPfeInputEnvelope
    set?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    disconnect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    delete?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    connect?: PFE_LivrableWhereUniqueInput | PFE_LivrableWhereUniqueInput[]
    update?: PFE_LivrableUpdateWithWhereUniqueWithoutPfeInput | PFE_LivrableUpdateWithWhereUniqueWithoutPfeInput[]
    updateMany?: PFE_LivrableUpdateManyWithWhereWithoutPfeInput | PFE_LivrableUpdateManyWithWhereWithoutPfeInput[]
    deleteMany?: PFE_LivrableScalarWhereInput | PFE_LivrableScalarWhereInput[]
  }

  export type PFECreateNestedOneWithoutGroupesInput = {
    create?: XOR<PFECreateWithoutGroupesInput, PFEUncheckedCreateWithoutGroupesInput>
    connectOrCreate?: PFECreateOrConnectWithoutGroupesInput
    connect?: PFEWhereUniqueInput
  }

  export type GroupeCreateNestedOneWithoutPFEsInput = {
    create?: XOR<GroupeCreateWithoutPFEsInput, GroupeUncheckedCreateWithoutPFEsInput>
    connectOrCreate?: GroupeCreateOrConnectWithoutPFEsInput
    connect?: GroupeWhereUniqueInput
  }

  export type PFEUpdateOneRequiredWithoutGroupesNestedInput = {
    create?: XOR<PFECreateWithoutGroupesInput, PFEUncheckedCreateWithoutGroupesInput>
    connectOrCreate?: PFECreateOrConnectWithoutGroupesInput
    upsert?: PFEUpsertWithoutGroupesInput
    connect?: PFEWhereUniqueInput
    update?: XOR<XOR<PFEUpdateToOneWithWhereWithoutGroupesInput, PFEUpdateWithoutGroupesInput>, PFEUncheckedUpdateWithoutGroupesInput>
  }

  export type GroupeUpdateOneRequiredWithoutPFEsNestedInput = {
    create?: XOR<GroupeCreateWithoutPFEsInput, GroupeUncheckedCreateWithoutPFEsInput>
    connectOrCreate?: GroupeCreateOrConnectWithoutPFEsInput
    upsert?: GroupeUpsertWithoutPFEsInput
    connect?: GroupeWhereUniqueInput
    update?: XOR<XOR<GroupeUpdateToOneWithWhereWithoutPFEsInput, GroupeUpdateWithoutPFEsInput>, GroupeUncheckedUpdateWithoutPFEsInput>
  }

  export type PFECreateNestedOneWithoutLivrablesInput = {
    create?: XOR<PFECreateWithoutLivrablesInput, PFEUncheckedCreateWithoutLivrablesInput>
    connectOrCreate?: PFECreateOrConnectWithoutLivrablesInput
    connect?: PFEWhereUniqueInput
  }

  export type LivrableCreateNestedOneWithoutPFEsInput = {
    create?: XOR<LivrableCreateWithoutPFEsInput, LivrableUncheckedCreateWithoutPFEsInput>
    connectOrCreate?: LivrableCreateOrConnectWithoutPFEsInput
    connect?: LivrableWhereUniqueInput
  }

  export type PFEUpdateOneRequiredWithoutLivrablesNestedInput = {
    create?: XOR<PFECreateWithoutLivrablesInput, PFEUncheckedCreateWithoutLivrablesInput>
    connectOrCreate?: PFECreateOrConnectWithoutLivrablesInput
    upsert?: PFEUpsertWithoutLivrablesInput
    connect?: PFEWhereUniqueInput
    update?: XOR<XOR<PFEUpdateToOneWithWhereWithoutLivrablesInput, PFEUpdateWithoutLivrablesInput>, PFEUncheckedUpdateWithoutLivrablesInput>
  }

  export type LivrableUpdateOneRequiredWithoutPFEsNestedInput = {
    create?: XOR<LivrableCreateWithoutPFEsInput, LivrableUncheckedCreateWithoutPFEsInput>
    connectOrCreate?: LivrableCreateOrConnectWithoutPFEsInput
    upsert?: LivrableUpsertWithoutPFEsInput
    connect?: LivrableWhereUniqueInput
    update?: XOR<XOR<LivrableUpdateToOneWithWhereWithoutPFEsInput, LivrableUpdateWithoutPFEsInput>, LivrableUncheckedUpdateWithoutPFEsInput>
  }

  export type EncadrantCreateNestedOneWithoutLivrablesInput = {
    create?: XOR<EncadrantCreateWithoutLivrablesInput, EncadrantUncheckedCreateWithoutLivrablesInput>
    connectOrCreate?: EncadrantCreateOrConnectWithoutLivrablesInput
    connect?: EncadrantWhereUniqueInput
  }

  export type LivrableCreateNestedOneWithoutEncadrantsInput = {
    create?: XOR<LivrableCreateWithoutEncadrantsInput, LivrableUncheckedCreateWithoutEncadrantsInput>
    connectOrCreate?: LivrableCreateOrConnectWithoutEncadrantsInput
    connect?: LivrableWhereUniqueInput
  }

  export type EncadrantUpdateOneRequiredWithoutLivrablesNestedInput = {
    create?: XOR<EncadrantCreateWithoutLivrablesInput, EncadrantUncheckedCreateWithoutLivrablesInput>
    connectOrCreate?: EncadrantCreateOrConnectWithoutLivrablesInput
    upsert?: EncadrantUpsertWithoutLivrablesInput
    connect?: EncadrantWhereUniqueInput
    update?: XOR<XOR<EncadrantUpdateToOneWithWhereWithoutLivrablesInput, EncadrantUpdateWithoutLivrablesInput>, EncadrantUncheckedUpdateWithoutLivrablesInput>
  }

  export type LivrableUpdateOneRequiredWithoutEncadrantsNestedInput = {
    create?: XOR<LivrableCreateWithoutEncadrantsInput, LivrableUncheckedCreateWithoutEncadrantsInput>
    connectOrCreate?: LivrableCreateOrConnectWithoutEncadrantsInput
    upsert?: LivrableUpsertWithoutEncadrantsInput
    connect?: LivrableWhereUniqueInput
    update?: XOR<XOR<LivrableUpdateToOneWithWhereWithoutEncadrantsInput, LivrableUpdateWithoutEncadrantsInput>, LivrableUncheckedUpdateWithoutEncadrantsInput>
  }

  export type TuteurCreateNestedOneWithoutLivrablesInput = {
    create?: XOR<TuteurCreateWithoutLivrablesInput, TuteurUncheckedCreateWithoutLivrablesInput>
    connectOrCreate?: TuteurCreateOrConnectWithoutLivrablesInput
    connect?: TuteurWhereUniqueInput
  }

  export type LivrableCreateNestedOneWithoutTuteursInput = {
    create?: XOR<LivrableCreateWithoutTuteursInput, LivrableUncheckedCreateWithoutTuteursInput>
    connectOrCreate?: LivrableCreateOrConnectWithoutTuteursInput
    connect?: LivrableWhereUniqueInput
  }

  export type TuteurUpdateOneRequiredWithoutLivrablesNestedInput = {
    create?: XOR<TuteurCreateWithoutLivrablesInput, TuteurUncheckedCreateWithoutLivrablesInput>
    connectOrCreate?: TuteurCreateOrConnectWithoutLivrablesInput
    upsert?: TuteurUpsertWithoutLivrablesInput
    connect?: TuteurWhereUniqueInput
    update?: XOR<XOR<TuteurUpdateToOneWithWhereWithoutLivrablesInput, TuteurUpdateWithoutLivrablesInput>, TuteurUncheckedUpdateWithoutLivrablesInput>
  }

  export type LivrableUpdateOneRequiredWithoutTuteursNestedInput = {
    create?: XOR<LivrableCreateWithoutTuteursInput, LivrableUncheckedCreateWithoutTuteursInput>
    connectOrCreate?: LivrableCreateOrConnectWithoutTuteursInput
    upsert?: LivrableUpsertWithoutTuteursInput
    connect?: LivrableWhereUniqueInput
    update?: XOR<XOR<LivrableUpdateToOneWithWhereWithoutTuteursInput, LivrableUpdateWithoutTuteursInput>, LivrableUncheckedUpdateWithoutTuteursInput>
  }

  export type EncadrantCreateNestedOneWithoutSoutenancesInput = {
    create?: XOR<EncadrantCreateWithoutSoutenancesInput, EncadrantUncheckedCreateWithoutSoutenancesInput>
    connectOrCreate?: EncadrantCreateOrConnectWithoutSoutenancesInput
    connect?: EncadrantWhereUniqueInput
  }

  export type SoutenanceCreateNestedOneWithoutEncadrantsInput = {
    create?: XOR<SoutenanceCreateWithoutEncadrantsInput, SoutenanceUncheckedCreateWithoutEncadrantsInput>
    connectOrCreate?: SoutenanceCreateOrConnectWithoutEncadrantsInput
    connect?: SoutenanceWhereUniqueInput
  }

  export type EncadrantUpdateOneRequiredWithoutSoutenancesNestedInput = {
    create?: XOR<EncadrantCreateWithoutSoutenancesInput, EncadrantUncheckedCreateWithoutSoutenancesInput>
    connectOrCreate?: EncadrantCreateOrConnectWithoutSoutenancesInput
    upsert?: EncadrantUpsertWithoutSoutenancesInput
    connect?: EncadrantWhereUniqueInput
    update?: XOR<XOR<EncadrantUpdateToOneWithWhereWithoutSoutenancesInput, EncadrantUpdateWithoutSoutenancesInput>, EncadrantUncheckedUpdateWithoutSoutenancesInput>
  }

  export type SoutenanceUpdateOneRequiredWithoutEncadrantsNestedInput = {
    create?: XOR<SoutenanceCreateWithoutEncadrantsInput, SoutenanceUncheckedCreateWithoutEncadrantsInput>
    connectOrCreate?: SoutenanceCreateOrConnectWithoutEncadrantsInput
    upsert?: SoutenanceUpsertWithoutEncadrantsInput
    connect?: SoutenanceWhereUniqueInput
    update?: XOR<XOR<SoutenanceUpdateToOneWithWhereWithoutEncadrantsInput, SoutenanceUpdateWithoutEncadrantsInput>, SoutenanceUncheckedUpdateWithoutEncadrantsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EncadrantCreateWithoutResponsableFiliereInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    sujets?: SujetCreateNestedManyWithoutEncadrantInput
    soutenances?: EncadrantSoutenanceCreateNestedManyWithoutEncadrantInput
    livrables?: EncadrantLivrableCreateNestedManyWithoutEncadrantInput
  }

  export type EncadrantUncheckedCreateWithoutResponsableFiliereInput = {
    idEncadrant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    sujets?: SujetUncheckedCreateNestedManyWithoutEncadrantInput
    soutenances?: EncadrantSoutenanceUncheckedCreateNestedManyWithoutEncadrantInput
    livrables?: EncadrantLivrableUncheckedCreateNestedManyWithoutEncadrantInput
  }

  export type EncadrantCreateOrConnectWithoutResponsableFiliereInput = {
    where: EncadrantWhereUniqueInput
    create: XOR<EncadrantCreateWithoutResponsableFiliereInput, EncadrantUncheckedCreateWithoutResponsableFiliereInput>
  }

  export type EncadrantCreateManyResponsableFiliereInputEnvelope = {
    data: EncadrantCreateManyResponsableFiliereInput | EncadrantCreateManyResponsableFiliereInput[]
    skipDuplicates?: boolean
  }

  export type EncadrantUpsertWithWhereUniqueWithoutResponsableFiliereInput = {
    where: EncadrantWhereUniqueInput
    update: XOR<EncadrantUpdateWithoutResponsableFiliereInput, EncadrantUncheckedUpdateWithoutResponsableFiliereInput>
    create: XOR<EncadrantCreateWithoutResponsableFiliereInput, EncadrantUncheckedCreateWithoutResponsableFiliereInput>
  }

  export type EncadrantUpdateWithWhereUniqueWithoutResponsableFiliereInput = {
    where: EncadrantWhereUniqueInput
    data: XOR<EncadrantUpdateWithoutResponsableFiliereInput, EncadrantUncheckedUpdateWithoutResponsableFiliereInput>
  }

  export type EncadrantUpdateManyWithWhereWithoutResponsableFiliereInput = {
    where: EncadrantScalarWhereInput
    data: XOR<EncadrantUpdateManyMutationInput, EncadrantUncheckedUpdateManyWithoutResponsableFiliereInput>
  }

  export type EncadrantScalarWhereInput = {
    AND?: EncadrantScalarWhereInput | EncadrantScalarWhereInput[]
    OR?: EncadrantScalarWhereInput[]
    NOT?: EncadrantScalarWhereInput | EncadrantScalarWhereInput[]
    idEncadrant?: IntFilter<"Encadrant"> | number
    nom?: StringFilter<"Encadrant"> | string
    prenom?: StringFilter<"Encadrant"> | string
    email?: StringFilter<"Encadrant"> | string
    motDePasse?: StringFilter<"Encadrant"> | string
    annee?: IntFilter<"Encadrant"> | number
    idResponsableFiliere?: IntNullableFilter<"Encadrant"> | number | null
  }

  export type ResponsableFiliereCreateWithoutEncadrantsInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    departement: string
    annee: number
  }

  export type ResponsableFiliereUncheckedCreateWithoutEncadrantsInput = {
    idResponsableFiliere?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    departement: string
    annee: number
  }

  export type ResponsableFiliereCreateOrConnectWithoutEncadrantsInput = {
    where: ResponsableFiliereWhereUniqueInput
    create: XOR<ResponsableFiliereCreateWithoutEncadrantsInput, ResponsableFiliereUncheckedCreateWithoutEncadrantsInput>
  }

  export type SujetCreateWithoutEncadrantInput = {
    titre: string
    description: string
    annee: number
    etudiants?: EtudiantSujetCreateNestedManyWithoutSujetInput
  }

  export type SujetUncheckedCreateWithoutEncadrantInput = {
    idSujet?: number
    titre: string
    description: string
    annee: number
    etudiants?: EtudiantSujetUncheckedCreateNestedManyWithoutSujetInput
  }

  export type SujetCreateOrConnectWithoutEncadrantInput = {
    where: SujetWhereUniqueInput
    create: XOR<SujetCreateWithoutEncadrantInput, SujetUncheckedCreateWithoutEncadrantInput>
  }

  export type SujetCreateManyEncadrantInputEnvelope = {
    data: SujetCreateManyEncadrantInput | SujetCreateManyEncadrantInput[]
    skipDuplicates?: boolean
  }

  export type EncadrantSoutenanceCreateWithoutEncadrantInput = {
    soutenance: SoutenanceCreateNestedOneWithoutEncadrantsInput
  }

  export type EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput = {
    idSoutenance: number
  }

  export type EncadrantSoutenanceCreateOrConnectWithoutEncadrantInput = {
    where: EncadrantSoutenanceWhereUniqueInput
    create: XOR<EncadrantSoutenanceCreateWithoutEncadrantInput, EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput>
  }

  export type EncadrantSoutenanceCreateManyEncadrantInputEnvelope = {
    data: EncadrantSoutenanceCreateManyEncadrantInput | EncadrantSoutenanceCreateManyEncadrantInput[]
    skipDuplicates?: boolean
  }

  export type EncadrantLivrableCreateWithoutEncadrantInput = {
    livrable: LivrableCreateNestedOneWithoutEncadrantsInput
  }

  export type EncadrantLivrableUncheckedCreateWithoutEncadrantInput = {
    idLivrable: number
  }

  export type EncadrantLivrableCreateOrConnectWithoutEncadrantInput = {
    where: EncadrantLivrableWhereUniqueInput
    create: XOR<EncadrantLivrableCreateWithoutEncadrantInput, EncadrantLivrableUncheckedCreateWithoutEncadrantInput>
  }

  export type EncadrantLivrableCreateManyEncadrantInputEnvelope = {
    data: EncadrantLivrableCreateManyEncadrantInput | EncadrantLivrableCreateManyEncadrantInput[]
    skipDuplicates?: boolean
  }

  export type ResponsableFiliereUpsertWithoutEncadrantsInput = {
    update: XOR<ResponsableFiliereUpdateWithoutEncadrantsInput, ResponsableFiliereUncheckedUpdateWithoutEncadrantsInput>
    create: XOR<ResponsableFiliereCreateWithoutEncadrantsInput, ResponsableFiliereUncheckedCreateWithoutEncadrantsInput>
    where?: ResponsableFiliereWhereInput
  }

  export type ResponsableFiliereUpdateToOneWithWhereWithoutEncadrantsInput = {
    where?: ResponsableFiliereWhereInput
    data: XOR<ResponsableFiliereUpdateWithoutEncadrantsInput, ResponsableFiliereUncheckedUpdateWithoutEncadrantsInput>
  }

  export type ResponsableFiliereUpdateWithoutEncadrantsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type ResponsableFiliereUncheckedUpdateWithoutEncadrantsInput = {
    idResponsableFiliere?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type SujetUpsertWithWhereUniqueWithoutEncadrantInput = {
    where: SujetWhereUniqueInput
    update: XOR<SujetUpdateWithoutEncadrantInput, SujetUncheckedUpdateWithoutEncadrantInput>
    create: XOR<SujetCreateWithoutEncadrantInput, SujetUncheckedCreateWithoutEncadrantInput>
  }

  export type SujetUpdateWithWhereUniqueWithoutEncadrantInput = {
    where: SujetWhereUniqueInput
    data: XOR<SujetUpdateWithoutEncadrantInput, SujetUncheckedUpdateWithoutEncadrantInput>
  }

  export type SujetUpdateManyWithWhereWithoutEncadrantInput = {
    where: SujetScalarWhereInput
    data: XOR<SujetUpdateManyMutationInput, SujetUncheckedUpdateManyWithoutEncadrantInput>
  }

  export type SujetScalarWhereInput = {
    AND?: SujetScalarWhereInput | SujetScalarWhereInput[]
    OR?: SujetScalarWhereInput[]
    NOT?: SujetScalarWhereInput | SujetScalarWhereInput[]
    idSujet?: IntFilter<"Sujet"> | number
    titre?: StringFilter<"Sujet"> | string
    description?: StringFilter<"Sujet"> | string
    annee?: IntFilter<"Sujet"> | number
    idEncadrant?: IntFilter<"Sujet"> | number
  }

  export type EncadrantSoutenanceUpsertWithWhereUniqueWithoutEncadrantInput = {
    where: EncadrantSoutenanceWhereUniqueInput
    update: XOR<EncadrantSoutenanceUpdateWithoutEncadrantInput, EncadrantSoutenanceUncheckedUpdateWithoutEncadrantInput>
    create: XOR<EncadrantSoutenanceCreateWithoutEncadrantInput, EncadrantSoutenanceUncheckedCreateWithoutEncadrantInput>
  }

  export type EncadrantSoutenanceUpdateWithWhereUniqueWithoutEncadrantInput = {
    where: EncadrantSoutenanceWhereUniqueInput
    data: XOR<EncadrantSoutenanceUpdateWithoutEncadrantInput, EncadrantSoutenanceUncheckedUpdateWithoutEncadrantInput>
  }

  export type EncadrantSoutenanceUpdateManyWithWhereWithoutEncadrantInput = {
    where: EncadrantSoutenanceScalarWhereInput
    data: XOR<EncadrantSoutenanceUpdateManyMutationInput, EncadrantSoutenanceUncheckedUpdateManyWithoutEncadrantInput>
  }

  export type EncadrantSoutenanceScalarWhereInput = {
    AND?: EncadrantSoutenanceScalarWhereInput | EncadrantSoutenanceScalarWhereInput[]
    OR?: EncadrantSoutenanceScalarWhereInput[]
    NOT?: EncadrantSoutenanceScalarWhereInput | EncadrantSoutenanceScalarWhereInput[]
    idEncadrant?: IntFilter<"EncadrantSoutenance"> | number
    idSoutenance?: IntFilter<"EncadrantSoutenance"> | number
  }

  export type EncadrantLivrableUpsertWithWhereUniqueWithoutEncadrantInput = {
    where: EncadrantLivrableWhereUniqueInput
    update: XOR<EncadrantLivrableUpdateWithoutEncadrantInput, EncadrantLivrableUncheckedUpdateWithoutEncadrantInput>
    create: XOR<EncadrantLivrableCreateWithoutEncadrantInput, EncadrantLivrableUncheckedCreateWithoutEncadrantInput>
  }

  export type EncadrantLivrableUpdateWithWhereUniqueWithoutEncadrantInput = {
    where: EncadrantLivrableWhereUniqueInput
    data: XOR<EncadrantLivrableUpdateWithoutEncadrantInput, EncadrantLivrableUncheckedUpdateWithoutEncadrantInput>
  }

  export type EncadrantLivrableUpdateManyWithWhereWithoutEncadrantInput = {
    where: EncadrantLivrableScalarWhereInput
    data: XOR<EncadrantLivrableUpdateManyMutationInput, EncadrantLivrableUncheckedUpdateManyWithoutEncadrantInput>
  }

  export type EncadrantLivrableScalarWhereInput = {
    AND?: EncadrantLivrableScalarWhereInput | EncadrantLivrableScalarWhereInput[]
    OR?: EncadrantLivrableScalarWhereInput[]
    NOT?: EncadrantLivrableScalarWhereInput | EncadrantLivrableScalarWhereInput[]
    idEncadrant?: IntFilter<"EncadrantLivrable"> | number
    idLivrable?: IntFilter<"EncadrantLivrable"> | number
  }

  export type PFECreateWithoutTuteurInput = {
    statut: number
    annee: number
    groupes?: PFE_GroupeCreateNestedManyWithoutPfeInput
    livrables?: PFE_LivrableCreateNestedManyWithoutPfeInput
  }

  export type PFEUncheckedCreateWithoutTuteurInput = {
    idPFE?: number
    statut: number
    annee: number
    groupes?: PFE_GroupeUncheckedCreateNestedManyWithoutPfeInput
    livrables?: PFE_LivrableUncheckedCreateNestedManyWithoutPfeInput
  }

  export type PFECreateOrConnectWithoutTuteurInput = {
    where: PFEWhereUniqueInput
    create: XOR<PFECreateWithoutTuteurInput, PFEUncheckedCreateWithoutTuteurInput>
  }

  export type PFECreateManyTuteurInputEnvelope = {
    data: PFECreateManyTuteurInput | PFECreateManyTuteurInput[]
    skipDuplicates?: boolean
  }

  export type TuteurLivrableCreateWithoutTuteurInput = {
    livrable: LivrableCreateNestedOneWithoutTuteursInput
  }

  export type TuteurLivrableUncheckedCreateWithoutTuteurInput = {
    idLivrable: number
  }

  export type TuteurLivrableCreateOrConnectWithoutTuteurInput = {
    where: TuteurLivrableWhereUniqueInput
    create: XOR<TuteurLivrableCreateWithoutTuteurInput, TuteurLivrableUncheckedCreateWithoutTuteurInput>
  }

  export type TuteurLivrableCreateManyTuteurInputEnvelope = {
    data: TuteurLivrableCreateManyTuteurInput | TuteurLivrableCreateManyTuteurInput[]
    skipDuplicates?: boolean
  }

  export type PFEUpsertWithWhereUniqueWithoutTuteurInput = {
    where: PFEWhereUniqueInput
    update: XOR<PFEUpdateWithoutTuteurInput, PFEUncheckedUpdateWithoutTuteurInput>
    create: XOR<PFECreateWithoutTuteurInput, PFEUncheckedCreateWithoutTuteurInput>
  }

  export type PFEUpdateWithWhereUniqueWithoutTuteurInput = {
    where: PFEWhereUniqueInput
    data: XOR<PFEUpdateWithoutTuteurInput, PFEUncheckedUpdateWithoutTuteurInput>
  }

  export type PFEUpdateManyWithWhereWithoutTuteurInput = {
    where: PFEScalarWhereInput
    data: XOR<PFEUpdateManyMutationInput, PFEUncheckedUpdateManyWithoutTuteurInput>
  }

  export type PFEScalarWhereInput = {
    AND?: PFEScalarWhereInput | PFEScalarWhereInput[]
    OR?: PFEScalarWhereInput[]
    NOT?: PFEScalarWhereInput | PFEScalarWhereInput[]
    idPFE?: IntFilter<"PFE"> | number
    statut?: IntFilter<"PFE"> | number
    annee?: IntFilter<"PFE"> | number
    idTuteur?: IntFilter<"PFE"> | number
  }

  export type TuteurLivrableUpsertWithWhereUniqueWithoutTuteurInput = {
    where: TuteurLivrableWhereUniqueInput
    update: XOR<TuteurLivrableUpdateWithoutTuteurInput, TuteurLivrableUncheckedUpdateWithoutTuteurInput>
    create: XOR<TuteurLivrableCreateWithoutTuteurInput, TuteurLivrableUncheckedCreateWithoutTuteurInput>
  }

  export type TuteurLivrableUpdateWithWhereUniqueWithoutTuteurInput = {
    where: TuteurLivrableWhereUniqueInput
    data: XOR<TuteurLivrableUpdateWithoutTuteurInput, TuteurLivrableUncheckedUpdateWithoutTuteurInput>
  }

  export type TuteurLivrableUpdateManyWithWhereWithoutTuteurInput = {
    where: TuteurLivrableScalarWhereInput
    data: XOR<TuteurLivrableUpdateManyMutationInput, TuteurLivrableUncheckedUpdateManyWithoutTuteurInput>
  }

  export type TuteurLivrableScalarWhereInput = {
    AND?: TuteurLivrableScalarWhereInput | TuteurLivrableScalarWhereInput[]
    OR?: TuteurLivrableScalarWhereInput[]
    NOT?: TuteurLivrableScalarWhereInput | TuteurLivrableScalarWhereInput[]
    idTuteur?: IntFilter<"TuteurLivrable"> | number
    idLivrable?: IntFilter<"TuteurLivrable"> | number
  }

  export type EtudiantGroupeCreateWithoutEtudiantInput = {
    groupe: GroupeCreateNestedOneWithoutEtudiantsInput
  }

  export type EtudiantGroupeUncheckedCreateWithoutEtudiantInput = {
    idGroupe: number
  }

  export type EtudiantGroupeCreateOrConnectWithoutEtudiantInput = {
    where: EtudiantGroupeWhereUniqueInput
    create: XOR<EtudiantGroupeCreateWithoutEtudiantInput, EtudiantGroupeUncheckedCreateWithoutEtudiantInput>
  }

  export type EtudiantGroupeCreateManyEtudiantInputEnvelope = {
    data: EtudiantGroupeCreateManyEtudiantInput | EtudiantGroupeCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type EtudiantSujetCreateWithoutEtudiantInput = {
    sujet: SujetCreateNestedOneWithoutEtudiantsInput
  }

  export type EtudiantSujetUncheckedCreateWithoutEtudiantInput = {
    idSujet: number
  }

  export type EtudiantSujetCreateOrConnectWithoutEtudiantInput = {
    where: EtudiantSujetWhereUniqueInput
    create: XOR<EtudiantSujetCreateWithoutEtudiantInput, EtudiantSujetUncheckedCreateWithoutEtudiantInput>
  }

  export type EtudiantSujetCreateManyEtudiantInputEnvelope = {
    data: EtudiantSujetCreateManyEtudiantInput | EtudiantSujetCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutEtudiantInput = {
    note: number
    feedback?: string | null
    soutenance: SoutenanceCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutEtudiantInput = {
    idEvaluation?: number
    note: number
    feedback?: string | null
    idSoutenance: number
  }

  export type EvaluationCreateOrConnectWithoutEtudiantInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutEtudiantInput, EvaluationUncheckedCreateWithoutEtudiantInput>
  }

  export type EvaluationCreateManyEtudiantInputEnvelope = {
    data: EvaluationCreateManyEtudiantInput | EvaluationCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type EtudiantGroupeUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: EtudiantGroupeWhereUniqueInput
    update: XOR<EtudiantGroupeUpdateWithoutEtudiantInput, EtudiantGroupeUncheckedUpdateWithoutEtudiantInput>
    create: XOR<EtudiantGroupeCreateWithoutEtudiantInput, EtudiantGroupeUncheckedCreateWithoutEtudiantInput>
  }

  export type EtudiantGroupeUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: EtudiantGroupeWhereUniqueInput
    data: XOR<EtudiantGroupeUpdateWithoutEtudiantInput, EtudiantGroupeUncheckedUpdateWithoutEtudiantInput>
  }

  export type EtudiantGroupeUpdateManyWithWhereWithoutEtudiantInput = {
    where: EtudiantGroupeScalarWhereInput
    data: XOR<EtudiantGroupeUpdateManyMutationInput, EtudiantGroupeUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type EtudiantGroupeScalarWhereInput = {
    AND?: EtudiantGroupeScalarWhereInput | EtudiantGroupeScalarWhereInput[]
    OR?: EtudiantGroupeScalarWhereInput[]
    NOT?: EtudiantGroupeScalarWhereInput | EtudiantGroupeScalarWhereInput[]
    idEtudiant?: IntFilter<"EtudiantGroupe"> | number
    idGroupe?: IntFilter<"EtudiantGroupe"> | number
  }

  export type EtudiantSujetUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: EtudiantSujetWhereUniqueInput
    update: XOR<EtudiantSujetUpdateWithoutEtudiantInput, EtudiantSujetUncheckedUpdateWithoutEtudiantInput>
    create: XOR<EtudiantSujetCreateWithoutEtudiantInput, EtudiantSujetUncheckedCreateWithoutEtudiantInput>
  }

  export type EtudiantSujetUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: EtudiantSujetWhereUniqueInput
    data: XOR<EtudiantSujetUpdateWithoutEtudiantInput, EtudiantSujetUncheckedUpdateWithoutEtudiantInput>
  }

  export type EtudiantSujetUpdateManyWithWhereWithoutEtudiantInput = {
    where: EtudiantSujetScalarWhereInput
    data: XOR<EtudiantSujetUpdateManyMutationInput, EtudiantSujetUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type EtudiantSujetScalarWhereInput = {
    AND?: EtudiantSujetScalarWhereInput | EtudiantSujetScalarWhereInput[]
    OR?: EtudiantSujetScalarWhereInput[]
    NOT?: EtudiantSujetScalarWhereInput | EtudiantSujetScalarWhereInput[]
    idEtudiant?: IntFilter<"EtudiantSujet"> | number
    idSujet?: IntFilter<"EtudiantSujet"> | number
  }

  export type EvaluationUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutEtudiantInput, EvaluationUncheckedUpdateWithoutEtudiantInput>
    create: XOR<EvaluationCreateWithoutEtudiantInput, EvaluationUncheckedCreateWithoutEtudiantInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutEtudiantInput, EvaluationUncheckedUpdateWithoutEtudiantInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutEtudiantInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type EvaluationScalarWhereInput = {
    AND?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    OR?: EvaluationScalarWhereInput[]
    NOT?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    idEvaluation?: IntFilter<"Evaluation"> | number
    note?: FloatFilter<"Evaluation"> | number
    feedback?: StringNullableFilter<"Evaluation"> | string | null
    idSoutenance?: IntFilter<"Evaluation"> | number
    idEtudiant?: IntFilter<"Evaluation"> | number
  }

  export type EtudiantGroupeCreateWithoutGroupeInput = {
    etudiant: EtudiantCreateNestedOneWithoutGroupesInput
  }

  export type EtudiantGroupeUncheckedCreateWithoutGroupeInput = {
    idEtudiant: number
  }

  export type EtudiantGroupeCreateOrConnectWithoutGroupeInput = {
    where: EtudiantGroupeWhereUniqueInput
    create: XOR<EtudiantGroupeCreateWithoutGroupeInput, EtudiantGroupeUncheckedCreateWithoutGroupeInput>
  }

  export type EtudiantGroupeCreateManyGroupeInputEnvelope = {
    data: EtudiantGroupeCreateManyGroupeInput | EtudiantGroupeCreateManyGroupeInput[]
    skipDuplicates?: boolean
  }

  export type PFE_GroupeCreateWithoutGroupeInput = {
    pfe: PFECreateNestedOneWithoutGroupesInput
  }

  export type PFE_GroupeUncheckedCreateWithoutGroupeInput = {
    idPFE: number
  }

  export type PFE_GroupeCreateOrConnectWithoutGroupeInput = {
    where: PFE_GroupeWhereUniqueInput
    create: XOR<PFE_GroupeCreateWithoutGroupeInput, PFE_GroupeUncheckedCreateWithoutGroupeInput>
  }

  export type PFE_GroupeCreateManyGroupeInputEnvelope = {
    data: PFE_GroupeCreateManyGroupeInput | PFE_GroupeCreateManyGroupeInput[]
    skipDuplicates?: boolean
  }

  export type EtudiantGroupeUpsertWithWhereUniqueWithoutGroupeInput = {
    where: EtudiantGroupeWhereUniqueInput
    update: XOR<EtudiantGroupeUpdateWithoutGroupeInput, EtudiantGroupeUncheckedUpdateWithoutGroupeInput>
    create: XOR<EtudiantGroupeCreateWithoutGroupeInput, EtudiantGroupeUncheckedCreateWithoutGroupeInput>
  }

  export type EtudiantGroupeUpdateWithWhereUniqueWithoutGroupeInput = {
    where: EtudiantGroupeWhereUniqueInput
    data: XOR<EtudiantGroupeUpdateWithoutGroupeInput, EtudiantGroupeUncheckedUpdateWithoutGroupeInput>
  }

  export type EtudiantGroupeUpdateManyWithWhereWithoutGroupeInput = {
    where: EtudiantGroupeScalarWhereInput
    data: XOR<EtudiantGroupeUpdateManyMutationInput, EtudiantGroupeUncheckedUpdateManyWithoutGroupeInput>
  }

  export type PFE_GroupeUpsertWithWhereUniqueWithoutGroupeInput = {
    where: PFE_GroupeWhereUniqueInput
    update: XOR<PFE_GroupeUpdateWithoutGroupeInput, PFE_GroupeUncheckedUpdateWithoutGroupeInput>
    create: XOR<PFE_GroupeCreateWithoutGroupeInput, PFE_GroupeUncheckedCreateWithoutGroupeInput>
  }

  export type PFE_GroupeUpdateWithWhereUniqueWithoutGroupeInput = {
    where: PFE_GroupeWhereUniqueInput
    data: XOR<PFE_GroupeUpdateWithoutGroupeInput, PFE_GroupeUncheckedUpdateWithoutGroupeInput>
  }

  export type PFE_GroupeUpdateManyWithWhereWithoutGroupeInput = {
    where: PFE_GroupeScalarWhereInput
    data: XOR<PFE_GroupeUpdateManyMutationInput, PFE_GroupeUncheckedUpdateManyWithoutGroupeInput>
  }

  export type PFE_GroupeScalarWhereInput = {
    AND?: PFE_GroupeScalarWhereInput | PFE_GroupeScalarWhereInput[]
    OR?: PFE_GroupeScalarWhereInput[]
    NOT?: PFE_GroupeScalarWhereInput | PFE_GroupeScalarWhereInput[]
    idPFE?: IntFilter<"PFE_Groupe"> | number
    idGroupe?: IntFilter<"PFE_Groupe"> | number
  }

  export type EtudiantCreateWithoutGroupesInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    classe: string
    filiere: string
    sujets?: EtudiantSujetCreateNestedManyWithoutEtudiantInput
    evaluations?: EvaluationCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutGroupesInput = {
    idEtudiant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    classe: string
    filiere: string
    sujets?: EtudiantSujetUncheckedCreateNestedManyWithoutEtudiantInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutGroupesInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutGroupesInput, EtudiantUncheckedCreateWithoutGroupesInput>
  }

  export type GroupeCreateWithoutEtudiantsInput = {
    nomGroupe: string
    nbEtudiants: number
    PFEs?: PFE_GroupeCreateNestedManyWithoutGroupeInput
  }

  export type GroupeUncheckedCreateWithoutEtudiantsInput = {
    idGroupe?: number
    nomGroupe: string
    nbEtudiants: number
    PFEs?: PFE_GroupeUncheckedCreateNestedManyWithoutGroupeInput
  }

  export type GroupeCreateOrConnectWithoutEtudiantsInput = {
    where: GroupeWhereUniqueInput
    create: XOR<GroupeCreateWithoutEtudiantsInput, GroupeUncheckedCreateWithoutEtudiantsInput>
  }

  export type EtudiantUpsertWithoutGroupesInput = {
    update: XOR<EtudiantUpdateWithoutGroupesInput, EtudiantUncheckedUpdateWithoutGroupesInput>
    create: XOR<EtudiantCreateWithoutGroupesInput, EtudiantUncheckedCreateWithoutGroupesInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutGroupesInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutGroupesInput, EtudiantUncheckedUpdateWithoutGroupesInput>
  }

  export type EtudiantUpdateWithoutGroupesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    sujets?: EtudiantSujetUpdateManyWithoutEtudiantNestedInput
    evaluations?: EvaluationUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutGroupesInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    sujets?: EtudiantSujetUncheckedUpdateManyWithoutEtudiantNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type GroupeUpsertWithoutEtudiantsInput = {
    update: XOR<GroupeUpdateWithoutEtudiantsInput, GroupeUncheckedUpdateWithoutEtudiantsInput>
    create: XOR<GroupeCreateWithoutEtudiantsInput, GroupeUncheckedCreateWithoutEtudiantsInput>
    where?: GroupeWhereInput
  }

  export type GroupeUpdateToOneWithWhereWithoutEtudiantsInput = {
    where?: GroupeWhereInput
    data: XOR<GroupeUpdateWithoutEtudiantsInput, GroupeUncheckedUpdateWithoutEtudiantsInput>
  }

  export type GroupeUpdateWithoutEtudiantsInput = {
    nomGroupe?: StringFieldUpdateOperationsInput | string
    nbEtudiants?: IntFieldUpdateOperationsInput | number
    PFEs?: PFE_GroupeUpdateManyWithoutGroupeNestedInput
  }

  export type GroupeUncheckedUpdateWithoutEtudiantsInput = {
    idGroupe?: IntFieldUpdateOperationsInput | number
    nomGroupe?: StringFieldUpdateOperationsInput | string
    nbEtudiants?: IntFieldUpdateOperationsInput | number
    PFEs?: PFE_GroupeUncheckedUpdateManyWithoutGroupeNestedInput
  }

  export type EncadrantCreateWithoutSujetsInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    responsableFiliere?: ResponsableFiliereCreateNestedOneWithoutEncadrantsInput
    soutenances?: EncadrantSoutenanceCreateNestedManyWithoutEncadrantInput
    livrables?: EncadrantLivrableCreateNestedManyWithoutEncadrantInput
  }

  export type EncadrantUncheckedCreateWithoutSujetsInput = {
    idEncadrant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    idResponsableFiliere?: number | null
    soutenances?: EncadrantSoutenanceUncheckedCreateNestedManyWithoutEncadrantInput
    livrables?: EncadrantLivrableUncheckedCreateNestedManyWithoutEncadrantInput
  }

  export type EncadrantCreateOrConnectWithoutSujetsInput = {
    where: EncadrantWhereUniqueInput
    create: XOR<EncadrantCreateWithoutSujetsInput, EncadrantUncheckedCreateWithoutSujetsInput>
  }

  export type EtudiantSujetCreateWithoutSujetInput = {
    etudiant: EtudiantCreateNestedOneWithoutSujetsInput
  }

  export type EtudiantSujetUncheckedCreateWithoutSujetInput = {
    idEtudiant: number
  }

  export type EtudiantSujetCreateOrConnectWithoutSujetInput = {
    where: EtudiantSujetWhereUniqueInput
    create: XOR<EtudiantSujetCreateWithoutSujetInput, EtudiantSujetUncheckedCreateWithoutSujetInput>
  }

  export type EtudiantSujetCreateManySujetInputEnvelope = {
    data: EtudiantSujetCreateManySujetInput | EtudiantSujetCreateManySujetInput[]
    skipDuplicates?: boolean
  }

  export type EncadrantUpsertWithoutSujetsInput = {
    update: XOR<EncadrantUpdateWithoutSujetsInput, EncadrantUncheckedUpdateWithoutSujetsInput>
    create: XOR<EncadrantCreateWithoutSujetsInput, EncadrantUncheckedCreateWithoutSujetsInput>
    where?: EncadrantWhereInput
  }

  export type EncadrantUpdateToOneWithWhereWithoutSujetsInput = {
    where?: EncadrantWhereInput
    data: XOR<EncadrantUpdateWithoutSujetsInput, EncadrantUncheckedUpdateWithoutSujetsInput>
  }

  export type EncadrantUpdateWithoutSujetsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    responsableFiliere?: ResponsableFiliereUpdateOneWithoutEncadrantsNestedInput
    soutenances?: EncadrantSoutenanceUpdateManyWithoutEncadrantNestedInput
    livrables?: EncadrantLivrableUpdateManyWithoutEncadrantNestedInput
  }

  export type EncadrantUncheckedUpdateWithoutSujetsInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    idResponsableFiliere?: NullableIntFieldUpdateOperationsInput | number | null
    soutenances?: EncadrantSoutenanceUncheckedUpdateManyWithoutEncadrantNestedInput
    livrables?: EncadrantLivrableUncheckedUpdateManyWithoutEncadrantNestedInput
  }

  export type EtudiantSujetUpsertWithWhereUniqueWithoutSujetInput = {
    where: EtudiantSujetWhereUniqueInput
    update: XOR<EtudiantSujetUpdateWithoutSujetInput, EtudiantSujetUncheckedUpdateWithoutSujetInput>
    create: XOR<EtudiantSujetCreateWithoutSujetInput, EtudiantSujetUncheckedCreateWithoutSujetInput>
  }

  export type EtudiantSujetUpdateWithWhereUniqueWithoutSujetInput = {
    where: EtudiantSujetWhereUniqueInput
    data: XOR<EtudiantSujetUpdateWithoutSujetInput, EtudiantSujetUncheckedUpdateWithoutSujetInput>
  }

  export type EtudiantSujetUpdateManyWithWhereWithoutSujetInput = {
    where: EtudiantSujetScalarWhereInput
    data: XOR<EtudiantSujetUpdateManyMutationInput, EtudiantSujetUncheckedUpdateManyWithoutSujetInput>
  }

  export type EtudiantCreateWithoutSujetsInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    classe: string
    filiere: string
    groupes?: EtudiantGroupeCreateNestedManyWithoutEtudiantInput
    evaluations?: EvaluationCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutSujetsInput = {
    idEtudiant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    classe: string
    filiere: string
    groupes?: EtudiantGroupeUncheckedCreateNestedManyWithoutEtudiantInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutSujetsInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutSujetsInput, EtudiantUncheckedCreateWithoutSujetsInput>
  }

  export type SujetCreateWithoutEtudiantsInput = {
    titre: string
    description: string
    annee: number
    encadrant: EncadrantCreateNestedOneWithoutSujetsInput
  }

  export type SujetUncheckedCreateWithoutEtudiantsInput = {
    idSujet?: number
    titre: string
    description: string
    annee: number
    idEncadrant: number
  }

  export type SujetCreateOrConnectWithoutEtudiantsInput = {
    where: SujetWhereUniqueInput
    create: XOR<SujetCreateWithoutEtudiantsInput, SujetUncheckedCreateWithoutEtudiantsInput>
  }

  export type EtudiantUpsertWithoutSujetsInput = {
    update: XOR<EtudiantUpdateWithoutSujetsInput, EtudiantUncheckedUpdateWithoutSujetsInput>
    create: XOR<EtudiantCreateWithoutSujetsInput, EtudiantUncheckedCreateWithoutSujetsInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutSujetsInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutSujetsInput, EtudiantUncheckedUpdateWithoutSujetsInput>
  }

  export type EtudiantUpdateWithoutSujetsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    groupes?: EtudiantGroupeUpdateManyWithoutEtudiantNestedInput
    evaluations?: EvaluationUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutSujetsInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    groupes?: EtudiantGroupeUncheckedUpdateManyWithoutEtudiantNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type SujetUpsertWithoutEtudiantsInput = {
    update: XOR<SujetUpdateWithoutEtudiantsInput, SujetUncheckedUpdateWithoutEtudiantsInput>
    create: XOR<SujetCreateWithoutEtudiantsInput, SujetUncheckedCreateWithoutEtudiantsInput>
    where?: SujetWhereInput
  }

  export type SujetUpdateToOneWithWhereWithoutEtudiantsInput = {
    where?: SujetWhereInput
    data: XOR<SujetUpdateWithoutEtudiantsInput, SujetUncheckedUpdateWithoutEtudiantsInput>
  }

  export type SujetUpdateWithoutEtudiantsInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    encadrant?: EncadrantUpdateOneRequiredWithoutSujetsNestedInput
  }

  export type SujetUncheckedUpdateWithoutEtudiantsInput = {
    idSujet?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    idEncadrant?: IntFieldUpdateOperationsInput | number
  }

  export type SoutenanceCreateWithoutJuryInput = {
    date: Date | string
    heure: Date | string
    encadrants?: EncadrantSoutenanceCreateNestedManyWithoutSoutenanceInput
    evaluations?: EvaluationCreateNestedManyWithoutSoutenanceInput
  }

  export type SoutenanceUncheckedCreateWithoutJuryInput = {
    idSoutenance?: number
    date: Date | string
    heure: Date | string
    encadrants?: EncadrantSoutenanceUncheckedCreateNestedManyWithoutSoutenanceInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSoutenanceInput
  }

  export type SoutenanceCreateOrConnectWithoutJuryInput = {
    where: SoutenanceWhereUniqueInput
    create: XOR<SoutenanceCreateWithoutJuryInput, SoutenanceUncheckedCreateWithoutJuryInput>
  }

  export type SoutenanceCreateManyJuryInputEnvelope = {
    data: SoutenanceCreateManyJuryInput | SoutenanceCreateManyJuryInput[]
    skipDuplicates?: boolean
  }

  export type SoutenanceUpsertWithWhereUniqueWithoutJuryInput = {
    where: SoutenanceWhereUniqueInput
    update: XOR<SoutenanceUpdateWithoutJuryInput, SoutenanceUncheckedUpdateWithoutJuryInput>
    create: XOR<SoutenanceCreateWithoutJuryInput, SoutenanceUncheckedCreateWithoutJuryInput>
  }

  export type SoutenanceUpdateWithWhereUniqueWithoutJuryInput = {
    where: SoutenanceWhereUniqueInput
    data: XOR<SoutenanceUpdateWithoutJuryInput, SoutenanceUncheckedUpdateWithoutJuryInput>
  }

  export type SoutenanceUpdateManyWithWhereWithoutJuryInput = {
    where: SoutenanceScalarWhereInput
    data: XOR<SoutenanceUpdateManyMutationInput, SoutenanceUncheckedUpdateManyWithoutJuryInput>
  }

  export type SoutenanceScalarWhereInput = {
    AND?: SoutenanceScalarWhereInput | SoutenanceScalarWhereInput[]
    OR?: SoutenanceScalarWhereInput[]
    NOT?: SoutenanceScalarWhereInput | SoutenanceScalarWhereInput[]
    idSoutenance?: IntFilter<"Soutenance"> | number
    date?: DateTimeFilter<"Soutenance"> | Date | string
    heure?: DateTimeFilter<"Soutenance"> | Date | string
    idJury?: IntFilter<"Soutenance"> | number
  }

  export type JuryCreateWithoutSoutenancesInput = {
    valideDeliberation: boolean
  }

  export type JuryUncheckedCreateWithoutSoutenancesInput = {
    idJury?: number
    valideDeliberation: boolean
  }

  export type JuryCreateOrConnectWithoutSoutenancesInput = {
    where: JuryWhereUniqueInput
    create: XOR<JuryCreateWithoutSoutenancesInput, JuryUncheckedCreateWithoutSoutenancesInput>
  }

  export type EncadrantSoutenanceCreateWithoutSoutenanceInput = {
    encadrant: EncadrantCreateNestedOneWithoutSoutenancesInput
  }

  export type EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput = {
    idEncadrant: number
  }

  export type EncadrantSoutenanceCreateOrConnectWithoutSoutenanceInput = {
    where: EncadrantSoutenanceWhereUniqueInput
    create: XOR<EncadrantSoutenanceCreateWithoutSoutenanceInput, EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput>
  }

  export type EncadrantSoutenanceCreateManySoutenanceInputEnvelope = {
    data: EncadrantSoutenanceCreateManySoutenanceInput | EncadrantSoutenanceCreateManySoutenanceInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutSoutenanceInput = {
    note: number
    feedback?: string | null
    etudiant: EtudiantCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutSoutenanceInput = {
    idEvaluation?: number
    note: number
    feedback?: string | null
    idEtudiant: number
  }

  export type EvaluationCreateOrConnectWithoutSoutenanceInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutSoutenanceInput, EvaluationUncheckedCreateWithoutSoutenanceInput>
  }

  export type EvaluationCreateManySoutenanceInputEnvelope = {
    data: EvaluationCreateManySoutenanceInput | EvaluationCreateManySoutenanceInput[]
    skipDuplicates?: boolean
  }

  export type JuryUpsertWithoutSoutenancesInput = {
    update: XOR<JuryUpdateWithoutSoutenancesInput, JuryUncheckedUpdateWithoutSoutenancesInput>
    create: XOR<JuryCreateWithoutSoutenancesInput, JuryUncheckedCreateWithoutSoutenancesInput>
    where?: JuryWhereInput
  }

  export type JuryUpdateToOneWithWhereWithoutSoutenancesInput = {
    where?: JuryWhereInput
    data: XOR<JuryUpdateWithoutSoutenancesInput, JuryUncheckedUpdateWithoutSoutenancesInput>
  }

  export type JuryUpdateWithoutSoutenancesInput = {
    valideDeliberation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JuryUncheckedUpdateWithoutSoutenancesInput = {
    idJury?: IntFieldUpdateOperationsInput | number
    valideDeliberation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncadrantSoutenanceUpsertWithWhereUniqueWithoutSoutenanceInput = {
    where: EncadrantSoutenanceWhereUniqueInput
    update: XOR<EncadrantSoutenanceUpdateWithoutSoutenanceInput, EncadrantSoutenanceUncheckedUpdateWithoutSoutenanceInput>
    create: XOR<EncadrantSoutenanceCreateWithoutSoutenanceInput, EncadrantSoutenanceUncheckedCreateWithoutSoutenanceInput>
  }

  export type EncadrantSoutenanceUpdateWithWhereUniqueWithoutSoutenanceInput = {
    where: EncadrantSoutenanceWhereUniqueInput
    data: XOR<EncadrantSoutenanceUpdateWithoutSoutenanceInput, EncadrantSoutenanceUncheckedUpdateWithoutSoutenanceInput>
  }

  export type EncadrantSoutenanceUpdateManyWithWhereWithoutSoutenanceInput = {
    where: EncadrantSoutenanceScalarWhereInput
    data: XOR<EncadrantSoutenanceUpdateManyMutationInput, EncadrantSoutenanceUncheckedUpdateManyWithoutSoutenanceInput>
  }

  export type EvaluationUpsertWithWhereUniqueWithoutSoutenanceInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutSoutenanceInput, EvaluationUncheckedUpdateWithoutSoutenanceInput>
    create: XOR<EvaluationCreateWithoutSoutenanceInput, EvaluationUncheckedCreateWithoutSoutenanceInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutSoutenanceInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutSoutenanceInput, EvaluationUncheckedUpdateWithoutSoutenanceInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutSoutenanceInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutSoutenanceInput>
  }

  export type SoutenanceCreateWithoutEvaluationsInput = {
    date: Date | string
    heure: Date | string
    jury: JuryCreateNestedOneWithoutSoutenancesInput
    encadrants?: EncadrantSoutenanceCreateNestedManyWithoutSoutenanceInput
  }

  export type SoutenanceUncheckedCreateWithoutEvaluationsInput = {
    idSoutenance?: number
    date: Date | string
    heure: Date | string
    idJury: number
    encadrants?: EncadrantSoutenanceUncheckedCreateNestedManyWithoutSoutenanceInput
  }

  export type SoutenanceCreateOrConnectWithoutEvaluationsInput = {
    where: SoutenanceWhereUniqueInput
    create: XOR<SoutenanceCreateWithoutEvaluationsInput, SoutenanceUncheckedCreateWithoutEvaluationsInput>
  }

  export type EtudiantCreateWithoutEvaluationsInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    classe: string
    filiere: string
    groupes?: EtudiantGroupeCreateNestedManyWithoutEtudiantInput
    sujets?: EtudiantSujetCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantUncheckedCreateWithoutEvaluationsInput = {
    idEtudiant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    classe: string
    filiere: string
    groupes?: EtudiantGroupeUncheckedCreateNestedManyWithoutEtudiantInput
    sujets?: EtudiantSujetUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type EtudiantCreateOrConnectWithoutEvaluationsInput = {
    where: EtudiantWhereUniqueInput
    create: XOR<EtudiantCreateWithoutEvaluationsInput, EtudiantUncheckedCreateWithoutEvaluationsInput>
  }

  export type SoutenanceUpsertWithoutEvaluationsInput = {
    update: XOR<SoutenanceUpdateWithoutEvaluationsInput, SoutenanceUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<SoutenanceCreateWithoutEvaluationsInput, SoutenanceUncheckedCreateWithoutEvaluationsInput>
    where?: SoutenanceWhereInput
  }

  export type SoutenanceUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: SoutenanceWhereInput
    data: XOR<SoutenanceUpdateWithoutEvaluationsInput, SoutenanceUncheckedUpdateWithoutEvaluationsInput>
  }

  export type SoutenanceUpdateWithoutEvaluationsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
    jury?: JuryUpdateOneRequiredWithoutSoutenancesNestedInput
    encadrants?: EncadrantSoutenanceUpdateManyWithoutSoutenanceNestedInput
  }

  export type SoutenanceUncheckedUpdateWithoutEvaluationsInput = {
    idSoutenance?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
    idJury?: IntFieldUpdateOperationsInput | number
    encadrants?: EncadrantSoutenanceUncheckedUpdateManyWithoutSoutenanceNestedInput
  }

  export type EtudiantUpsertWithoutEvaluationsInput = {
    update: XOR<EtudiantUpdateWithoutEvaluationsInput, EtudiantUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<EtudiantCreateWithoutEvaluationsInput, EtudiantUncheckedCreateWithoutEvaluationsInput>
    where?: EtudiantWhereInput
  }

  export type EtudiantUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: EtudiantWhereInput
    data: XOR<EtudiantUpdateWithoutEvaluationsInput, EtudiantUncheckedUpdateWithoutEvaluationsInput>
  }

  export type EtudiantUpdateWithoutEvaluationsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    groupes?: EtudiantGroupeUpdateManyWithoutEtudiantNestedInput
    sujets?: EtudiantSujetUpdateManyWithoutEtudiantNestedInput
  }

  export type EtudiantUncheckedUpdateWithoutEvaluationsInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    groupes?: EtudiantGroupeUncheckedUpdateManyWithoutEtudiantNestedInput
    sujets?: EtudiantSujetUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type PFE_LivrableCreateWithoutLivrableInput = {
    pfe: PFECreateNestedOneWithoutLivrablesInput
  }

  export type PFE_LivrableUncheckedCreateWithoutLivrableInput = {
    idPFE: number
  }

  export type PFE_LivrableCreateOrConnectWithoutLivrableInput = {
    where: PFE_LivrableWhereUniqueInput
    create: XOR<PFE_LivrableCreateWithoutLivrableInput, PFE_LivrableUncheckedCreateWithoutLivrableInput>
  }

  export type PFE_LivrableCreateManyLivrableInputEnvelope = {
    data: PFE_LivrableCreateManyLivrableInput | PFE_LivrableCreateManyLivrableInput[]
    skipDuplicates?: boolean
  }

  export type EncadrantLivrableCreateWithoutLivrableInput = {
    encadrant: EncadrantCreateNestedOneWithoutLivrablesInput
  }

  export type EncadrantLivrableUncheckedCreateWithoutLivrableInput = {
    idEncadrant: number
  }

  export type EncadrantLivrableCreateOrConnectWithoutLivrableInput = {
    where: EncadrantLivrableWhereUniqueInput
    create: XOR<EncadrantLivrableCreateWithoutLivrableInput, EncadrantLivrableUncheckedCreateWithoutLivrableInput>
  }

  export type EncadrantLivrableCreateManyLivrableInputEnvelope = {
    data: EncadrantLivrableCreateManyLivrableInput | EncadrantLivrableCreateManyLivrableInput[]
    skipDuplicates?: boolean
  }

  export type TuteurLivrableCreateWithoutLivrableInput = {
    tuteur: TuteurCreateNestedOneWithoutLivrablesInput
  }

  export type TuteurLivrableUncheckedCreateWithoutLivrableInput = {
    idTuteur: number
  }

  export type TuteurLivrableCreateOrConnectWithoutLivrableInput = {
    where: TuteurLivrableWhereUniqueInput
    create: XOR<TuteurLivrableCreateWithoutLivrableInput, TuteurLivrableUncheckedCreateWithoutLivrableInput>
  }

  export type TuteurLivrableCreateManyLivrableInputEnvelope = {
    data: TuteurLivrableCreateManyLivrableInput | TuteurLivrableCreateManyLivrableInput[]
    skipDuplicates?: boolean
  }

  export type PFE_LivrableUpsertWithWhereUniqueWithoutLivrableInput = {
    where: PFE_LivrableWhereUniqueInput
    update: XOR<PFE_LivrableUpdateWithoutLivrableInput, PFE_LivrableUncheckedUpdateWithoutLivrableInput>
    create: XOR<PFE_LivrableCreateWithoutLivrableInput, PFE_LivrableUncheckedCreateWithoutLivrableInput>
  }

  export type PFE_LivrableUpdateWithWhereUniqueWithoutLivrableInput = {
    where: PFE_LivrableWhereUniqueInput
    data: XOR<PFE_LivrableUpdateWithoutLivrableInput, PFE_LivrableUncheckedUpdateWithoutLivrableInput>
  }

  export type PFE_LivrableUpdateManyWithWhereWithoutLivrableInput = {
    where: PFE_LivrableScalarWhereInput
    data: XOR<PFE_LivrableUpdateManyMutationInput, PFE_LivrableUncheckedUpdateManyWithoutLivrableInput>
  }

  export type PFE_LivrableScalarWhereInput = {
    AND?: PFE_LivrableScalarWhereInput | PFE_LivrableScalarWhereInput[]
    OR?: PFE_LivrableScalarWhereInput[]
    NOT?: PFE_LivrableScalarWhereInput | PFE_LivrableScalarWhereInput[]
    idPFE?: IntFilter<"PFE_Livrable"> | number
    idLivrable?: IntFilter<"PFE_Livrable"> | number
  }

  export type EncadrantLivrableUpsertWithWhereUniqueWithoutLivrableInput = {
    where: EncadrantLivrableWhereUniqueInput
    update: XOR<EncadrantLivrableUpdateWithoutLivrableInput, EncadrantLivrableUncheckedUpdateWithoutLivrableInput>
    create: XOR<EncadrantLivrableCreateWithoutLivrableInput, EncadrantLivrableUncheckedCreateWithoutLivrableInput>
  }

  export type EncadrantLivrableUpdateWithWhereUniqueWithoutLivrableInput = {
    where: EncadrantLivrableWhereUniqueInput
    data: XOR<EncadrantLivrableUpdateWithoutLivrableInput, EncadrantLivrableUncheckedUpdateWithoutLivrableInput>
  }

  export type EncadrantLivrableUpdateManyWithWhereWithoutLivrableInput = {
    where: EncadrantLivrableScalarWhereInput
    data: XOR<EncadrantLivrableUpdateManyMutationInput, EncadrantLivrableUncheckedUpdateManyWithoutLivrableInput>
  }

  export type TuteurLivrableUpsertWithWhereUniqueWithoutLivrableInput = {
    where: TuteurLivrableWhereUniqueInput
    update: XOR<TuteurLivrableUpdateWithoutLivrableInput, TuteurLivrableUncheckedUpdateWithoutLivrableInput>
    create: XOR<TuteurLivrableCreateWithoutLivrableInput, TuteurLivrableUncheckedCreateWithoutLivrableInput>
  }

  export type TuteurLivrableUpdateWithWhereUniqueWithoutLivrableInput = {
    where: TuteurLivrableWhereUniqueInput
    data: XOR<TuteurLivrableUpdateWithoutLivrableInput, TuteurLivrableUncheckedUpdateWithoutLivrableInput>
  }

  export type TuteurLivrableUpdateManyWithWhereWithoutLivrableInput = {
    where: TuteurLivrableScalarWhereInput
    data: XOR<TuteurLivrableUpdateManyMutationInput, TuteurLivrableUncheckedUpdateManyWithoutLivrableInput>
  }

  export type TuteurCreateWithoutPFEsInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    classe: string
    filiere: string
    annee: number
    livrables?: TuteurLivrableCreateNestedManyWithoutTuteurInput
  }

  export type TuteurUncheckedCreateWithoutPFEsInput = {
    idTuteur?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    classe: string
    filiere: string
    annee: number
    livrables?: TuteurLivrableUncheckedCreateNestedManyWithoutTuteurInput
  }

  export type TuteurCreateOrConnectWithoutPFEsInput = {
    where: TuteurWhereUniqueInput
    create: XOR<TuteurCreateWithoutPFEsInput, TuteurUncheckedCreateWithoutPFEsInput>
  }

  export type PFE_GroupeCreateWithoutPfeInput = {
    groupe: GroupeCreateNestedOneWithoutPFEsInput
  }

  export type PFE_GroupeUncheckedCreateWithoutPfeInput = {
    idGroupe: number
  }

  export type PFE_GroupeCreateOrConnectWithoutPfeInput = {
    where: PFE_GroupeWhereUniqueInput
    create: XOR<PFE_GroupeCreateWithoutPfeInput, PFE_GroupeUncheckedCreateWithoutPfeInput>
  }

  export type PFE_GroupeCreateManyPfeInputEnvelope = {
    data: PFE_GroupeCreateManyPfeInput | PFE_GroupeCreateManyPfeInput[]
    skipDuplicates?: boolean
  }

  export type PFE_LivrableCreateWithoutPfeInput = {
    livrable: LivrableCreateNestedOneWithoutPFEsInput
  }

  export type PFE_LivrableUncheckedCreateWithoutPfeInput = {
    idLivrable: number
  }

  export type PFE_LivrableCreateOrConnectWithoutPfeInput = {
    where: PFE_LivrableWhereUniqueInput
    create: XOR<PFE_LivrableCreateWithoutPfeInput, PFE_LivrableUncheckedCreateWithoutPfeInput>
  }

  export type PFE_LivrableCreateManyPfeInputEnvelope = {
    data: PFE_LivrableCreateManyPfeInput | PFE_LivrableCreateManyPfeInput[]
    skipDuplicates?: boolean
  }

  export type TuteurUpsertWithoutPFEsInput = {
    update: XOR<TuteurUpdateWithoutPFEsInput, TuteurUncheckedUpdateWithoutPFEsInput>
    create: XOR<TuteurCreateWithoutPFEsInput, TuteurUncheckedCreateWithoutPFEsInput>
    where?: TuteurWhereInput
  }

  export type TuteurUpdateToOneWithWhereWithoutPFEsInput = {
    where?: TuteurWhereInput
    data: XOR<TuteurUpdateWithoutPFEsInput, TuteurUncheckedUpdateWithoutPFEsInput>
  }

  export type TuteurUpdateWithoutPFEsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    livrables?: TuteurLivrableUpdateManyWithoutTuteurNestedInput
  }

  export type TuteurUncheckedUpdateWithoutPFEsInput = {
    idTuteur?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    livrables?: TuteurLivrableUncheckedUpdateManyWithoutTuteurNestedInput
  }

  export type PFE_GroupeUpsertWithWhereUniqueWithoutPfeInput = {
    where: PFE_GroupeWhereUniqueInput
    update: XOR<PFE_GroupeUpdateWithoutPfeInput, PFE_GroupeUncheckedUpdateWithoutPfeInput>
    create: XOR<PFE_GroupeCreateWithoutPfeInput, PFE_GroupeUncheckedCreateWithoutPfeInput>
  }

  export type PFE_GroupeUpdateWithWhereUniqueWithoutPfeInput = {
    where: PFE_GroupeWhereUniqueInput
    data: XOR<PFE_GroupeUpdateWithoutPfeInput, PFE_GroupeUncheckedUpdateWithoutPfeInput>
  }

  export type PFE_GroupeUpdateManyWithWhereWithoutPfeInput = {
    where: PFE_GroupeScalarWhereInput
    data: XOR<PFE_GroupeUpdateManyMutationInput, PFE_GroupeUncheckedUpdateManyWithoutPfeInput>
  }

  export type PFE_LivrableUpsertWithWhereUniqueWithoutPfeInput = {
    where: PFE_LivrableWhereUniqueInput
    update: XOR<PFE_LivrableUpdateWithoutPfeInput, PFE_LivrableUncheckedUpdateWithoutPfeInput>
    create: XOR<PFE_LivrableCreateWithoutPfeInput, PFE_LivrableUncheckedCreateWithoutPfeInput>
  }

  export type PFE_LivrableUpdateWithWhereUniqueWithoutPfeInput = {
    where: PFE_LivrableWhereUniqueInput
    data: XOR<PFE_LivrableUpdateWithoutPfeInput, PFE_LivrableUncheckedUpdateWithoutPfeInput>
  }

  export type PFE_LivrableUpdateManyWithWhereWithoutPfeInput = {
    where: PFE_LivrableScalarWhereInput
    data: XOR<PFE_LivrableUpdateManyMutationInput, PFE_LivrableUncheckedUpdateManyWithoutPfeInput>
  }

  export type PFECreateWithoutGroupesInput = {
    statut: number
    annee: number
    tuteur: TuteurCreateNestedOneWithoutPFEsInput
    livrables?: PFE_LivrableCreateNestedManyWithoutPfeInput
  }

  export type PFEUncheckedCreateWithoutGroupesInput = {
    idPFE?: number
    statut: number
    annee: number
    idTuteur: number
    livrables?: PFE_LivrableUncheckedCreateNestedManyWithoutPfeInput
  }

  export type PFECreateOrConnectWithoutGroupesInput = {
    where: PFEWhereUniqueInput
    create: XOR<PFECreateWithoutGroupesInput, PFEUncheckedCreateWithoutGroupesInput>
  }

  export type GroupeCreateWithoutPFEsInput = {
    nomGroupe: string
    nbEtudiants: number
    etudiants?: EtudiantGroupeCreateNestedManyWithoutGroupeInput
  }

  export type GroupeUncheckedCreateWithoutPFEsInput = {
    idGroupe?: number
    nomGroupe: string
    nbEtudiants: number
    etudiants?: EtudiantGroupeUncheckedCreateNestedManyWithoutGroupeInput
  }

  export type GroupeCreateOrConnectWithoutPFEsInput = {
    where: GroupeWhereUniqueInput
    create: XOR<GroupeCreateWithoutPFEsInput, GroupeUncheckedCreateWithoutPFEsInput>
  }

  export type PFEUpsertWithoutGroupesInput = {
    update: XOR<PFEUpdateWithoutGroupesInput, PFEUncheckedUpdateWithoutGroupesInput>
    create: XOR<PFECreateWithoutGroupesInput, PFEUncheckedCreateWithoutGroupesInput>
    where?: PFEWhereInput
  }

  export type PFEUpdateToOneWithWhereWithoutGroupesInput = {
    where?: PFEWhereInput
    data: XOR<PFEUpdateWithoutGroupesInput, PFEUncheckedUpdateWithoutGroupesInput>
  }

  export type PFEUpdateWithoutGroupesInput = {
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    tuteur?: TuteurUpdateOneRequiredWithoutPFEsNestedInput
    livrables?: PFE_LivrableUpdateManyWithoutPfeNestedInput
  }

  export type PFEUncheckedUpdateWithoutGroupesInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    idTuteur?: IntFieldUpdateOperationsInput | number
    livrables?: PFE_LivrableUncheckedUpdateManyWithoutPfeNestedInput
  }

  export type GroupeUpsertWithoutPFEsInput = {
    update: XOR<GroupeUpdateWithoutPFEsInput, GroupeUncheckedUpdateWithoutPFEsInput>
    create: XOR<GroupeCreateWithoutPFEsInput, GroupeUncheckedCreateWithoutPFEsInput>
    where?: GroupeWhereInput
  }

  export type GroupeUpdateToOneWithWhereWithoutPFEsInput = {
    where?: GroupeWhereInput
    data: XOR<GroupeUpdateWithoutPFEsInput, GroupeUncheckedUpdateWithoutPFEsInput>
  }

  export type GroupeUpdateWithoutPFEsInput = {
    nomGroupe?: StringFieldUpdateOperationsInput | string
    nbEtudiants?: IntFieldUpdateOperationsInput | number
    etudiants?: EtudiantGroupeUpdateManyWithoutGroupeNestedInput
  }

  export type GroupeUncheckedUpdateWithoutPFEsInput = {
    idGroupe?: IntFieldUpdateOperationsInput | number
    nomGroupe?: StringFieldUpdateOperationsInput | string
    nbEtudiants?: IntFieldUpdateOperationsInput | number
    etudiants?: EtudiantGroupeUncheckedUpdateManyWithoutGroupeNestedInput
  }

  export type PFECreateWithoutLivrablesInput = {
    statut: number
    annee: number
    tuteur: TuteurCreateNestedOneWithoutPFEsInput
    groupes?: PFE_GroupeCreateNestedManyWithoutPfeInput
  }

  export type PFEUncheckedCreateWithoutLivrablesInput = {
    idPFE?: number
    statut: number
    annee: number
    idTuteur: number
    groupes?: PFE_GroupeUncheckedCreateNestedManyWithoutPfeInput
  }

  export type PFECreateOrConnectWithoutLivrablesInput = {
    where: PFEWhereUniqueInput
    create: XOR<PFECreateWithoutLivrablesInput, PFEUncheckedCreateWithoutLivrablesInput>
  }

  export type LivrableCreateWithoutPFEsInput = {
    type: string
    nom: string
    annee: number
    encadrants?: EncadrantLivrableCreateNestedManyWithoutLivrableInput
    tuteurs?: TuteurLivrableCreateNestedManyWithoutLivrableInput
  }

  export type LivrableUncheckedCreateWithoutPFEsInput = {
    idLivrable?: number
    type: string
    nom: string
    annee: number
    encadrants?: EncadrantLivrableUncheckedCreateNestedManyWithoutLivrableInput
    tuteurs?: TuteurLivrableUncheckedCreateNestedManyWithoutLivrableInput
  }

  export type LivrableCreateOrConnectWithoutPFEsInput = {
    where: LivrableWhereUniqueInput
    create: XOR<LivrableCreateWithoutPFEsInput, LivrableUncheckedCreateWithoutPFEsInput>
  }

  export type PFEUpsertWithoutLivrablesInput = {
    update: XOR<PFEUpdateWithoutLivrablesInput, PFEUncheckedUpdateWithoutLivrablesInput>
    create: XOR<PFECreateWithoutLivrablesInput, PFEUncheckedCreateWithoutLivrablesInput>
    where?: PFEWhereInput
  }

  export type PFEUpdateToOneWithWhereWithoutLivrablesInput = {
    where?: PFEWhereInput
    data: XOR<PFEUpdateWithoutLivrablesInput, PFEUncheckedUpdateWithoutLivrablesInput>
  }

  export type PFEUpdateWithoutLivrablesInput = {
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    tuteur?: TuteurUpdateOneRequiredWithoutPFEsNestedInput
    groupes?: PFE_GroupeUpdateManyWithoutPfeNestedInput
  }

  export type PFEUncheckedUpdateWithoutLivrablesInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    idTuteur?: IntFieldUpdateOperationsInput | number
    groupes?: PFE_GroupeUncheckedUpdateManyWithoutPfeNestedInput
  }

  export type LivrableUpsertWithoutPFEsInput = {
    update: XOR<LivrableUpdateWithoutPFEsInput, LivrableUncheckedUpdateWithoutPFEsInput>
    create: XOR<LivrableCreateWithoutPFEsInput, LivrableUncheckedCreateWithoutPFEsInput>
    where?: LivrableWhereInput
  }

  export type LivrableUpdateToOneWithWhereWithoutPFEsInput = {
    where?: LivrableWhereInput
    data: XOR<LivrableUpdateWithoutPFEsInput, LivrableUncheckedUpdateWithoutPFEsInput>
  }

  export type LivrableUpdateWithoutPFEsInput = {
    type?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    encadrants?: EncadrantLivrableUpdateManyWithoutLivrableNestedInput
    tuteurs?: TuteurLivrableUpdateManyWithoutLivrableNestedInput
  }

  export type LivrableUncheckedUpdateWithoutPFEsInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    encadrants?: EncadrantLivrableUncheckedUpdateManyWithoutLivrableNestedInput
    tuteurs?: TuteurLivrableUncheckedUpdateManyWithoutLivrableNestedInput
  }

  export type EncadrantCreateWithoutLivrablesInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    responsableFiliere?: ResponsableFiliereCreateNestedOneWithoutEncadrantsInput
    sujets?: SujetCreateNestedManyWithoutEncadrantInput
    soutenances?: EncadrantSoutenanceCreateNestedManyWithoutEncadrantInput
  }

  export type EncadrantUncheckedCreateWithoutLivrablesInput = {
    idEncadrant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    idResponsableFiliere?: number | null
    sujets?: SujetUncheckedCreateNestedManyWithoutEncadrantInput
    soutenances?: EncadrantSoutenanceUncheckedCreateNestedManyWithoutEncadrantInput
  }

  export type EncadrantCreateOrConnectWithoutLivrablesInput = {
    where: EncadrantWhereUniqueInput
    create: XOR<EncadrantCreateWithoutLivrablesInput, EncadrantUncheckedCreateWithoutLivrablesInput>
  }

  export type LivrableCreateWithoutEncadrantsInput = {
    type: string
    nom: string
    annee: number
    PFEs?: PFE_LivrableCreateNestedManyWithoutLivrableInput
    tuteurs?: TuteurLivrableCreateNestedManyWithoutLivrableInput
  }

  export type LivrableUncheckedCreateWithoutEncadrantsInput = {
    idLivrable?: number
    type: string
    nom: string
    annee: number
    PFEs?: PFE_LivrableUncheckedCreateNestedManyWithoutLivrableInput
    tuteurs?: TuteurLivrableUncheckedCreateNestedManyWithoutLivrableInput
  }

  export type LivrableCreateOrConnectWithoutEncadrantsInput = {
    where: LivrableWhereUniqueInput
    create: XOR<LivrableCreateWithoutEncadrantsInput, LivrableUncheckedCreateWithoutEncadrantsInput>
  }

  export type EncadrantUpsertWithoutLivrablesInput = {
    update: XOR<EncadrantUpdateWithoutLivrablesInput, EncadrantUncheckedUpdateWithoutLivrablesInput>
    create: XOR<EncadrantCreateWithoutLivrablesInput, EncadrantUncheckedCreateWithoutLivrablesInput>
    where?: EncadrantWhereInput
  }

  export type EncadrantUpdateToOneWithWhereWithoutLivrablesInput = {
    where?: EncadrantWhereInput
    data: XOR<EncadrantUpdateWithoutLivrablesInput, EncadrantUncheckedUpdateWithoutLivrablesInput>
  }

  export type EncadrantUpdateWithoutLivrablesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    responsableFiliere?: ResponsableFiliereUpdateOneWithoutEncadrantsNestedInput
    sujets?: SujetUpdateManyWithoutEncadrantNestedInput
    soutenances?: EncadrantSoutenanceUpdateManyWithoutEncadrantNestedInput
  }

  export type EncadrantUncheckedUpdateWithoutLivrablesInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    idResponsableFiliere?: NullableIntFieldUpdateOperationsInput | number | null
    sujets?: SujetUncheckedUpdateManyWithoutEncadrantNestedInput
    soutenances?: EncadrantSoutenanceUncheckedUpdateManyWithoutEncadrantNestedInput
  }

  export type LivrableUpsertWithoutEncadrantsInput = {
    update: XOR<LivrableUpdateWithoutEncadrantsInput, LivrableUncheckedUpdateWithoutEncadrantsInput>
    create: XOR<LivrableCreateWithoutEncadrantsInput, LivrableUncheckedCreateWithoutEncadrantsInput>
    where?: LivrableWhereInput
  }

  export type LivrableUpdateToOneWithWhereWithoutEncadrantsInput = {
    where?: LivrableWhereInput
    data: XOR<LivrableUpdateWithoutEncadrantsInput, LivrableUncheckedUpdateWithoutEncadrantsInput>
  }

  export type LivrableUpdateWithoutEncadrantsInput = {
    type?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    PFEs?: PFE_LivrableUpdateManyWithoutLivrableNestedInput
    tuteurs?: TuteurLivrableUpdateManyWithoutLivrableNestedInput
  }

  export type LivrableUncheckedUpdateWithoutEncadrantsInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    PFEs?: PFE_LivrableUncheckedUpdateManyWithoutLivrableNestedInput
    tuteurs?: TuteurLivrableUncheckedUpdateManyWithoutLivrableNestedInput
  }

  export type TuteurCreateWithoutLivrablesInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    classe: string
    filiere: string
    annee: number
    PFEs?: PFECreateNestedManyWithoutTuteurInput
  }

  export type TuteurUncheckedCreateWithoutLivrablesInput = {
    idTuteur?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    classe: string
    filiere: string
    annee: number
    PFEs?: PFEUncheckedCreateNestedManyWithoutTuteurInput
  }

  export type TuteurCreateOrConnectWithoutLivrablesInput = {
    where: TuteurWhereUniqueInput
    create: XOR<TuteurCreateWithoutLivrablesInput, TuteurUncheckedCreateWithoutLivrablesInput>
  }

  export type LivrableCreateWithoutTuteursInput = {
    type: string
    nom: string
    annee: number
    PFEs?: PFE_LivrableCreateNestedManyWithoutLivrableInput
    encadrants?: EncadrantLivrableCreateNestedManyWithoutLivrableInput
  }

  export type LivrableUncheckedCreateWithoutTuteursInput = {
    idLivrable?: number
    type: string
    nom: string
    annee: number
    PFEs?: PFE_LivrableUncheckedCreateNestedManyWithoutLivrableInput
    encadrants?: EncadrantLivrableUncheckedCreateNestedManyWithoutLivrableInput
  }

  export type LivrableCreateOrConnectWithoutTuteursInput = {
    where: LivrableWhereUniqueInput
    create: XOR<LivrableCreateWithoutTuteursInput, LivrableUncheckedCreateWithoutTuteursInput>
  }

  export type TuteurUpsertWithoutLivrablesInput = {
    update: XOR<TuteurUpdateWithoutLivrablesInput, TuteurUncheckedUpdateWithoutLivrablesInput>
    create: XOR<TuteurCreateWithoutLivrablesInput, TuteurUncheckedCreateWithoutLivrablesInput>
    where?: TuteurWhereInput
  }

  export type TuteurUpdateToOneWithWhereWithoutLivrablesInput = {
    where?: TuteurWhereInput
    data: XOR<TuteurUpdateWithoutLivrablesInput, TuteurUncheckedUpdateWithoutLivrablesInput>
  }

  export type TuteurUpdateWithoutLivrablesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    PFEs?: PFEUpdateManyWithoutTuteurNestedInput
  }

  export type TuteurUncheckedUpdateWithoutLivrablesInput = {
    idTuteur?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    classe?: StringFieldUpdateOperationsInput | string
    filiere?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    PFEs?: PFEUncheckedUpdateManyWithoutTuteurNestedInput
  }

  export type LivrableUpsertWithoutTuteursInput = {
    update: XOR<LivrableUpdateWithoutTuteursInput, LivrableUncheckedUpdateWithoutTuteursInput>
    create: XOR<LivrableCreateWithoutTuteursInput, LivrableUncheckedCreateWithoutTuteursInput>
    where?: LivrableWhereInput
  }

  export type LivrableUpdateToOneWithWhereWithoutTuteursInput = {
    where?: LivrableWhereInput
    data: XOR<LivrableUpdateWithoutTuteursInput, LivrableUncheckedUpdateWithoutTuteursInput>
  }

  export type LivrableUpdateWithoutTuteursInput = {
    type?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    PFEs?: PFE_LivrableUpdateManyWithoutLivrableNestedInput
    encadrants?: EncadrantLivrableUpdateManyWithoutLivrableNestedInput
  }

  export type LivrableUncheckedUpdateWithoutTuteursInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    PFEs?: PFE_LivrableUncheckedUpdateManyWithoutLivrableNestedInput
    encadrants?: EncadrantLivrableUncheckedUpdateManyWithoutLivrableNestedInput
  }

  export type EncadrantCreateWithoutSoutenancesInput = {
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    responsableFiliere?: ResponsableFiliereCreateNestedOneWithoutEncadrantsInput
    sujets?: SujetCreateNestedManyWithoutEncadrantInput
    livrables?: EncadrantLivrableCreateNestedManyWithoutEncadrantInput
  }

  export type EncadrantUncheckedCreateWithoutSoutenancesInput = {
    idEncadrant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
    idResponsableFiliere?: number | null
    sujets?: SujetUncheckedCreateNestedManyWithoutEncadrantInput
    livrables?: EncadrantLivrableUncheckedCreateNestedManyWithoutEncadrantInput
  }

  export type EncadrantCreateOrConnectWithoutSoutenancesInput = {
    where: EncadrantWhereUniqueInput
    create: XOR<EncadrantCreateWithoutSoutenancesInput, EncadrantUncheckedCreateWithoutSoutenancesInput>
  }

  export type SoutenanceCreateWithoutEncadrantsInput = {
    date: Date | string
    heure: Date | string
    jury: JuryCreateNestedOneWithoutSoutenancesInput
    evaluations?: EvaluationCreateNestedManyWithoutSoutenanceInput
  }

  export type SoutenanceUncheckedCreateWithoutEncadrantsInput = {
    idSoutenance?: number
    date: Date | string
    heure: Date | string
    idJury: number
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSoutenanceInput
  }

  export type SoutenanceCreateOrConnectWithoutEncadrantsInput = {
    where: SoutenanceWhereUniqueInput
    create: XOR<SoutenanceCreateWithoutEncadrantsInput, SoutenanceUncheckedCreateWithoutEncadrantsInput>
  }

  export type EncadrantUpsertWithoutSoutenancesInput = {
    update: XOR<EncadrantUpdateWithoutSoutenancesInput, EncadrantUncheckedUpdateWithoutSoutenancesInput>
    create: XOR<EncadrantCreateWithoutSoutenancesInput, EncadrantUncheckedCreateWithoutSoutenancesInput>
    where?: EncadrantWhereInput
  }

  export type EncadrantUpdateToOneWithWhereWithoutSoutenancesInput = {
    where?: EncadrantWhereInput
    data: XOR<EncadrantUpdateWithoutSoutenancesInput, EncadrantUncheckedUpdateWithoutSoutenancesInput>
  }

  export type EncadrantUpdateWithoutSoutenancesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    responsableFiliere?: ResponsableFiliereUpdateOneWithoutEncadrantsNestedInput
    sujets?: SujetUpdateManyWithoutEncadrantNestedInput
    livrables?: EncadrantLivrableUpdateManyWithoutEncadrantNestedInput
  }

  export type EncadrantUncheckedUpdateWithoutSoutenancesInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    idResponsableFiliere?: NullableIntFieldUpdateOperationsInput | number | null
    sujets?: SujetUncheckedUpdateManyWithoutEncadrantNestedInput
    livrables?: EncadrantLivrableUncheckedUpdateManyWithoutEncadrantNestedInput
  }

  export type SoutenanceUpsertWithoutEncadrantsInput = {
    update: XOR<SoutenanceUpdateWithoutEncadrantsInput, SoutenanceUncheckedUpdateWithoutEncadrantsInput>
    create: XOR<SoutenanceCreateWithoutEncadrantsInput, SoutenanceUncheckedCreateWithoutEncadrantsInput>
    where?: SoutenanceWhereInput
  }

  export type SoutenanceUpdateToOneWithWhereWithoutEncadrantsInput = {
    where?: SoutenanceWhereInput
    data: XOR<SoutenanceUpdateWithoutEncadrantsInput, SoutenanceUncheckedUpdateWithoutEncadrantsInput>
  }

  export type SoutenanceUpdateWithoutEncadrantsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
    jury?: JuryUpdateOneRequiredWithoutSoutenancesNestedInput
    evaluations?: EvaluationUpdateManyWithoutSoutenanceNestedInput
  }

  export type SoutenanceUncheckedUpdateWithoutEncadrantsInput = {
    idSoutenance?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
    idJury?: IntFieldUpdateOperationsInput | number
    evaluations?: EvaluationUncheckedUpdateManyWithoutSoutenanceNestedInput
  }

  export type EncadrantCreateManyResponsableFiliereInput = {
    idEncadrant?: number
    nom: string
    prenom: string
    email: string
    motDePasse: string
    annee: number
  }

  export type EncadrantUpdateWithoutResponsableFiliereInput = {
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    sujets?: SujetUpdateManyWithoutEncadrantNestedInput
    soutenances?: EncadrantSoutenanceUpdateManyWithoutEncadrantNestedInput
    livrables?: EncadrantLivrableUpdateManyWithoutEncadrantNestedInput
  }

  export type EncadrantUncheckedUpdateWithoutResponsableFiliereInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    sujets?: SujetUncheckedUpdateManyWithoutEncadrantNestedInput
    soutenances?: EncadrantSoutenanceUncheckedUpdateManyWithoutEncadrantNestedInput
    livrables?: EncadrantLivrableUncheckedUpdateManyWithoutEncadrantNestedInput
  }

  export type EncadrantUncheckedUpdateManyWithoutResponsableFiliereInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    motDePasse?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type SujetCreateManyEncadrantInput = {
    idSujet?: number
    titre: string
    description: string
    annee: number
  }

  export type EncadrantSoutenanceCreateManyEncadrantInput = {
    idSoutenance: number
  }

  export type EncadrantLivrableCreateManyEncadrantInput = {
    idLivrable: number
  }

  export type SujetUpdateWithoutEncadrantInput = {
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    etudiants?: EtudiantSujetUpdateManyWithoutSujetNestedInput
  }

  export type SujetUncheckedUpdateWithoutEncadrantInput = {
    idSujet?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    etudiants?: EtudiantSujetUncheckedUpdateManyWithoutSujetNestedInput
  }

  export type SujetUncheckedUpdateManyWithoutEncadrantInput = {
    idSujet?: IntFieldUpdateOperationsInput | number
    titre?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantSoutenanceUpdateWithoutEncadrantInput = {
    soutenance?: SoutenanceUpdateOneRequiredWithoutEncadrantsNestedInput
  }

  export type EncadrantSoutenanceUncheckedUpdateWithoutEncadrantInput = {
    idSoutenance?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantSoutenanceUncheckedUpdateManyWithoutEncadrantInput = {
    idSoutenance?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantLivrableUpdateWithoutEncadrantInput = {
    livrable?: LivrableUpdateOneRequiredWithoutEncadrantsNestedInput
  }

  export type EncadrantLivrableUncheckedUpdateWithoutEncadrantInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantLivrableUncheckedUpdateManyWithoutEncadrantInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type PFECreateManyTuteurInput = {
    idPFE?: number
    statut: number
    annee: number
  }

  export type TuteurLivrableCreateManyTuteurInput = {
    idLivrable: number
  }

  export type PFEUpdateWithoutTuteurInput = {
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    groupes?: PFE_GroupeUpdateManyWithoutPfeNestedInput
    livrables?: PFE_LivrableUpdateManyWithoutPfeNestedInput
  }

  export type PFEUncheckedUpdateWithoutTuteurInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    groupes?: PFE_GroupeUncheckedUpdateManyWithoutPfeNestedInput
    livrables?: PFE_LivrableUncheckedUpdateManyWithoutPfeNestedInput
  }

  export type PFEUncheckedUpdateManyWithoutTuteurInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
    statut?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
  }

  export type TuteurLivrableUpdateWithoutTuteurInput = {
    livrable?: LivrableUpdateOneRequiredWithoutTuteursNestedInput
  }

  export type TuteurLivrableUncheckedUpdateWithoutTuteurInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type TuteurLivrableUncheckedUpdateManyWithoutTuteurInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantGroupeCreateManyEtudiantInput = {
    idGroupe: number
  }

  export type EtudiantSujetCreateManyEtudiantInput = {
    idSujet: number
  }

  export type EvaluationCreateManyEtudiantInput = {
    idEvaluation?: number
    note: number
    feedback?: string | null
    idSoutenance: number
  }

  export type EtudiantGroupeUpdateWithoutEtudiantInput = {
    groupe?: GroupeUpdateOneRequiredWithoutEtudiantsNestedInput
  }

  export type EtudiantGroupeUncheckedUpdateWithoutEtudiantInput = {
    idGroupe?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantGroupeUncheckedUpdateManyWithoutEtudiantInput = {
    idGroupe?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantSujetUpdateWithoutEtudiantInput = {
    sujet?: SujetUpdateOneRequiredWithoutEtudiantsNestedInput
  }

  export type EtudiantSujetUncheckedUpdateWithoutEtudiantInput = {
    idSujet?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantSujetUncheckedUpdateManyWithoutEtudiantInput = {
    idSujet?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluationUpdateWithoutEtudiantInput = {
    note?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    soutenance?: SoutenanceUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutEtudiantInput = {
    idEvaluation?: IntFieldUpdateOperationsInput | number
    note?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    idSoutenance?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluationUncheckedUpdateManyWithoutEtudiantInput = {
    idEvaluation?: IntFieldUpdateOperationsInput | number
    note?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    idSoutenance?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantGroupeCreateManyGroupeInput = {
    idEtudiant: number
  }

  export type PFE_GroupeCreateManyGroupeInput = {
    idPFE: number
  }

  export type EtudiantGroupeUpdateWithoutGroupeInput = {
    etudiant?: EtudiantUpdateOneRequiredWithoutGroupesNestedInput
  }

  export type EtudiantGroupeUncheckedUpdateWithoutGroupeInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantGroupeUncheckedUpdateManyWithoutGroupeInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_GroupeUpdateWithoutGroupeInput = {
    pfe?: PFEUpdateOneRequiredWithoutGroupesNestedInput
  }

  export type PFE_GroupeUncheckedUpdateWithoutGroupeInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_GroupeUncheckedUpdateManyWithoutGroupeInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantSujetCreateManySujetInput = {
    idEtudiant: number
  }

  export type EtudiantSujetUpdateWithoutSujetInput = {
    etudiant?: EtudiantUpdateOneRequiredWithoutSujetsNestedInput
  }

  export type EtudiantSujetUncheckedUpdateWithoutSujetInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
  }

  export type EtudiantSujetUncheckedUpdateManyWithoutSujetInput = {
    idEtudiant?: IntFieldUpdateOperationsInput | number
  }

  export type SoutenanceCreateManyJuryInput = {
    idSoutenance?: number
    date: Date | string
    heure: Date | string
  }

  export type SoutenanceUpdateWithoutJuryInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
    encadrants?: EncadrantSoutenanceUpdateManyWithoutSoutenanceNestedInput
    evaluations?: EvaluationUpdateManyWithoutSoutenanceNestedInput
  }

  export type SoutenanceUncheckedUpdateWithoutJuryInput = {
    idSoutenance?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
    encadrants?: EncadrantSoutenanceUncheckedUpdateManyWithoutSoutenanceNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutSoutenanceNestedInput
  }

  export type SoutenanceUncheckedUpdateManyWithoutJuryInput = {
    idSoutenance?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heure?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncadrantSoutenanceCreateManySoutenanceInput = {
    idEncadrant: number
  }

  export type EvaluationCreateManySoutenanceInput = {
    idEvaluation?: number
    note: number
    feedback?: string | null
    idEtudiant: number
  }

  export type EncadrantSoutenanceUpdateWithoutSoutenanceInput = {
    encadrant?: EncadrantUpdateOneRequiredWithoutSoutenancesNestedInput
  }

  export type EncadrantSoutenanceUncheckedUpdateWithoutSoutenanceInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantSoutenanceUncheckedUpdateManyWithoutSoutenanceInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluationUpdateWithoutSoutenanceInput = {
    note?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    etudiant?: EtudiantUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutSoutenanceInput = {
    idEvaluation?: IntFieldUpdateOperationsInput | number
    note?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    idEtudiant?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluationUncheckedUpdateManyWithoutSoutenanceInput = {
    idEvaluation?: IntFieldUpdateOperationsInput | number
    note?: FloatFieldUpdateOperationsInput | number
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    idEtudiant?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_LivrableCreateManyLivrableInput = {
    idPFE: number
  }

  export type EncadrantLivrableCreateManyLivrableInput = {
    idEncadrant: number
  }

  export type TuteurLivrableCreateManyLivrableInput = {
    idTuteur: number
  }

  export type PFE_LivrableUpdateWithoutLivrableInput = {
    pfe?: PFEUpdateOneRequiredWithoutLivrablesNestedInput
  }

  export type PFE_LivrableUncheckedUpdateWithoutLivrableInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_LivrableUncheckedUpdateManyWithoutLivrableInput = {
    idPFE?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantLivrableUpdateWithoutLivrableInput = {
    encadrant?: EncadrantUpdateOneRequiredWithoutLivrablesNestedInput
  }

  export type EncadrantLivrableUncheckedUpdateWithoutLivrableInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
  }

  export type EncadrantLivrableUncheckedUpdateManyWithoutLivrableInput = {
    idEncadrant?: IntFieldUpdateOperationsInput | number
  }

  export type TuteurLivrableUpdateWithoutLivrableInput = {
    tuteur?: TuteurUpdateOneRequiredWithoutLivrablesNestedInput
  }

  export type TuteurLivrableUncheckedUpdateWithoutLivrableInput = {
    idTuteur?: IntFieldUpdateOperationsInput | number
  }

  export type TuteurLivrableUncheckedUpdateManyWithoutLivrableInput = {
    idTuteur?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_GroupeCreateManyPfeInput = {
    idGroupe: number
  }

  export type PFE_LivrableCreateManyPfeInput = {
    idLivrable: number
  }

  export type PFE_GroupeUpdateWithoutPfeInput = {
    groupe?: GroupeUpdateOneRequiredWithoutPFEsNestedInput
  }

  export type PFE_GroupeUncheckedUpdateWithoutPfeInput = {
    idGroupe?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_GroupeUncheckedUpdateManyWithoutPfeInput = {
    idGroupe?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_LivrableUpdateWithoutPfeInput = {
    livrable?: LivrableUpdateOneRequiredWithoutPFEsNestedInput
  }

  export type PFE_LivrableUncheckedUpdateWithoutPfeInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
  }

  export type PFE_LivrableUncheckedUpdateManyWithoutPfeInput = {
    idLivrable?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}